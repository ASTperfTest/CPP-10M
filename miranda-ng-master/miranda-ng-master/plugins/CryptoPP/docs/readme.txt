
-*-*-*-*-*-*-*-*- Описание RSA/AES алгоритма (наиболее свежее) -*-*-*-*-*-*-*-*-


Реализовано только RSA4096/AES256, без выбора длин ключей


стороны (1) и (2) - участнки установки криптосессии
sha(1) и sha(2) - sha от пабликов (или md5)
tlv() - type length value (формат упаковки значений)

priv = privkey
pub = tlv(1,mod)+tlv(2,exp)


rsa_init(pRSA_EXPORT* e,pRSA_IMPORT i)
rsa_done()

(cpp) rsa_gen_keypair(PBYTE priv, int* len, PBYTE pub, int* len) cntx==-2
(cpp) rsa_set_keypair(priv,len,pub,len) cntx==-2

(cpp) rsa_connect(cntx,pub,len) - установить криптосессию
(cpp) rsa_disconnect(cntx) - разорвать криптосессию
(cpp) rsa_recv(cntx,msg) - все принятые сообщения засоваем сюда, возвращает 0, или расшифрованное сообщение
(cpp) rsa_send(cntx,msg) - все отправляемые сообщения засоваем сюда, возвращает статус отправлено или нет

(sim) rsa_inject(cntx,msg) - вставляет сообщение в очередь на отправку на ту сторону, возвращает ок или не ок
(sim) rsa_check_pub(cntx,sha,sha_len,pub,pub_len) - диалог для проверки sha и если ок - то надо сохранить ключ в базе, возвращает ок или не ок
(sim) rsa_notify(cntx,int) - нотификация о установке/разрыве криптосессии (event)


RSA_EXPORT rsa;
RSA_IMPORT cb = {
	rsa_inject,
	rsa_check_pub,
	rsa_notify
};


сторона (1|2): пришла преамбула(0)
if( state ) {
	state=0
	send(преамбула(0)) - завершаем сессию, если была открыта
	"не могу установить соединение!"
}

сторона (1): преамбула(1), base64(поддерживаемые фичи, sha(1), sha(2)) [2]

сторона (2): пришла преамбула(1)
1 обе sha совпали?       преамбула(2.1), base64(rsa(aes ключ и вектор), подпись rsa)        [5]
2 совпала только sha(1)? преамбула(2.2), base64(выбранные фичи, rsa-паблик свой(2), sha)    [3.2]
3 совпала только sha(2)? преамбула(2.3), base64(выбранные фичи, запрос rsa-паблика(1), sha) [3.3]
4 не совпало ничего!     преамбула(2.4), base64(выбранные фичи, rsa-паблик свой(2), sha)    [3.4]

сторона (1): пришла преамбула(2)
1 преамбула(2.1) - преамбула(5), base64(aes("random"),sha) [6]
2 преамбула(2.2) - выдали sha(2) для проверки. преамбула(3.2), base64(rsa(aes ключ и вектор), подпись rsa) [5]
3 преамбула(2.3) -                             преамбула(3.3), base64(rsa-паблик свой(1), sha)             [4]
4 преамбула(2.4) - выдали sha(2) для проверки. преамбула(3.4), base64(rsa-паблик свой(1), sha)             [4]

сторона (2): пришла преамбула(3)
1 
2 преамбула(3.2) - преамбула(5), base64(aes("random"),sha) [6]
3 преамбула(3.3) - выдали sha(1) для проверки. преамбула(4), base64(rsa(aes ключ и вектор), подпись rsa) [5]
4 преамбула(3.4) - выдали sha(1) для проверки. преамбула(4), base64(rsa(aes ключ и вектор), подпись rsa) [5]

сторона (1): пришла преамбула(4)
1 преамбула(4) - преамбула(5), base64(aes("random"),sha) [6]

сторона (1|2): пришла преамбула(5)
преамбула(6), base64(aes("random_new"),sha) [7]
"!!!криптосессия открыта!!!"

сторона (1|2): пришла преамбула(6)
"!!!криптосессия открыта!!!" [7]

сторона (1|2): пришла преамбула(7) - зашифрованное сообщение

сторона (1|2): пришла преамбула(F)
if( state ) {
	state=0
	"disconnected by other side"
}


Заметка0: вводим счетчик и увеличиваем его на каждом шаге, если приходит сообщение не с этого шага или не проходит проверка,
  обрываем обмен ключами и посылаем преамбула(0)
  заводим таймер после отправки каждого сообщения, если истекло время - то шлем преамбула(0) и прерываем сесиию

Заметка1: Пользователь должен быть вкурсе о выбранных фичах и в интерфейс хорошо ссыпать каждое из возможных
  5-ти событий, чтобы можно было контролировать возможный спам (мало ли). Информирование о шагах также
  благоприятствует уведомлению о переустановке сессии - для пользователя повышение внимания.

Заметка2: Для криптосессии - преамбула(7), aes(zlib(сообщение))
  zlib - без заголовка, сброс потока перед каждым сообщением. Сжимается вне зависимости от избыточности
  (можно вынести в фичи, но по-моему не зачем).

Заметка3: выбранные фичи относятся к поддерживаемым алгоритмам симетричным (если будешь делать поддержку
  других, то можно и асим туда включить): размер ключа и блока.
  Минимальные: RSA-2048, AES-128/128.


// EOF
