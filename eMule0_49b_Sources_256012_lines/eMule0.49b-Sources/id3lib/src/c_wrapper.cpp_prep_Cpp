// $Id: c_wrapper.cpp,v 1.22 2002/09/21 17:23:32 t1mpy Exp $

// id3lib: a C++ library for creating and manipulating id3v1/v2 tags
// Copyright 1999, 2000  Scott Thomas Haug
// Copyright 2002 Thijmen Klok (thijmen@id3lib.org)

// This library is free software; you can redistribute it and/or modify it
// under the terms of the     Library General Public License as published by
// the Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// This library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of                 or
// FITNESS     A            PURPOSE.  See the     Library General Public
// License for more details.
//
// You should have received a copy of the     Library General Public License
// along with this library; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

// The id3lib authors encourage improvements and optimisations to be sent to
// the id3lib coordinator.  Please see the        file for details on where to
// send such submissions.  See the         file for a list of people who have
// contributed to id3lib.  See the ChangeLog file for a list of changes to
// id3lib.  These files are distributed with id3lib at
// http://download.sourceforge.net/id3lib/

//#include <string.h>
void INCLUDEREPLACE(){CX_INCL("id3.h");}
void INCLUDEREPLACE(){CX_INCL("tag.h");}
void INCLUDEREPLACE(){CX_INCL("field.h");}


void INCLUDEREPLACE(){CX_INCL("config.h");}




{
       /* __cplusplus */

  // tag wrappers



  ID3_C_EXPORT ID3Tag* CCONV
  ID3Tag_New(void)
  {
    ID3_Tag* tag = NULL;
    try { tag = new ID3_Tag; } catch (...) { };
    return reinterpret_cast          (tag);
  }


  ID3_C_EXPORT void      
  ID3Tag_Delete(ID3Tag *tag)
  {
    if (tag)
    {
      try { delete reinterpret_cast          (tag); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Tag_Clear(ID3Tag *tag)
  {
    if (tag)
    {
      try { reinterpret_cast          (tag)->Clear(); } catch (...) { };
    }
  }


  ID3_C_EXPORT bool      
  ID3Tag_HasChanged(const ID3Tag *tag)
  {
    bool changed = false;

    if (tag)
    {
      try { changed = reinterpret_cast                  (tag)->HasChanged(); } catch (...) { };
    }

    return changed;
  }


  ID3_C_EXPORT void      
  ID3Tag_SetUnsync(ID3Tag *tag, bool unsync)
  {
    if (tag)
    {
      try { reinterpret_cast           (tag)->SetUnsync(unsync); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Tag_SetExtendedHeader(ID3Tag *tag, bool ext)
  {
    if (tag)
    {
      try { reinterpret_cast           (tag)->SetExtendedHeader(ext); } catch (...) { };
    }
  }

  ID3_C_EXPORT void      
  ID3Tag_SetPadding(ID3Tag *tag, bool pad)
  {
    if (tag)
    {
      try { reinterpret_cast           (tag)->SetPadding(pad); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Tag_AddFrame(ID3Tag *tag, const ID3Frame *frame)
  {
    if (tag)
    {
      try { reinterpret_cast           (tag)->AddFrame(reinterpret_cast                   (frame)); } catch (...) { };
    }
  }


  ID3_C_EXPORT bool      
  ID3Tag_AttachFrame(ID3Tag *tag, ID3Frame *frame)
  {
    bool b = false;
    if (tag)
    {
      try { b = reinterpret_cast           (tag)->AttachFrame(reinterpret_cast             (frame)); } catch (...) { };
    }
    return b;
  }


  ID3_C_EXPORT void      
  ID3Tag_AddFrames(ID3Tag *tag, const ID3Frame *frames, size_t num)
  {
    if (tag)
    {
      try { reinterpret_cast           (tag)->AddFrames(reinterpret_cast                   (frames), num); } catch (...) { };
    }
  }


  ID3_C_EXPORT ID3Frame* CCONV
  ID3Tag_RemoveFrame(ID3Tag *tag, const ID3Frame *frame)
  {
    ID3_Frame* rem_frame = NULL;
    if (tag)
    {
      try { rem_frame = reinterpret_cast           (tag)->RemoveFrame(reinterpret_cast                   (frame)); } catch (...) { };
    }
    return reinterpret_cast           (rem_frame);
  }


  ID3_C_EXPORT ID3_Err      
  ID3Tag_Parse(ID3Tag *tag, const uchar header[ ID3_TAGHEADERSIZE ],
               const uchar *buffer)
  {
    size_t size = 0;
    if (tag)
    {
      try { size = reinterpret_cast           (tag)->Parse(header, buffer); } catch (...) { };
    }
    return ID3E_NoError;
  }


  ID3_C_EXPORT size_t      
  ID3Tag_Link(ID3Tag *tag, const char *fileName)
  {
    size_t offset = 0;
    if (tag)
    {
      try { offset = reinterpret_cast           (tag)->Link(fileName); } catch (...) { };
    }
    return offset;
  }

  ID3_C_EXPORT size_t      
  ID3Tag_LinkWithFlags(ID3Tag *tag, const char *fileName, flags_t flags)
  {
    size_t offset = 0;
    if (tag)
    {
      try { offset = reinterpret_cast           (tag)->Link(fileName,flags); } catch (...) { };
    }
    return offset;
  }



  ID3_C_EXPORT ID3_Err      
  ID3Tag_Update(ID3Tag *tag)
  {
    flags_t flags = 0;
    if (tag)
    {
      try { flags = reinterpret_cast           (tag)->Update(); } catch (...) { };
    }
    return ID3E_NoError;
  }

  ID3_C_EXPORT ID3_Err      
  ID3Tag_UpdateByTagType(ID3Tag *tag, flags_t tag_type)
  {
    flags_t flags = 0;
    if (tag)
    {
      try { flags = reinterpret_cast           (tag)->Update(tag_type); } catch (...) { };
    }
    return ID3E_NoError;
  }


  ID3_C_EXPORT ID3_Err      
  ID3Tag_Strip(ID3Tag *tag, flags_t ulTagFlags)
  {
    if (tag)
    {
      try { reinterpret_cast           (tag)->Strip(ulTagFlags); } catch (...) { };
    }
    return ID3E_NoError;
  }


  ID3_C_EXPORT ID3Frame* CCONV
  ID3Tag_FindFrameWithID(const ID3Tag *tag, ID3_FrameID id)
  {
    ID3_Frame *frame = NULL;

    if (tag)
    {
      try { frame = reinterpret_cast                 (tag)->Find(id); } catch (...) { };
    }

    return reinterpret_cast            (frame);
  }


  ID3_C_EXPORT ID3Frame* CCONV
  ID3Tag_FindFrameWithINT(const ID3Tag *tag, ID3_FrameID id,
                          ID3_FieldID fld, uint32 data)
  {
    ID3_Frame *frame = NULL;

    if (tag)
    {
      try { frame = reinterpret_cast                 (tag)->Find(id, fld, data); } catch (...) { };
    }

    return reinterpret_cast            (frame);
  }


  ID3_C_EXPORT ID3Frame* CCONV
  ID3Tag_FindFrameWithASCII(const ID3Tag *tag, ID3_FrameID id,
                            ID3_FieldID fld, const char *data)
  {
    ID3_Frame *frame = NULL;

    if (tag)
    {
      try { frame = reinterpret_cast                 (tag)->Find(id, fld, data); } catch (...) { };
    }

    return reinterpret_cast            (frame);
  }


  ID3_C_EXPORT ID3Frame* CCONV
  ID3Tag_FindFrameWithUNICODE(const ID3Tag *tag, ID3_FrameID id,
                              ID3_FieldID fld, const unicode_t *data)
  {
    ID3_Frame *frame = NULL;

    if (tag)
    {
      try { frame = reinterpret_cast                 (tag)->Find(id, fld, data); } catch (...) { };
    }

    return reinterpret_cast            (frame);
  }


  ID3_C_EXPORT size_t      
  ID3Tag_NumFrames(const ID3Tag *tag)
  {
    size_t num = 0;

    if (tag)
    {
      try { num = reinterpret_cast                 (tag)->NumFrames(); } catch (...) { };
    }

    return num;
  }


  ID3_C_EXPORT bool      
  ID3Tag_HasTagType(const ID3Tag *tag, ID3_TagType tt)
  {
    bool has_tt = false;

    if (tag)
    {
      try { has_tt = reinterpret_cast                 (tag)->HasTagType(tt); } catch (...) { };
    }

    return has_tt;
  }

  ID3_C_EXPORT ID3TagIterator* CCONV
  ID3Tag_CreateIterator(ID3Tag* tag)
  {
    ID3_Tag::Iterator* iter = NULL;

    if (tag)
    {
      try { iter = reinterpret_cast          (tag)->CreateIterator(); } catch (...) { };
    }

    return reinterpret_cast                 (iter);
  }

  ID3_C_EXPORT ID3TagConstIterator* CCONV
  ID3Tag_CreateConstIterator(const ID3Tag* tag)
  {
    ID3_Tag::ConstIterator* iter = NULL;

    if (tag)
    {
      try { iter = reinterpret_cast                (tag)->CreateIterator(); } catch (...) { };
    }

    return reinterpret_cast                      (iter);
  }

  ID3_C_EXPORT void      
  ID3TagIterator_Delete(ID3TagIterator *iter)
  {
    if (iter)
    {
      try { delete reinterpret_cast                    (iter); } catch (...) { };
    }
  }

  ID3_C_EXPORT ID3Frame* CCONV
  ID3TagIterator_GetNext(ID3TagIterator *iter)
  {
    ID3_Frame* frame = NULL;
    if (iter)
    {
      try { frame = reinterpret_cast                    (iter)->GetNext(); } catch (...) { };
    }
    return reinterpret_cast           (frame);
  }

  ID3_C_EXPORT void      
  ID3TagConstIterator_Delete(ID3TagConstIterator *iter)
  {
    if (iter)
    {
      try { delete reinterpret_cast                         (iter); } catch (...) { };
    }
  }

  ID3_C_EXPORT const ID3Frame* CCONV
  ID3TagConstIterator_GetNext(ID3TagConstIterator *iter)
  {
    const ID3_Frame* frame = NULL;
    if (iter)
    {
      try { frame = reinterpret_cast                         (iter)->GetNext(); } catch (...) { };
    }
    return reinterpret_cast                 (frame);
  }

  // frame wrappers

  ID3_C_EXPORT ID3Frame* CCONV
  ID3Frame_New(void)
  {
    ID3_Frame* frame = NULL;
    try { frame = new ID3_Frame; } catch (...) { };
    return reinterpret_cast            (frame);
  }

  ID3_C_EXPORT ID3Frame* CCONV
  ID3Frame_NewID(ID3_FrameID id)
  {
    ID3_Frame* frame = NULL;
    try { frame = new ID3_Frame(id); } catch (...) { };
    return reinterpret_cast            (frame);
  }

  ID3_C_EXPORT void      
  ID3Frame_Delete(ID3Frame *frame)
  {
    if (frame)
    {
      try { delete reinterpret_cast             (frame); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Frame_Clear(ID3Frame *frame)
  {
    if (frame)
    {
      try { reinterpret_cast             (frame)->Clear(); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Frame_SetID(ID3Frame *frame, ID3_FrameID id)
  {
    if (frame)
    {
      try { reinterpret_cast             (frame)->SetID(id); } catch (...) { };
    }
  }


  ID3_C_EXPORT ID3_FrameID      
  ID3Frame_GetID(const ID3Frame *frame)
  {
    ID3_FrameID id = ID3FID_NOFRAME;

    if (frame)
    {
      try { id = reinterpret_cast                   (frame)->GetID(); } catch (...) { };
    }

    return id;
  }


  ID3_C_EXPORT ID3Field* CCONV
  ID3Frame_GetField(const ID3Frame *frame, ID3_FieldID name)
  {
    ID3_Field *field = NULL;

    if (frame)
    {
      try { field = reinterpret_cast                   (frame)->GetField(name); } catch (...) { };
    }

    return reinterpret_cast            (field);
  }


  ID3_C_EXPORT void      
  ID3Frame_SetCompression(ID3Frame *frame, bool comp)
  {
    if (frame)
    {
      try { reinterpret_cast             (frame)->SetCompression(comp); } catch (...) { };
    }
  }


  ID3_C_EXPORT bool      
  ID3Frame_GetCompression(const ID3Frame *frame)
  {
    bool compressed = false;
    if (frame)
    {
      try { compressed = reinterpret_cast                   (frame)->GetCompression(); } catch (...) { };
    }
    return compressed;
  }


  // field wrappers


  ID3_C_EXPORT void      
  ID3Field_Clear(ID3Field *field)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->Clear(); } catch (...) { };
    }
  }


  ID3_C_EXPORT size_t      
  ID3Field_Size(const ID3Field *field)
  {
    size_t size = 0;

    if (field)
    {
      try { size = reinterpret_cast                   (field)->Size(); } catch (...) { };
    }

    return size;
  }


  ID3_C_EXPORT size_t      
  ID3Field_GetNumTextItems(const ID3Field *field)
  {
    size_t items = 0;

    if (field)
    {
      try { items = reinterpret_cast                   (field)->GetNumTextItems(); } catch (...) { };
    }

    return items;
  }


  ID3_C_EXPORT void      
  ID3Field_SetINT(ID3Field *field, uint32 data)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->Set(data); } catch (...) { };
    }
  }


  ID3_C_EXPORT uint32      
  ID3Field_GetINT(const ID3Field *field)
  {
    uint32 value = 0;

    if (field)
    {
      try { value = reinterpret_cast                   (field)->Get(); } catch (...) { };
    }

    return value;
  }


  ID3_C_EXPORT void      
  ID3Field_SetUNICODE(ID3Field *field, const unicode_t *string)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->Set(string); } catch (...) { };
    }
  }


  ID3_C_EXPORT size_t      
  ID3Field_GetUNICODE(const ID3Field *field, unicode_t *buffer, size_t maxChars)
  {
    size_t numChars = 0;

    if (field)
    {
      try { numChars = reinterpret_cast                   (field)->Get(buffer, maxChars); } catch (...) { };
    }

    return numChars;
  }


  ID3_C_EXPORT size_t      
  ID3Field_GetUNICODEItem(const ID3Field *field, unicode_t *buffer,
                          size_t maxChars, size_t itemNum)
  {
    size_t numChars = 0;

    if (field)
    {
      try { numChars = reinterpret_cast                   (field)->Get(buffer, maxChars, itemNum); } catch (...) { };
    }

    return numChars;
  }


  ID3_C_EXPORT void      
  ID3Field_AddUNICODE(ID3Field *field, const unicode_t *string)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->Add(string); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Field_SetASCII(ID3Field *field, const char *string)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->Set(string); } catch (...) { };
    }
  }


  ID3_C_EXPORT size_t      
  ID3Field_GetASCII(const ID3Field *field, char *buffer, size_t maxChars)
  {
    size_t numChars = 0;

    if (field)
    {
      try { numChars = reinterpret_cast                   (field)->Get(buffer, maxChars); } catch (...) { };
    }

    return numChars;
  }

  ID3_C_EXPORT size_t      
  ID3Field_GetASCIIItem(const ID3Field *field, char *buffer,
                        size_t maxChars, size_t itemNum)
  {
    size_t numChars = 0;

    if (field)
    {
      try { numChars = reinterpret_cast                   (field)->Get(buffer, maxChars, itemNum); } catch (...) { };
    }

    return numChars;
  }


  ID3_C_EXPORT void      
  ID3Field_AddASCII(ID3Field *field, const char *string)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->Add(string); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Field_SetBINARY(ID3Field *field, const uchar *data, size_t size)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->Set(data, size); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Field_GetBINARY(const ID3Field *field, uchar *buffer, size_t buffLength)
  {
    if (field)
    {
      try { reinterpret_cast                   (field)->Get(buffer, buffLength); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Field_FromFile(ID3Field *field, const char *fileName)
  {
    if (field)
    {
      try { reinterpret_cast             (field)->FromFile(fileName); } catch (...) { };
    }
  }


  ID3_C_EXPORT void      
  ID3Field_ToFile(const ID3Field *field, const char *fileName)
  {
    if (field)
    {
      try { reinterpret_cast                   (field)->ToFile(fileName); } catch (...) { };
    }
  }


}
       /* __cplusplus */







 