/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id: zutil.c,v 1.5 2002/06/28 12:02:57 t1mpy Exp $ */

void INCLUDEREPLACE(){CX_INCL("zutil.h");}

 class internal_state      {int dummy;}; /* for buggy compilers */


extern void exit OF((int));


const char *z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}






int z_verbose = 0      ;

void z_error (  
    char *m)
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}


/* exported to allow conversion of error code to string for and
 * uncompress()
 */
const char * ZEXPORT
    int err;
{
    return ERR_MSG(err);
}




void zmemcpy(                  
    Bytef* dest,
    const Bytef* source,
    uInt  len)
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int zmemcmp(            
    const Bytef* s1,
    const Bytef* s2,
    uInt  len)
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void zmemzero(          
    Bytef* dest,
    uInt  len)
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}




/* Small and medium model in Turbo   are for now limited to near allocation
 * with reduced           and MAX_MEM_LEVEL
 */


/* Turbo   does not allow dynamic allocation of 64K bytes
 * and returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */


/* 10*64K = 640K */

local int next_ptr = 0;

          class ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
};       ptr_table_s ptr_table = "CX_TYPEDEF";

local ptr_table table[10     ];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since       is not a preemptive multitasking OS, this table is not
 *           from concurrent access. This hack doesn't work anyway on
 * a           system like OS/2. Use Microsoft   instead.
 */

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= 10     ) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}

       /* __TURBOC__ */



/* Microsoft   in 16-bit mode */








voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return halloc ((long)items, size);
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    hfree (ptr);
}

       /* MSC */





extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));


voidpf zcalloc (                    
    voidpf opaque,
    unsigned items,
    unsigned size)
{
    if (opaque) items += size - size; /* make compiler happy */
    return (voidpf)calloc(items, size);
}

void  zcfree (            
    voidpf opaque,
    voidpf ptr)
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

       /*            */






 