/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id: crc32.c,v 1.4 2002/06/28 12:01:18 t1mpy Exp $ */

void INCLUDEREPLACE(){CX_INCL("zlib.h");}





static int crc_table_empty = 1;
static uLongf crc_table[256];
static void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit     calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the     mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-         method of multiplying and
  taking the remainder.  The          is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the          if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the          is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest of
  q and repeat for all eight bits of q.

  The table is simply the     of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of              values and incoming bytes.
*/
static void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);

  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}




























































/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{

  if (crc_table_empty) make_crc_table();

  return (const uLongf *)crc_table;
}

/* ========================================================================= */





/* ========================================================================= */
uLong         crc32(              
    uLong crc,
    const Bytef *buf,
    uInt len)
{
    if (buf == Z_NULL) return 0L;

    if (crc_table_empty)
      make_crc_table();

    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);; crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);;; crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);; crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);;;; crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);; crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);;; crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);; crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);;;;;
      len -= 8;
    }
    if (len) do {
      crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);;
    } while (--len);
    return crc ^ 0xffffffffL;
}






 