//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

void INCLUDEREPLACE(){CX_INCL("KnownFile.h");}
void INCLUDEREPLACE(){CX_INCL("SearchFile.h");}
void INCLUDEREPLACE(){CX_INCL("QArray.h");}
void INCLUDEREPLACE(){CX_INCL("Mapkey.h");}

enum ESearchType;

  class SearchFileStruct
{
 CString m_strFileName;
 CString m_strFileType;
 CString m_strFileHash;
 CString m_strIndex;
 uint64 m_uFileSize;
 uint32 m_uSourceCount;
 uint32 m_dwCompleteSourceCount;
} ;

        CTypedPtrList                         SearchList = "CX_TYPEDEF";

  class SearchListsStruct {
 uint32 m_nSearchID;
 SearchList m_listSearchFiles;
} ;

  class UDPServerRecord {
 uint32 m_nResults;
 uint32 m_nSpamResults;
} ;



class CFileDataIO;
class CAbstractFile;


class CSearchList
{
 friend class CSearchListCtrl;
public:
 CSearchList();
 ~CSearchList();

 void Clear();
 void NewSearch(CSearchListCtrl* in_wnd, CStringA strResultFileType, uint32 nSearchID, ESearchType eType, CString strSearchExpression, bool bMobilMuleSearch = false);
 unsigned int ProcessSearchAnswer(const uchar* packet, uint32 size, CUpDownClient* Sender, bool* pbMoreResultsAvailable, const char* pszDirectory = NULL);
 unsigned int ProcessSearchAnswer(const uchar* packet, uint32 size, bool bOptUTF8, uint32 nServerIP, uint16 nServerPort, bool* pbMoreResultsAvailable);
 unsigned int ProcessUDPSearchAnswer(CFileDataIO& packet, bool bOptUTF8, uint32 nServerIP, uint16 nServerPort);
 unsigned int GetED2KResultCount() const;
 unsigned int GetResultCount(uint32 nSearchID) const;
 void AddResultCount(uint32 nSearchID, const uchar* hash, unsigned int nCount, bool bSpam);
 void SetOutputWnd(CSearchListCtrl* in_wnd) { outputwnd = in_wnd; }
 void RemoveResults(uint32 nSearchID);
 void RemoveResult(CSearchFile* todel);
 void ShowResults(uint32 nSearchID);
 void GetWebList(CQArray                                     *SearchFileArray, int iSortBy) const;
 void AddFileToDownloadByHash(const uchar* hash)  {AddFileToDownloadByHash(hash,0);}
 void AddFileToDownloadByHash(const uchar* hash, int cat);
 bool AddToList(CSearchFile* toadd, bool bClientResponse = false, uint32 dwFromUDPServerIP = 0);
 CSearchFile* GetSearchFileByHash(const uchar* hash) const;
 void KademliaSearchKeyword(uint32 searchID, const Kademlia::CUInt128* pfileID, const char* name, uint64 size, const char* type, unsigned int uKadPublishInfo, unsigned int numProperties, ...);
 bool AddNotes(Kademlia::CEntry* entry, const uchar* hash);
 void SetNotesSearchStatus(const uchar* pFileHash, bool bSearchRunning);
 void SentUDPRequestNotification(uint32 nSearchID, uint32 dwServerIP);

 void StoreSearches();
 void LoadSearches();

 void DoSpamRating(CSearchFile* pSearchFile, bool bIsClientFile = false, bool bMarkAsNoSpam = false, bool bRecalculateAll = false, bool bUpdateAll = false, uint32 dwFromUDPServerIP = 0);
 void MarkFileAsSpam(CSearchFile* pSpamFile, bool bRecalculateAll = false, bool bUpdate = false);
 void MarkFileAsNotSpam(CSearchFile* pSpamFile, bool bRecalculateAll = false, bool bUpdate = false) { DoSpamRating(pSpamFile, false, true, bRecalculateAll, bUpdate); }
 void RecalculateSpamRatings(uint32 nSearchID, bool bExpectHigher, bool bExpectLower, bool bUpdate);
 void SaveSpamFilter();

 unsigned int GetFoundFiles(uint32 searchID) const {
  unsigned int returnVal = 0;
  VERIFY( m_foundFilesCount.Lookup(searchID, returnVal) );
  return returnVal;
 }
 // mobilemule
 CSearchFile* DetachNextFile(uint32 nSearchID);
protected:
 SearchList*  GetSearchListForID(uint32 nSearchID);
 uint32   GetSpamFilenameRatings(const CSearchFile* pSearchFile, bool bMarkAsNoSpam);
 void   LoadSpamFilter();



private:
 CTypedPtrList                               m_listFileLists;
 CMap                             m_foundFilesCount;
 CMap                             m_foundSourcesCount;
 CMap                             m_ReceivedUDPAnswersCount;
 CMap                             m_RequestedUDPAnswersCount;
 CSearchListCtrl* outputwnd;
 CString   m_strResultFileType;

 uint32   m_nCurED2KSearchID;
 bool   m_MobilMuleSearch;

 // spamfilter
 CStringArray       m_astrSpamCheckCurSearchExp;
 CStringArray       m_astrKnownSpamNames;
 CStringArray       m_astrKnownSimilarSpamNames;
 CMap                              m_mapKnownSpamServerIPs;
 CMap                              m_mapKnownSpamSourcesIPs;
 CMap<CSKey,const CSKey&, bool, bool> m_mapKnownSpamHashs;
 CArray                     m_aui64KnownSpamSizes;
 CArray                     m_aCurED2KSentRequestsIPs;
 CArray                     m_aCurED2KSentReceivedIPs;
 bool         m_bSpamFilterLoaded;
 CMap                                                     m_aUDPServerRecords;
};






 