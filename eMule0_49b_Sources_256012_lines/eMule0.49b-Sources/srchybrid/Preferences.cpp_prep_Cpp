//this file is part of eMule
//Copyright (C)2002-2005 Merkur ( devs@emule-project.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

void INCLUDEREPLACE(){CX_INCL("stdafx.h");}
void INCLUDEREPLACE(){CX_INCL("io.h");}
void INCLUDEREPLACE(){CX_INCL("share.h");}
void INCLUDEREPLACE(){CX_INCL("iphlpapi.h");}
void INCLUDEREPLACE(){CX_INCL("emule.h");}
void INCLUDEREPLACE(){CX_INCL("Preferences.h");}
void INCLUDEREPLACE(){CX_INCL("Opcodes.h");}
void INCLUDEREPLACE(){CX_INCL("OtherFunctions.h");}
void INCLUDEREPLACE(){CX_INCL("Ini2.h");}
void INCLUDEREPLACE(){CX_INCL("DownloadQueue.h");}
void INCLUDEREPLACE(){CX_INCL("UploadQueue.h");}
void INCLUDEREPLACE(){CX_INCL("Statistics.h");}
void INCLUDEREPLACE(){CX_INCL("MD5Sum.h");}
void INCLUDEREPLACE(){CX_INCL("PartFile.h");}
void INCLUDEREPLACE(){CX_INCL("Sockets.h");}
void INCLUDEREPLACE(){CX_INCL("ListenSocket.h");}
void INCLUDEREPLACE(){CX_INCL("ServerList.h");}
void INCLUDEREPLACE(){CX_INCL("SharedFileList.h");}
void INCLUDEREPLACE(){CX_INCL("UpDownClient.h");}
void INCLUDEREPLACE(){CX_INCL("SafeFile.h");}
void INCLUDEREPLACE(){CX_INCL("emuledlg.h");}
void INCLUDEREPLACE(){CX_INCL("StatisticsDlg.h");}
void INCLUDEREPLACE(){CX_INCL("Log.h");}
void INCLUDEREPLACE(){CX_INCL("MuleToolbarCtrl.h");}
void INCLUDEREPLACE(){CX_INCL("VistaDefines.h");}




static char THIS_FILE[] =  "FILE" ;


CPreferences thePrefs;

CString CPreferences::m_astrDefaultDirs[13];
bool CPreferences::m_abDefaultDirsCreated[13] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int  CPreferences::m_nCurrentUserDirMode = -1;
int  CPreferences::m_iDbgHeap;
CString CPreferences::strNick;
uint16 CPreferences::minupload;
uint16 CPreferences::maxupload;
uint16 CPreferences::maxdownload;
const char* CPreferences::m_pszBindAddrA;
CStringA CPreferences::m_strBindAddrA;
const long* CPreferences::m_pszBindAddrW;
CStringW CPreferences::m_strBindAddrW;
uint16 CPreferences::port;
uint16 CPreferences::udpport;
uint16 CPreferences::nServerUDPPort;
unsigned int CPreferences::maxconnections;
unsigned int CPreferences::maxhalfconnections;
bool CPreferences::m_bConditionalTCPAccept;
bool CPreferences::reconnect;
bool CPreferences::m_bUseServerPriorities;
bool CPreferences::m_bUseUserSortedServerList;
CString CPreferences::m_strIncomingDir;
CStringArray CPreferences::tempdir;
bool CPreferences::ICH;
bool CPreferences::m_bAutoUpdateServerList;
bool CPreferences::updatenotify;
bool CPreferences::mintotray;
bool CPreferences::autoconnect;
bool CPreferences::m_bAutoConnectToStaticServersOnly;
bool CPreferences::autotakeed2klinks;
bool CPreferences::addnewfilespaused;
unsigned int CPreferences::depth3D;
bool CPreferences::m_bEnableMiniMule;
int  CPreferences::m_iStraightWindowStyles;
bool CPreferences::m_bUseSystemFontForMainControls;
bool CPreferences::m_bRTLWindowsLayout;
CString CPreferences::m_strSkinProfile;
CString CPreferences::m_strSkinProfileDir;
bool CPreferences::m_bAddServersFromServer;
bool CPreferences::m_bAddServersFromClients;
unsigned int CPreferences::maxsourceperfile;
unsigned int CPreferences::trafficOMeterInterval;
unsigned int CPreferences::statsInterval;
bool CPreferences::m_bFillGraphs;
uchar CPreferences::userhash[16];
WINDOWPLACEMENT CPreferences::EmuleWindowPlacement;
int  CPreferences::maxGraphDownloadRate;
int  CPreferences::maxGraphUploadRate;
uint32 CPreferences::maxGraphUploadRateEstimated = 0;
bool CPreferences::beepOnError;
bool CPreferences::m_bIconflashOnNewMessage;
bool CPreferences::confirmExit;
unsigned long CPreferences::m_adwStatsColors[15];
bool CPreferences::splashscreen;
bool CPreferences::filterLANIPs;
bool CPreferences::m_bAllocLocalHostIP;
bool CPreferences::onlineSig;
uint64 CPreferences::cumDownOverheadTotal;
uint64 CPreferences::cumDownOverheadFileReq;
uint64 CPreferences::cumDownOverheadSrcEx;
uint64 CPreferences::cumDownOverheadServer;
uint64 CPreferences::cumDownOverheadKad;
uint64 CPreferences::cumDownOverheadTotalPackets;
uint64 CPreferences::cumDownOverheadFileReqPackets;
uint64 CPreferences::cumDownOverheadSrcExPackets;
uint64 CPreferences::cumDownOverheadServerPackets;
uint64 CPreferences::cumDownOverheadKadPackets;
uint64 CPreferences::cumUpOverheadTotal;
uint64 CPreferences::cumUpOverheadFileReq;
uint64 CPreferences::cumUpOverheadSrcEx;
uint64 CPreferences::cumUpOverheadServer;
uint64 CPreferences::cumUpOverheadKad;
uint64 CPreferences::cumUpOverheadTotalPackets;
uint64 CPreferences::cumUpOverheadFileReqPackets;
uint64 CPreferences::cumUpOverheadSrcExPackets;
uint64 CPreferences::cumUpOverheadServerPackets;
uint64 CPreferences::cumUpOverheadKadPackets;
uint32 CPreferences::cumUpSuccessfulSessions;
uint32 CPreferences::cumUpFailedSessions;
uint32 CPreferences::cumUpAvgTime;
uint64 CPreferences::cumUpData_EDONKEY;
uint64 CPreferences::cumUpData_EDONKEYHYBRID;
uint64 CPreferences::cumUpData_EMULE;
uint64 CPreferences::cumUpData_MLDONKEY;
uint64 CPreferences::cumUpData_AMULE;
uint64 CPreferences::cumUpData_EMULECOMPAT;
uint64 CPreferences::cumUpData_SHAREAZA;
uint64 CPreferences::sesUpData_EDONKEY;
uint64 CPreferences::sesUpData_EDONKEYHYBRID;
uint64 CPreferences::sesUpData_EMULE;
uint64 CPreferences::sesUpData_MLDONKEY;
uint64 CPreferences::sesUpData_AMULE;
uint64 CPreferences::sesUpData_EMULECOMPAT;
uint64 CPreferences::sesUpData_SHAREAZA;
uint64 CPreferences::cumUpDataPort_4662;
uint64 CPreferences::cumUpDataPort_OTHER;
uint64 CPreferences::cumUpDataPort_PeerCache;
uint64 CPreferences::sesUpDataPort_4662;
uint64 CPreferences::sesUpDataPort_OTHER;
uint64 CPreferences::sesUpDataPort_PeerCache;
uint64 CPreferences::cumUpData_File;
uint64 CPreferences::cumUpData_Partfile;
uint64 CPreferences::sesUpData_File;
uint64 CPreferences::sesUpData_Partfile;
uint32 CPreferences::cumDownCompletedFiles;
uint32 CPreferences::cumDownSuccessfulSessions;
uint32 CPreferences::cumDownFailedSessions;
uint32 CPreferences::cumDownAvgTime;
uint64 CPreferences::cumLostFromCorruption;
uint64 CPreferences::cumSavedFromCompression;
uint32 CPreferences::cumPartsSavedByICH;
uint32 CPreferences::sesDownSuccessfulSessions;
uint32 CPreferences::sesDownFailedSessions;
uint32 CPreferences::sesDownAvgTime;
uint32 CPreferences::sesDownCompletedFiles;
uint64 CPreferences::sesLostFromCorruption;
uint64 CPreferences::sesSavedFromCompression;
uint32 CPreferences::sesPartsSavedByICH;
uint64 CPreferences::cumDownData_EDONKEY;
uint64 CPreferences::cumDownData_EDONKEYHYBRID;
uint64 CPreferences::cumDownData_EMULE;
uint64 CPreferences::cumDownData_MLDONKEY;
uint64 CPreferences::cumDownData_AMULE;
uint64 CPreferences::cumDownData_EMULECOMPAT;
uint64 CPreferences::cumDownData_SHAREAZA;
uint64 CPreferences::cumDownData_URL;
uint64 CPreferences::sesDownData_EDONKEY;
uint64 CPreferences::sesDownData_EDONKEYHYBRID;
uint64 CPreferences::sesDownData_EMULE;
uint64 CPreferences::sesDownData_MLDONKEY;
uint64 CPreferences::sesDownData_AMULE;
uint64 CPreferences::sesDownData_EMULECOMPAT;
uint64 CPreferences::sesDownData_SHAREAZA;
uint64 CPreferences::sesDownData_URL;
uint64 CPreferences::cumDownDataPort_4662;
uint64 CPreferences::cumDownDataPort_OTHER;
uint64 CPreferences::cumDownDataPort_PeerCache;
uint64 CPreferences::sesDownDataPort_4662;
uint64 CPreferences::sesDownDataPort_OTHER;
uint64 CPreferences::sesDownDataPort_PeerCache;
float CPreferences::cumConnAvgDownRate;
float CPreferences::cumConnMaxAvgDownRate;
float CPreferences::cumConnMaxDownRate;
float CPreferences::cumConnAvgUpRate;
float CPreferences::cumConnMaxAvgUpRate;
float CPreferences::cumConnMaxUpRate;
time_t CPreferences::cumConnRunTime;
uint32 CPreferences::cumConnNumReconnects;
uint32 CPreferences::cumConnAvgConnections;
uint32 CPreferences::cumConnMaxConnLimitReached;
uint32 CPreferences::cumConnPeakConnections;
uint32 CPreferences::cumConnTransferTime;
uint32 CPreferences::cumConnDownloadTime;
uint32 CPreferences::cumConnUploadTime;
uint32 CPreferences::cumConnServerDuration;
uint32 CPreferences::cumSrvrsMostWorkingServers;
uint32 CPreferences::cumSrvrsMostUsersOnline;
uint32 CPreferences::cumSrvrsMostFilesAvail;
uint32 CPreferences::cumSharedMostFilesShared;
uint64 CPreferences::cumSharedLargestShareSize;
uint64 CPreferences::cumSharedLargestAvgFileSize;
uint64 CPreferences::cumSharedLargestFileSize;
time_t CPreferences::stat_datetimeLastReset;
unsigned int CPreferences::statsConnectionsGraphRatio;
unsigned int CPreferences::statsSaveInterval;
CString CPreferences::m_strStatsExpandedTreeItems;
bool CPreferences::m_bShowVerticalHourMarkers;
uint64 CPreferences::totalDownloadedBytes;
uint64 CPreferences::totalUploadedBytes;
unsigned short CPreferences::m_wLanguageID;
bool CPreferences::transferDoubleclick;
EViewSharedFilesAccess CPreferences::m_iSeeShares;
unsigned int CPreferences::m_iToolDelayTime;
bool CPreferences::bringtoforeground;
unsigned int CPreferences::splitterbarPosition;
unsigned int CPreferences::splitterbarPositionSvr;
unsigned int CPreferences::splitterbarPositionStat;
unsigned int CPreferences::splitterbarPositionStat_HL;
unsigned int CPreferences::splitterbarPositionStat_HR;
unsigned int CPreferences::splitterbarPositionFriend;
unsigned int CPreferences::splitterbarPositionIRC;
unsigned int CPreferences::splitterbarPositionShared;
unsigned int CPreferences::m_uTransferWnd1;
unsigned int CPreferences::m_uTransferWnd2;
unsigned int CPreferences::m_uDeadServerRetries;
unsigned long CPreferences::m_dwServerKeepAliveTimeout;
unsigned int CPreferences::statsMax;
unsigned int CPreferences::statsAverageMinutes;
CString CPreferences::notifierConfiguration;
bool CPreferences::notifierOnDownloadFinished;
bool CPreferences::notifierOnNewDownload;
bool CPreferences::notifierOnChat;
bool CPreferences::notifierOnLog;
bool CPreferences::notifierOnImportantError;
bool CPreferences::notifierOnEveryChatMsg;
bool CPreferences::notifierOnNewVersion;
ENotifierSoundType CPreferences::notifierSoundType = ntfstNoSound;
CString CPreferences::notifierSoundFile;
CString CPreferences::m_strIRCServer;
CString CPreferences::m_strIRCNick;
CString CPreferences::m_strIRCChannelFilter;
bool CPreferences::m_bIRCAddTimeStamp;
bool CPreferences::m_bIRCUseChannelFilter;
unsigned int CPreferences::m_uIRCChannelUserFilter;
CString CPreferences::m_strIRCPerformString;
bool CPreferences::m_bIRCUsePerform;
bool CPreferences::m_bIRCGetChannelsOnConnect;
bool CPreferences::m_bIRCAcceptLinks;
bool CPreferences::m_bIRCAcceptLinksFriendsOnly;
bool CPreferences::m_bIRCPlaySoundEvents;
bool CPreferences::m_bIRCIgnoreMiscMessages;
bool CPreferences::m_bIRCIgnoreJoinMessages;
bool CPreferences::m_bIRCIgnorePartMessages;
bool CPreferences::m_bIRCIgnoreQuitMessages;
bool CPreferences::m_bIRCIgnoreEmuleAddFriendMsgs;
bool CPreferences::m_bIRCAllowEmuleAddFriend;
bool CPreferences::m_bIRCIgnoreEmuleSendLinkMsgs;
bool CPreferences::m_bIRCJoinHelpChannel;
bool CPreferences::m_bRemove2bin;
bool CPreferences::m_bShowCopyEd2kLinkCmd;
bool CPreferences::m_bpreviewprio;
bool CPreferences::m_bSmartServerIdCheck;
uint8 CPreferences::smartidstate;
bool CPreferences::m_bSafeServerConnect;
bool CPreferences::startMinimized;
bool CPreferences::m_bAutoStart;
bool CPreferences::m_bRestoreLastMainWndDlg;
int  CPreferences::m_iLastMainWndDlgID;
bool CPreferences::m_bRestoreLastLogPane;
int  CPreferences::m_iLastLogPaneID;
unsigned int CPreferences::MaxConperFive;
bool CPreferences::checkDiskspace;
unsigned int CPreferences::m_uMinFreeDiskSpace;
bool CPreferences::m_bSparsePartFiles;
CString CPreferences::m_strYourHostname;
bool CPreferences::m_bEnableVerboseOptions;
bool CPreferences::m_bVerbose;
bool CPreferences::m_bFullVerbose;
bool CPreferences::m_bDebugSourceExchange;
bool CPreferences::m_bLogBannedClients;
bool CPreferences::m_bLogRatingDescReceived;
bool CPreferences::m_bLogSecureIdent;
bool CPreferences::m_bLogFilteredIPs;
bool CPreferences::m_bLogFileSaving;
bool CPreferences::m_bLogA4AF; // ZZ:DownloadManager
bool CPreferences::m_bLogUlDlEvents;

bool CPreferences::m_bUseDebugDevice = true;



int  CPreferences::m_iDebugServerTCPLevel;
int  CPreferences::m_iDebugServerUDPLevel;
int  CPreferences::m_iDebugServerSourcesLevel;
int  CPreferences::m_iDebugServerSearchesLevel;
int  CPreferences::m_iDebugClientTCPLevel;
int  CPreferences::m_iDebugClientUDPLevel;
int  CPreferences::m_iDebugClientKadUDPLevel;
int  CPreferences::m_iDebugSearchResultDetailLevel;
bool CPreferences::m_bupdatequeuelist;
bool CPreferences::m_bManualAddedServersHighPriority;
bool CPreferences::m_btransferfullchunks;
int  CPreferences::m_istartnextfile;
bool CPreferences::m_bshowoverhead;
bool CPreferences::m_bDAP;
bool CPreferences::m_bUAP;
bool CPreferences::m_bDisableKnownClientList;
bool CPreferences::m_bDisableQueueList;
bool CPreferences::m_bExtControls;
bool CPreferences::m_bTransflstRemain;
unsigned int CPreferences::versioncheckdays;
bool CPreferences::showRatesInTitle;
CString CPreferences::m_strTxtEditor;
CString CPreferences::m_strVideoPlayer;
CString CPreferences::m_strVideoPlayerArgs;
bool CPreferences::moviePreviewBackup;
int  CPreferences::m_iPreviewSmallBlocks;
bool CPreferences::m_bPreviewCopiedArchives;
int  CPreferences::m_iInspectAllFileTypes;
bool CPreferences::m_bPreviewOnIconDblClk;
bool CPreferences::indicateratings;
bool CPreferences::watchclipboard;
bool CPreferences::filterserverbyip;
bool CPreferences::m_bFirstStart;
bool CPreferences::m_bCreditSystem;
bool CPreferences::log2disk;
bool CPreferences::debug2disk;
int  CPreferences::iMaxLogBuff;
unsigned int CPreferences::uMaxLogFileSize;
ELogFileFormat CPreferences::m_iLogFileFormat = Unicode;
bool CPreferences::scheduler;
bool CPreferences::dontcompressavi;
bool CPreferences::msgonlyfriends;
bool CPreferences::msgsecure;
bool CPreferences::m_bUseChatCaptchas;
unsigned int CPreferences::filterlevel;
unsigned int CPreferences::m_iFileBufferSize;
unsigned int CPreferences::m_iQueueSize;
int  CPreferences::m_iCommitFiles;
unsigned int CPreferences::maxmsgsessions;
uint32 CPreferences::versioncheckLastAutomatic;
CString CPreferences::messageFilter;
CString CPreferences::commentFilter;
CString CPreferences::filenameCleanups;
CString CPreferences::m_strDateTimeFormat;
CString CPreferences::m_strDateTimeFormat4Log;
LOGFONT CPreferences::m_lfHyperText;
LOGFONT CPreferences::m_lfLogText;
unsigned long CPreferences::m_crLogError = RGB(255, 0, 0);
unsigned long CPreferences::m_crLogWarning = RGB(128, 0, 128);
unsigned long CPreferences::m_crLogSuccess = RGB(0, 0, 255);
int  CPreferences::m_iExtractMetaData;
bool CPreferences::m_bAdjustNTFSDaylightFileTime = true;
CString CPreferences::m_strWebPassword;
CString CPreferences::m_strWebLowPassword;
CUIntArray CPreferences::m_aAllowedRemoteAccessIPs;
uint16 CPreferences::m_nWebPort;
bool CPreferences::m_bWebEnabled;
bool CPreferences::m_bWebUseGzip;
int  CPreferences::m_nWebPageRefresh;
bool CPreferences::m_bWebLowEnabled;
int  CPreferences::m_iWebTimeoutMins;
int  CPreferences::m_iWebFileUploadSizeLimitMB;
bool CPreferences::m_bAllowAdminHiLevFunc;
CString CPreferences::m_strTemplateFile;
ProxySettings CPreferences::proxy;
bool CPreferences::showCatTabInfos;
bool CPreferences::resumeSameCat;
bool CPreferences::dontRecreateGraphs;
bool CPreferences::autofilenamecleanup;
bool CPreferences::m_bUseAutocompl;
bool CPreferences::m_bShowDwlPercentage;
bool CPreferences::m_bRemoveFinishedDownloads;
unsigned int CPreferences::m_iMaxChatHistory;
bool CPreferences::m_bShowActiveDownloadsBold;
int  CPreferences::m_iSearchMethod;
bool CPreferences::m_bAdvancedSpamfilter;
bool CPreferences::m_bUseSecureIdent;
CString CPreferences::m_strMMPassword;
bool CPreferences::m_bMMEnabled;
uint16 CPreferences::m_nMMPort;
bool CPreferences::networkkademlia;
bool CPreferences::networked2k;
EToolbarLabelType CPreferences::m_nToolbarLabels;
CString CPreferences::m_sToolbarBitmap;
CString CPreferences::m_sToolbarBitmapFolder;
CString CPreferences::m_sToolbarSettings;
bool CPreferences::m_bReBarToolbar;
CSize CPreferences::m_sizToolbarIconSize;
bool CPreferences::m_bPreviewEnabled;
bool CPreferences::m_bAutomaticArcPreviewStart;
bool CPreferences::m_bDynUpEnabled;
int  CPreferences::m_iDynUpPingTolerance;
int  CPreferences::m_iDynUpGoingUpDivider;
int  CPreferences::m_iDynUpGoingDownDivider;
int  CPreferences::m_iDynUpNumberOfPings;
int  CPreferences::m_iDynUpPingToleranceMilliseconds;
bool CPreferences::m_bDynUpUseMillisecondPingTolerance;
bool    CPreferences::m_bAllocFull;
// ZZ:DownloadManager -->
bool    CPreferences::m_bA4AFSaveCpu;
// ZZ:DownloadManager <--
bool    CPreferences::m_bHighresTimer;
CStringList CPreferences::shareddir_list;
CStringList CPreferences::addresses_list;
CString CPreferences::m_strFileCommentsFilePath;
Preferences_Ext_Struct* CPreferences::prefsExt;
unsigned short CPreferences::m_wWinVer;
CArray                                    CPreferences::catMap;
unsigned int CPreferences::m_nWebMirrorAlertLevel;
bool CPreferences::m_bRunAsUser;
bool CPreferences::m_bPreferRestrictedOverUser;
bool CPreferences::m_bUseOldTimeRemaining;
uint32 CPreferences::m_uPeerCacheLastSearch;
bool CPreferences::m_bPeerCacheWasFound;
bool CPreferences::m_bPeerCacheEnabled;
uint16 CPreferences::m_nPeerCachePort;
bool CPreferences::m_bPeerCacheShow;

bool CPreferences::m_bOpenPortsOnStartUp;
int  CPreferences::m_byLogLevel;
bool CPreferences::m_bTrustEveryHash;
bool CPreferences::m_bRememberCancelledFiles;
bool CPreferences::m_bRememberDownloadedFiles;

bool CPreferences::m_bNotifierSendMail;
CString CPreferences::m_strNotifierMailServer;
CString CPreferences::m_strNotifierMailSender;
CString CPreferences::m_strNotifierMailReceiver;

bool CPreferences::m_bWinaTransToolbar;

bool CPreferences::m_bCryptLayerRequested;
bool CPreferences::m_bCryptLayerSupported;
bool CPreferences::m_bCryptLayerRequired;
uint32 CPreferences::m_dwKadUDPKey;
uint8 CPreferences::m_byCryptTCPPaddingLength;

bool CPreferences::m_bSkipWANIPSetup;
bool CPreferences::m_bSkipWANPPPSetup;
bool CPreferences::m_bEnableUPnP;
bool CPreferences::m_bCloseUPnPOnExit;
bool CPreferences::m_bIsWinServImplDisabled;
bool CPreferences::m_bIsMinilibImplDisabled;
int  CPreferences::m_nLastWorkingImpl;

bool CPreferences::m_bEnableSearchResultFilter;

bool CPreferences::m_bIRCEnableSmileys;
bool CPreferences::m_bMessageEnableSmileys;

int  CPreferences::m_bIsRunningAeroGlass;
bool CPreferences::m_bPreventStandby;
bool CPreferences::m_bStoreSearches;

CPreferences::CPreferences()
{

 m_iDbgHeap = 1;

}

CPreferences::~CPreferences()
{
 delete prefsExt;
}

const char* CPreferences::GetConfigFile()
{
 return theApp.m_pszProfileName;
}

void CPreferences::Init()
{
 srand((uint32)time(0)); // we need random numbers sometimes

 prefsExt = new       Preferences_Ext_Struct;
 memset(prefsExt, 0, sizeof *prefsExt);

 m_strFileCommentsFilePath = GetMuleDirectory(EMULE_CONFIGDIR) +  "fileinfo.ini";
 ///////////////////////////////////////////////////////////////////////////
 // Create 'logs' directory (and optionally move files from application directory)
 //
 CFileFind ff;
 int  bFoundFile = ff.FindFile(GetMuleDirectory(EMULE_EXECUTEABLEDIR) +  "eMule*.log", 0);
 while (bFoundFile)
 {
  bFoundFile = ff.FindNextFile();
  if (ff.IsDots() || ff.IsSystem() || ff.IsDirectory() || ff.IsHidden())
   continue;
  MoveFile(ff.GetFilePath(), GetMuleDirectory(EMULE_LOGDIR) + ff.GetFileName());
 }
 ff.Close();

 CreateUserHash();

 // load preferences.dat or set standart values
 CString strFullPath;
 strFullPath = GetMuleDirectory(EMULE_CONFIGDIR) +  "preferences.dat";
 FILE* preffile = _tfsopen(strFullPath,  "rb", _SH_DENYWR);

 LoadPreferences();

 if (!preffile){
  SetStandartValues();
 }
 else{
  if (fread(prefsExt,sizeof(Preferences_Ext_Struct),1,preffile) != 1 || ferror(preffile))
   SetStandartValues();

  md4cpy(userhash, prefsExt->userhash);
  EmuleWindowPlacement = prefsExt->EmuleWindowPlacement;

  fclose(preffile);
  smartidstate = 0;
 }

 // shared directories
 strFullPath = GetMuleDirectory(EMULE_CONFIGDIR) +  "shareddir.dat";
 CStdioFile* sdirfile = new       CStdioFile();
 bool bIsUnicodeFile = IsUnicodeFile(strFullPath); // check for BOM
 // open the text file either in or Unicode (binary), this way we can read old and new       files
 // with nearly the same code..
 if (sdirfile->Open(strFullPath, CFile::modeRead | CFile::shareDenyWrite | (bIsUnicodeFile ? CFile::typeBinary : 0)))
 {
  try {
   if (bIsUnicodeFile)
    sdirfile->Seek(sizeof(unsigned short), SEEK_CUR); // skip    

   CString toadd;
   while (sdirfile->ReadString(toadd))
   {
    toadd.Trim( " \t\r\n"); // need to trim '\r' in binary mode
    if (toadd.IsEmpty())
     continue;

    char  szFullPath[MAX_PATH];
    if (PathCanonicalize(szFullPath, toadd))
     toadd = szFullPath;

    if (!IsShareableDirectory(toadd))
     continue;

    if (_taccess(toadd, 0) == 0) { // only add directories which still exist
     if (toadd.Right(1) !=  '\\')
      toadd.Append( "\\");
     shareddir_list.AddHead(toadd);
    }
   }
   sdirfile->Close();
  }
  catch (CFileException* ex) {
   ASSERT(0);
   ex->Delete();
  }
 }
 delete sdirfile;

 // serverlist addresses
 // filename update to reasonable name
 if (PathFileExists(GetMuleDirectory(EMULE_CONFIGDIR) +  "adresses.dat") ) {
  if (PathFileExists(GetMuleDirectory(EMULE_CONFIGDIR) +  "addresses.dat") )
   DeleteFile(GetMuleDirectory(EMULE_CONFIGDIR) +  "adresses.dat");
  else
   MoveFile(GetMuleDirectory(EMULE_CONFIGDIR) +  "adresses.dat", GetMuleDirectory(EMULE_CONFIGDIR) +  "addresses.dat");
 }

 strFullPath = GetMuleDirectory(EMULE_CONFIGDIR) +  "addresses.dat";
 sdirfile = new       CStdioFile();
 bIsUnicodeFile = IsUnicodeFile(strFullPath);
 if (sdirfile->Open(strFullPath, CFile::modeRead | CFile::shareDenyWrite | (bIsUnicodeFile ? CFile::typeBinary : 0)))
 {
  try {
   if (bIsUnicodeFile)
    sdirfile->Seek(sizeof(unsigned short), SEEK_CUR); // skip    

   CString toadd;
   while (sdirfile->ReadString(toadd))
   {
    toadd.Trim( " \t\r\n"); // need to trim '\r' in binary mode
    if (toadd.IsEmpty())
     continue;
    addresses_list.AddHead(toadd);
   }
  }
  catch (CFileException* ex) {
   ASSERT(0);
   ex->Delete();
  }
  sdirfile->Close();
 }
 delete sdirfile;

 userhash[5] = 14;
 userhash[14] = 111;

 // Explicitly inform the user about errors with incoming/temp folders!
 if (!PathFileExists(GetMuleDirectory(EMULE_INCOMINGDIR)) && !::CreateDirectory(GetMuleDirectory(EMULE_INCOMINGDIR),0)) {
  CString strError;
  strError.Format(GetResString(IDS_ERR_CREATE_DIR), GetResString(IDS_PW_INCOMING), GetMuleDirectory(EMULE_INCOMINGDIR), GetErrorMessage(GetLastError()));
  AfxMessageBox(strError, MB_ICONERROR);

  m_strIncomingDir = GetDefaultDirectory(EMULE_INCOMINGDIR, true); // will also try to create it if needed
  if (!PathFileExists(GetMuleDirectory(EMULE_INCOMINGDIR))){
   strError.Format(GetResString(IDS_ERR_CREATE_DIR), GetResString(IDS_PW_INCOMING), GetMuleDirectory(EMULE_INCOMINGDIR), GetErrorMessage(GetLastError()));
   AfxMessageBox(strError, MB_ICONERROR);
  }
 }
 if (!PathFileExists(GetTempDir()) && !::CreateDirectory(GetTempDir(),0)) {
  CString strError;
  strError.Format(GetResString(IDS_ERR_CREATE_DIR), GetResString(IDS_PW_TEMP), GetTempDir(), GetErrorMessage(GetLastError()));
  AfxMessageBox(strError, MB_ICONERROR);

  tempdir.SetAt(0, GetDefaultDirectory(EMULE_TEMPDIR, true)); // will also try to create it if needed);
  if (!PathFileExists(GetTempDir())){
   strError.Format(GetResString(IDS_ERR_CREATE_DIR), GetResString(IDS_PW_TEMP), GetTempDir(), GetErrorMessage(GetLastError()));
   AfxMessageBox(strError, MB_ICONERROR);
  }
 }

 // Create 'skins' directory
 if (!PathFileExists(GetMuleDirectory(EMULE_SKINDIR)) && !CreateDirectory(GetMuleDirectory(EMULE_SKINDIR), 0)) {
  m_strSkinProfileDir = GetDefaultDirectory(EMULE_SKINDIR, true); // will also try to create it if needed
 }

 // Create 'toolbars' directory
 if (!PathFileExists(GetMuleDirectory(EMULE_TOOLBARDIR)) && !CreateDirectory(GetMuleDirectory(EMULE_TOOLBARDIR), 0)) {
  m_sToolbarBitmapFolder = GetDefaultDirectory(EMULE_TOOLBARDIR, true); // will also try to create it if needed;
 }


 if (((int*)userhash[0]) == 0 && ((int*)userhash[1]) == 0 && ((int*)userhash[2]) == 0 && ((int*)userhash[3]) == 0)
  CreateUserHash();
}

void CPreferences::Uninit()
{
 while (!catMap.IsEmpty())
 {
  Category_Struct* delcat = catMap.GetAt(0);
  catMap.RemoveAt(0);
  delete delcat;
 }
}

void CPreferences::SetStandartValues()
{
 CreateUserHash();

 WINDOWPLACEMENT defaultWPM;
 defaultWPM.length = sizeof(WINDOWPLACEMENT);
 defaultWPM.rcNormalPosition.left=10;defaultWPM.rcNormalPosition.top=10;
 defaultWPM.rcNormalPosition.right=700;defaultWPM.rcNormalPosition.bottom=500;
 defaultWPM.showCmd=0;
 EmuleWindowPlacement=defaultWPM;
 versioncheckLastAutomatic=0;

// Save();
}

bool CPreferences::IsTempFile(const CString& rstrDirectory, const CString& rstrName)
{
 bool bFound = false;
 for (int i=0;i<tempdir.GetCount() && !bFound;i++)
  if (CompareDirectories(rstrDirectory, GetTempDir(i))==0)
   bFound = true; //ok, found a directory

 if(!bFound) //found nowhere - not a tempfile...
  return false;

 // do not share a file from the temp directory, if it matches one of the following patterns
 CString strNameLower(rstrName);
 strNameLower.MakeLower();
 strNameLower +=  "|"; // append an     character which we can query for
 static const const char* _apszNotSharedExts[] = {
   "%u.part"  "%c",
   "%u.part.met"  "%c",
   "%u.part.met" PARTMET_BAK_EXT  "%c",
   "%u.part.met" PARTMET_TMP_EXT  "%c"
 };
 for (int i = 0; i < _countof(_apszNotSharedExts); i++){
  unsigned int uNum;
  char  iChar;
  // "misuse" the 'scanf' function for a very simple pattern scanning.
  if (_stscanf(strNameLower, _apszNotSharedExts[i], &uNum, &iChar) == 2 && iChar ==  '|')
   return true;
 }

 return false;
}

// SLUGFILLER: SafeHash
bool CPreferences::IsConfigFile(const CString& rstrDirectory, const CString& rstrName)
{
 if (CompareDirectories(rstrDirectory, GetMuleDirectory(EMULE_CONFIGDIR)))
  return false;

 // do not share a file from the config directory, if it contains one of the following extensions
 static const const char* _apszNotSharedExts[] = {  ".met.bak",  ".ini.old" };
 for (int i = 0; i < _countof(_apszNotSharedExts); i++){
  int iLen = _tcslen(_apszNotSharedExts[i]);
  if (rstrName.GetLength()>=iLen && rstrName.Right(iLen).CompareNoCase(_apszNotSharedExts[i])==0)
   return true;
 }

 // do not share following files from the config directory
 static const const char* _apszNotSharedFiles[] =
 {
   "AC_SearchStrings.dat",
   "AC_ServerMetURLs.dat",
   "addresses.dat",
   "category.ini",
   "clients.met",
   "cryptkey.dat",
   "emfriends.met",
   "fileinfo.ini",
   "ipfilter.dat",
   "known.met",
   "preferences.dat",
   "preferences.ini",
   "server.met",
   "server.met.new      ",
   "server_met.download",
   "server_met.old",
   "shareddir.dat",
   "sharedsubdir.dat",
   "staticservers.dat",
   "webservices.dat"
 };
 for (int i = 0; i < _countof(_apszNotSharedFiles); i++){
  if (rstrName.CompareNoCase(_apszNotSharedFiles[i])==0)
   return true;
 }

 return false;
}
// SLUGFILLER: SafeHash

uint16 CPreferences::GetMaxDownload(){
    return (uint16)(GetMaxDownloadInBytesPerSec()/1024);
}

uint64 CPreferences::GetMaxDownloadInBytesPerSec(bool dynamic){
 //dont be a Lam3r :)
 unsigned int maxup;
 if (dynamic && thePrefs.IsDynUpEnabled() && theApp.uploadqueue->GetWaitingUserCount() != 0 && theApp.uploadqueue->GetDatarate() != 0) {
  maxup = theApp.uploadqueue->GetDatarate();
 } else {
  maxup = GetMaxUpload()*1024;
 }

 if (maxup < 4*1024)
  return (((maxup < 10*1024) && ((uint64)maxup*3 < maxdownload*1024)) ? (uint64)maxup*3 : maxdownload*1024);
 return (((maxup < 10*1024) && ((uint64)maxup*4 < maxdownload*1024)) ? (uint64)maxup*4 : maxdownload*1024);
}

// -khaos--+++> A whole bunch of methods!  Keep going until you reach the end tag.
void CPreferences::SaveStats(int bBackUp){
 // This function saves all of the new       statistics in my addon.  It is also used to
 // save backups for the Reset Stats function, and the Restore Stats function (Which is actually LoadStats)
 // bBackUp = 0: DEFAULT; save to statistics.ini
 // bBackUp = 1: Save to statbkup.ini, which is used to restore after a reset
 // bBackUp = 2: Save to statbkuptmp.ini, which is temporarily created during a restore and then renamed to statbkup.ini

 CString strFullPath(GetMuleDirectory(EMULE_CONFIGDIR));
 if (bBackUp == 1)
  strFullPath +=  "statbkup.ini";
 else if (bBackUp == 2)
  strFullPath +=  "statbkuptmp.ini";
 else
  strFullPath +=  "statistics.ini";

 CIni ini(strFullPath,  "Statistics");

 // Save cumulative statistics to preferences.ini, going in order as they appear in CStatisticsDlg::ShowStatistics.
 // We do     SET the values in prefs        here.

    // Save Cum Down Data
 ini.WriteUInt64( "TotalDownloadedBytes", theStats.sessionReceivedBytes + GetTotalDownloaded());
 ini.WriteInt( "DownSuccessfulSessions", cumDownSuccessfulSessions);
 ini.WriteInt( "DownFailedSessions", cumDownFailedSessions);
 ini.WriteInt( "DownAvgTime", (GetDownC_AvgTime() + GetDownS_AvgTime()) / 2);
 ini.WriteUInt64( "LostFromCorruption", cumLostFromCorruption + sesLostFromCorruption);
 ini.WriteUInt64( "SavedFromCompression", sesSavedFromCompression + cumSavedFromCompression);
 ini.WriteInt( "PartsSavedByICH", cumPartsSavedByICH + sesPartsSavedByICH);

 ini.WriteUInt64( "DownData_EDONKEY", GetCumDownData_EDONKEY());
 ini.WriteUInt64( "DownData_EDONKEYHYBRID", GetCumDownData_EDONKEYHYBRID());
 ini.WriteUInt64( "DownData_EMULE", GetCumDownData_EMULE());
 ini.WriteUInt64( "DownData_MLDONKEY", GetCumDownData_MLDONKEY());
 ini.WriteUInt64( "DownData_LMULE", GetCumDownData_EMULECOMPAT());
 ini.WriteUInt64( "DownData_AMULE", GetCumDownData_AMULE());
 ini.WriteUInt64( "DownData_SHAREAZA", GetCumDownData_SHAREAZA());
 ini.WriteUInt64( "DownData_UR ", GetCumDownData_URL());
 ini.WriteUInt64( "DownDataPort_4662", GetCumDownDataPort_4662());
 ini.WriteUInt64( "DownDataPort_OTHER", GetCumDownDataPort_OTHER());
 ini.WriteUInt64( "DownDataPort_PeerCache", GetCumDownDataPort_PeerCache());

 ini.WriteUInt64( "DownOverheadTotal",theStats.GetDownDataOverheadFileRequest() +
          theStats.GetDownDataOverheadSourceExchange() +
          theStats.GetDownDataOverheadServer() +
          theStats.GetDownDataOverheadKad() +
          theStats.GetDownDataOverheadOther() +
          GetDownOverheadTotal());
 ini.WriteUInt64( "DownOverheadFileReq", theStats.GetDownDataOverheadFileRequest() + GetDownOverheadFileReq());
 ini.WriteUInt64( "DownOverheadSrcEx", theStats.GetDownDataOverheadSourceExchange() + GetDownOverheadSrcEx());
 ini.WriteUInt64( "DownOverheadServer", theStats.GetDownDataOverheadServer() + GetDownOverheadServer());
 ini.WriteUInt64( "DownOverheadKad", theStats.GetDownDataOverheadKad() + GetDownOverheadKad());

 ini.WriteUInt64( "DownOverheadTotalPackets", theStats.GetDownDataOverheadFileRequestPackets() +
            theStats.GetDownDataOverheadSourceExchangePackets() +
            theStats.GetDownDataOverheadServerPackets() +
            theStats.GetDownDataOverheadKadPackets() +
            theStats.GetDownDataOverheadOtherPackets() +
            GetDownOverheadTotalPackets());
 ini.WriteUInt64( "DownOverheadFileReqPackets", theStats.GetDownDataOverheadFileRequestPackets() + GetDownOverheadFileReqPackets());
 ini.WriteUInt64( "DownOverheadSrcExPackets", theStats.GetDownDataOverheadSourceExchangePackets() + GetDownOverheadSrcExPackets());
 ini.WriteUInt64( "DownOverheadServerPackets", theStats.GetDownDataOverheadServerPackets() + GetDownOverheadServerPackets());
 ini.WriteUInt64( "DownOverheadKadPackets", theStats.GetDownDataOverheadKadPackets() + GetDownOverheadKadPackets());

 // Save Cumulative Upline Statistics
 ini.WriteUInt64( "TotalUploadedBytes", theStats.sessionSentBytes + GetTotalUploaded());
 ini.WriteInt( "UpSuccessfulSessions", theApp.uploadqueue->GetSuccessfullUpCount() + GetUpSuccessfulSessions());
 ini.WriteInt( "UpFailedSessions", theApp.uploadqueue->GetFailedUpCount() + GetUpFailedSessions());
 ini.WriteInt( "UpAvgTime", (theApp.uploadqueue->GetAverageUpTime() + GetUpAvgTime())/2);
 ini.WriteUInt64( "UpData_EDONKEY", GetCumUpData_EDONKEY());
 ini.WriteUInt64( "UpData_EDONKEYHYBRID", GetCumUpData_EDONKEYHYBRID());
 ini.WriteUInt64( "UpData_EMULE", GetCumUpData_EMULE());
 ini.WriteUInt64( "UpData_MLDONKEY", GetCumUpData_MLDONKEY());
 ini.WriteUInt64( "UpData_LMULE", GetCumUpData_EMULECOMPAT());
 ini.WriteUInt64( "UpData_AMULE", GetCumUpData_AMULE());
 ini.WriteUInt64( "UpData_SHAREAZA", GetCumUpData_SHAREAZA());
 ini.WriteUInt64( "UpDataPort_4662", GetCumUpDataPort_4662());
 ini.WriteUInt64( "UpDataPort_OTHER", GetCumUpDataPort_OTHER());
 ini.WriteUInt64( "UpDataPort_PeerCache", GetCumUpDataPort_PeerCache());
 ini.WriteUInt64( "UpData_File", GetCumUpData_File());
 ini.WriteUInt64( "UpData_Partfile", GetCumUpData_Partfile());

 ini.WriteUInt64( "UpOverheadTotal", theStats.GetUpDataOverheadFileRequest() +
          theStats.GetUpDataOverheadSourceExchange() +
          theStats.GetUpDataOverheadServer() +
          theStats.GetUpDataOverheadKad() +
          theStats.GetUpDataOverheadOther() +
          GetUpOverheadTotal());
 ini.WriteUInt64( "UpOverheadFileReq", theStats.GetUpDataOverheadFileRequest() + GetUpOverheadFileReq());
 ini.WriteUInt64( "UpOverheadSrcEx", theStats.GetUpDataOverheadSourceExchange() + GetUpOverheadSrcEx());
 ini.WriteUInt64( "UpOverheadServer", theStats.GetUpDataOverheadServer() + GetUpOverheadServer());
 ini.WriteUInt64( "UpOverheadKad", theStats.GetUpDataOverheadKad() + GetUpOverheadKad());

 ini.WriteUInt64( "UpOverheadTotalPackets", theStats.GetUpDataOverheadFileRequestPackets() +
          theStats.GetUpDataOverheadSourceExchangePackets() +
          theStats.GetUpDataOverheadServerPackets() +
          theStats.GetUpDataOverheadKadPackets() +
          theStats.GetUpDataOverheadOtherPackets() +
          GetUpOverheadTotalPackets());
 ini.WriteUInt64( "UpOverheadFileReqPackets", theStats.GetUpDataOverheadFileRequestPackets() + GetUpOverheadFileReqPackets());
 ini.WriteUInt64( "UpOverheadSrcExPackets", theStats.GetUpDataOverheadSourceExchangePackets() + GetUpOverheadSrcExPackets());
 ini.WriteUInt64( "UpOverheadServerPackets", theStats.GetUpDataOverheadServerPackets() + GetUpOverheadServerPackets());
 ini.WriteUInt64( "UpOverheadKadPackets", theStats.GetUpDataOverheadKadPackets() + GetUpOverheadKadPackets());

 // Save Cumulative Connection Statistics
 float tempRate = 0.0F;

 // Download Rate Average
 tempRate = theStats.GetAvgDownloadRate(AVG_TOTAL);
 ini.WriteFloat( "ConnAvgDownRate", tempRate);

 // Max Download Rate Average
 if (tempRate > GetConnMaxAvgDownRate())
  SetConnMaxAvgDownRate(tempRate);
 ini.WriteFloat( "ConnMaxAvgDownRate", GetConnMaxAvgDownRate());

 // Max Download Rate
 tempRate = (float)theApp.downloadqueue->GetDatarate() / 1024;
 if (tempRate > GetConnMaxDownRate())
  SetConnMaxDownRate(tempRate);
 ini.WriteFloat( "ConnMaxDownRate", GetConnMaxDownRate());

 // Upload Rate Average
 tempRate = theStats.GetAvgUploadRate(AVG_TOTAL);
 ini.WriteFloat( "ConnAvgUpRate", tempRate);

 // Max Upload Rate Average
 if (tempRate > GetConnMaxAvgUpRate())
  SetConnMaxAvgUpRate(tempRate);
 ini.WriteFloat( "ConnMaxAvgUpRate", GetConnMaxAvgUpRate());

 // Max Upload Rate
 tempRate = (float)theApp.uploadqueue->GetDatarate() / 1024;
 if (tempRate > GetConnMaxUpRate())
  SetConnMaxUpRate(tempRate);
 ini.WriteFloat( "ConnMaxUpRate", GetConnMaxUpRate());

 // Overall Run Time
 ini.WriteInt( "ConnRunTime", (unsigned int)((GetTickCount() - theStats.starttime)/1000 + GetConnRunTime()));

 // Number of Reconnects
 ini.WriteInt( "ConnNumReconnects", (theStats.reconnects>0) ? (theStats.reconnects - 1 + GetConnNumReconnects()) : GetConnNumReconnects());

 // Average Connections
 if (theApp.serverconnect->IsConnected())
  ini.WriteInt( "ConnAvgConnections", (unsigned int)((theApp.listensocket->GetAverageConnections() + cumConnAvgConnections)/2));

 // Peak Connections
 if (theApp.listensocket->GetPeakConnections() > cumConnPeakConnections)
  cumConnPeakConnections = theApp.listensocket->GetPeakConnections();
 ini.WriteInt( "ConnPeakConnections", cumConnPeakConnections);

 // Max Connection Limit Reached
 if (theApp.listensocket->GetMaxConnectionReached() + cumConnMaxConnLimitReached > cumConnMaxConnLimitReached)
  ini.WriteInt( "ConnMaxConnLimitReached", theApp.listensocket->GetMaxConnectionReached() + cumConnMaxConnLimitReached);

 // Time Stuff...
 ini.WriteInt( "ConnTransferTime", GetConnTransferTime() + theStats.GetTransferTime());
 ini.WriteInt( "ConnUploadTime", GetConnUploadTime() + theStats.GetUploadTime());
 ini.WriteInt( "ConnDownloadTime", GetConnDownloadTime() + theStats.GetDownloadTime());
 ini.WriteInt( "ConnServerDuration", GetConnServerDuration() + theStats.GetServerDuration());

 // Compare and Save Server Records
 uint32 servtotal, servfail, servuser, servfile, servlowiduser, servtuser, servtfile;
 float servocc;
 theApp.serverlist->GetStatus(servtotal, servfail, servuser, servfile, servlowiduser, servtuser, servtfile, servocc);

 if (servtotal - servfail > cumSrvrsMostWorkingServers)
  cumSrvrsMostWorkingServers = servtotal - servfail;
 ini.WriteInt( "SrvrsMostWorkingServers", cumSrvrsMostWorkingServers);

 if (servtuser > cumSrvrsMostUsersOnline)
  cumSrvrsMostUsersOnline = servtuser;
 ini.WriteInt( "SrvrsMostUsersOnline", cumSrvrsMostUsersOnline);

 if (servtfile > cumSrvrsMostFilesAvail)
  cumSrvrsMostFilesAvail = servtfile;
 ini.WriteInt( "SrvrsMostFilesAvail", cumSrvrsMostFilesAvail);

 // Compare and Save Shared File Records
 if ((unsigned int)theApp.sharedfiles->GetCount() > cumSharedMostFilesShared)
  cumSharedMostFilesShared = theApp.sharedfiles->GetCount();
 ini.WriteInt( "SharedMostFilesShared", cumSharedMostFilesShared);

 uint64 bytesLargestFile = 0;
 uint64 allsize = theApp.sharedfiles->GetDatasize(bytesLargestFile);
 if (allsize > cumSharedLargestShareSize)
  cumSharedLargestShareSize = allsize;
 ini.WriteUInt64( "SharedLargestShareSize", cumSharedLargestShareSize);
 if (bytesLargestFile > cumSharedLargestFileSize)
  cumSharedLargestFileSize = bytesLargestFile;
 ini.WriteUInt64( "SharedLargestFileSize", cumSharedLargestFileSize);

 if (theApp.sharedfiles->GetCount() != 0) {
  uint64 tempint = allsize/theApp.sharedfiles->GetCount();
  if (tempint > cumSharedLargestAvgFileSize)
   cumSharedLargestAvgFileSize = tempint;
 }

 ini.WriteUInt64( "SharedLargestAvgFileSize", cumSharedLargestAvgFileSize);
 ini.WriteInt( "statsDateTimeLastReset", stat_datetimeLastReset);

 // If we are saving a back-up or a temporary back-up, return now.
 if (bBackUp != 0)
  return;
}

void CPreferences::SetRecordStructMembers() {

 // The purpose of this function is to be called from CStatisticsDlg::ShowStatistics()
 // This was easier than making a bunch of functions to interface with the record
 // members of the prefs        from ShowStatistics.

 // This function is going to compare current values with previously saved records, and if
 // the current values are greater, the corresponding member of prefs will be updated.
 // We will not write to     here, because this code is going to be called a lot more often
 // than SaveStats()  - Khaos

 CString buffer;

 // Servers
 uint32 servtotal, servfail, servuser, servfile, servlowiduser, servtuser, servtfile;
 float servocc;
 theApp.serverlist->GetStatus( servtotal, servfail, servuser, servfile, servlowiduser, servtuser, servtfile, servocc );
 if ((servtotal-servfail)>cumSrvrsMostWorkingServers) cumSrvrsMostWorkingServers = (servtotal-servfail);
 if (servtuser>cumSrvrsMostUsersOnline) cumSrvrsMostUsersOnline = servtuser;
 if (servtfile>cumSrvrsMostFilesAvail) cumSrvrsMostFilesAvail = servtfile;

 // Shared Files
 if ((unsigned int)theApp.sharedfiles->GetCount() > cumSharedMostFilesShared)
  cumSharedMostFilesShared = theApp.sharedfiles->GetCount();
 uint64 bytesLargestFile = 0;
 uint64 allsize=theApp.sharedfiles->GetDatasize(bytesLargestFile);
 if (allsize>cumSharedLargestShareSize) cumSharedLargestShareSize = allsize;
 if (bytesLargestFile>cumSharedLargestFileSize) cumSharedLargestFileSize = bytesLargestFile;
 if (theApp.sharedfiles->GetCount() != 0) {
  uint64 tempint = allsize/theApp.sharedfiles->GetCount();
  if (tempint>cumSharedLargestAvgFileSize) cumSharedLargestAvgFileSize = tempint;
 }
} // SetRecordStructMembers()

void CPreferences::SaveCompletedDownloadsStat(){

 // This function saves the values for the completed
 // download members to INI.  It is called from
 // CPartfile::PerformFileComplete ...   - Khaos

 CIni ini(GetMuleDirectory(EMULE_CONFIGDIR) +  "statistics.ini",  "Statistics" );

 ini.WriteInt( "DownCompletedFiles",   GetDownCompletedFiles());
 ini.WriteInt( "DownSessionCompletedFiles", GetDownSessionCompletedFiles());
} // SaveCompletedDownloadsStat()

void CPreferences::Add2SessionTransferData(unsigned int uClientID, unsigned int uClientPort, int  bFromPF,
             int  bUpDown, uint32 bytes, bool sentToFriend)
{
 // This function adds the transferred bytes to the appropriate variables,
 // as well as to the totals for all clients. - Khaos
 // PARAMETERS:
 // uClientID - The identifier for which client software sent or received this data, eg SO_EMULE
 // uClientPort - The remote port of the client that sent or received this data, eg 4662
 // bFromPF - Applies only to uploads.  True is from partfile, False is from non-partfile.
 // bUpDown - True is Up, False is Down
 // bytes - Number of bytes sent by the client.  Subtract header before calling.

 switch (bUpDown){
  case true:
   // Upline Data
   switch (uClientID){
    // Update session client breakdown stats for sent bytes...
    case SO_EMULE:
    case SO_OLDEMULE:  sesUpData_EMULE+=bytes;   break;
    case SO_EDONKEYHYBRID: sesUpData_EDONKEYHYBRID+=bytes; break;
    case SO_EDONKEY:  sesUpData_EDONKEY+=bytes;  break;
    case SO_MLDONKEY:  sesUpData_MLDONKEY+=bytes;  break;
    case SO_AMULE:   sesUpData_AMULE+=bytes;   break;
    case SO_SHAREAZA:  sesUpData_SHAREAZA+=bytes;  break;
    case SO_CDONKEY:
    case SO_LPHANT:
    case SO_XMULE:   sesUpData_EMULECOMPAT+=bytes; break;
   }

   switch (uClientPort){
    // Update session port breakdown stats for sent bytes...
    case 4662:    sesUpDataPort_4662+=bytes;  break;
    case (unsigned int)-1:   sesUpDataPort_PeerCache+=bytes; break;
    //case (unsigned int)-2:  sesUpDataPort_URL+=bytes;  break;
    default:    sesUpDataPort_OTHER+=bytes;  break;
   }

   if (bFromPF)    sesUpData_Partfile+=bytes;
   else      sesUpData_File+=bytes;

   // Add to our total for sent bytes...
   theApp.UpdateSentBytes(bytes, sentToFriend);

   break;

  case false:
   // Downline Data
   switch (uClientID){
                // Update session client breakdown stats for received bytes...
    case SO_EMULE:
    case SO_OLDEMULE:  sesDownData_EMULE+=bytes;  break;
    case SO_EDONKEYHYBRID: sesDownData_EDONKEYHYBRID+=bytes;break;
    case SO_EDONKEY:  sesDownData_EDONKEY+=bytes;  break;
    case SO_MLDONKEY:  sesDownData_MLDONKEY+=bytes; break;
    case SO_AMULE:   sesDownData_AMULE+=bytes;  break;
    case SO_SHAREAZA:  sesDownData_SHAREAZA+=bytes; break;
    case SO_CDONKEY:
    case SO_LPHANT:
    case SO_XMULE:   sesDownData_EMULECOMPAT+=bytes; break;
    case SO_URL:   sesDownData_URL+=bytes;   break;
   }

   switch (uClientPort){
    // Update session port breakdown stats for received bytes...
    // For now we are only going to break it down by default and non-default.
    // A statistical analysis of all data sent from every single port/domain is
    // beyond the scope of this add-on.
    case 4662:    sesDownDataPort_4662+=bytes; break;
    case (unsigned int)-1:   sesDownDataPort_PeerCache+=bytes;break;
    //case (unsigned int)-2:  sesDownDataPort_URL+=bytes;  break;
    default:    sesDownDataPort_OTHER+=bytes; break;
   }

   // Add to our total for received bytes...
   theApp.UpdateReceivedBytes(bytes);
 }
}

// Reset Statistics by Khaos

void CPreferences::ResetCumulativeStatistics(){

 // Save a backup so that we can undo this action
 SaveStats(1);

 // SET     CUMULATIVE      VALUES    0  :'-(

 totalDownloadedBytes=0;
 totalUploadedBytes=0;
 cumDownOverheadTotal=0;
 cumDownOverheadFileReq=0;
 cumDownOverheadSrcEx=0;
 cumDownOverheadServer=0;
 cumDownOverheadKad=0;
 cumDownOverheadTotalPackets=0;
 cumDownOverheadFileReqPackets=0;
 cumDownOverheadSrcExPackets=0;
 cumDownOverheadServerPackets=0;
 cumDownOverheadKadPackets=0;
 cumUpOverheadTotal=0;
 cumUpOverheadFileReq=0;
 cumUpOverheadSrcEx=0;
 cumUpOverheadServer=0;
 cumUpOverheadKad=0;
 cumUpOverheadTotalPackets=0;
 cumUpOverheadFileReqPackets=0;
 cumUpOverheadSrcExPackets=0;
 cumUpOverheadServerPackets=0;
 cumUpOverheadKadPackets=0;
 cumUpSuccessfulSessions=0;
 cumUpFailedSessions=0;
 cumUpAvgTime=0;
 cumUpData_EDONKEY=0;
 cumUpData_EDONKEYHYBRID=0;
 cumUpData_EMULE=0;
 cumUpData_MLDONKEY=0;
 cumUpData_AMULE=0;
 cumUpData_EMULECOMPAT=0;
 cumUpData_SHAREAZA=0;
 cumUpDataPort_4662=0;
 cumUpDataPort_OTHER=0;
 cumUpDataPort_PeerCache=0;
 cumDownCompletedFiles=0;
 cumDownSuccessfulSessions=0;
 cumDownFailedSessions=0;
 cumDownAvgTime=0;
 cumLostFromCorruption=0;
 cumSavedFromCompression=0;
 cumPartsSavedByICH=0;
 cumDownData_EDONKEY=0;
 cumDownData_EDONKEYHYBRID=0;
 cumDownData_EMULE=0;
 cumDownData_MLDONKEY=0;
 cumDownData_AMULE=0;
 cumDownData_EMULECOMPAT=0;
 cumDownData_SHAREAZA=0;
 cumDownData_URL=0;
 cumDownDataPort_4662=0;
 cumDownDataPort_OTHER=0;
 cumDownDataPort_PeerCache=0;
 cumConnAvgDownRate=0;
 cumConnMaxAvgDownRate=0;
 cumConnMaxDownRate=0;
 cumConnAvgUpRate=0;
 cumConnRunTime=0;
 cumConnNumReconnects=0;
 cumConnAvgConnections=0;
 cumConnMaxConnLimitReached=0;
 cumConnPeakConnections=0;
 cumConnDownloadTime=0;
 cumConnUploadTime=0;
 cumConnTransferTime=0;
 cumConnServerDuration=0;
 cumConnMaxAvgUpRate=0;
 cumConnMaxUpRate=0;
 cumSrvrsMostWorkingServers=0;
 cumSrvrsMostUsersOnline=0;
 cumSrvrsMostFilesAvail=0;
    cumSharedMostFilesShared=0;
 cumSharedLargestShareSize=0;
 cumSharedLargestAvgFileSize=0;

 // Set the time of last reset...
 time_t timeNow;
 time(&timeNow);
 stat_datetimeLastReset = timeNow;

 // Save the reset stats
 SaveStats();
 theApp.emuledlg->statisticswnd->ShowStatistics(true);
}


// Load Statistics
// This used to be integrated in LoadPreferences, but it has been altered
// so that it can be used to load the backup created when the stats are reset.
// Last Modified: 2-22-03 by Khaos
bool CPreferences::LoadStats(int loadBackUp)
{
 // loadBackUp is 0 by default
 // loadBackUp = 0: Load the stats normally like we used to do in LoadPreferences
 // loadBackUp = 1: Load the stats from statbkup.ini and create a backup of the current stats.  Also, do not initialize session variables.
 CString sINI;
 CFileFind findBackUp;

 switch (loadBackUp) {
  case 0:{
   // for transition...
   if(PathFileExists(GetMuleDirectory(EMULE_CONFIGDIR) +  "statistics.ini"))
    sINI.Format( "%sstatistics.ini", GetMuleDirectory(EMULE_CONFIGDIR));
   else
    sINI.Format( "%spreferences.ini", GetMuleDirectory(EMULE_CONFIGDIR));

   break;
      }
  case 1:
   sINI.Format( "%sstatbkup.ini", GetMuleDirectory(EMULE_CONFIGDIR));
   if (!findBackUp.FindFile(sINI))
    return false;
   SaveStats(2); // Save our temp backup of current values to statbkuptmp.ini, we will be renaming it at the end of this function.
   break;
 }

 int  fileex = PathFileExists(sINI);
 CIni ini(sINI,  "Statistics");

 totalDownloadedBytes   = ini.GetUInt64( "TotalDownloadedBytes");
 totalUploadedBytes    = ini.GetUInt64( "TotalUploadedBytes");

 // Load stats for cumulative downline overhead
 cumDownOverheadTotal   = ini.GetUInt64( "DownOverheadTotal");
 cumDownOverheadFileReq   = ini.GetUInt64( "DownOverheadFileReq");
 cumDownOverheadSrcEx   = ini.GetUInt64( "DownOverheadSrcEx");
 cumDownOverheadServer   = ini.GetUInt64( "DownOverheadServer");
 cumDownOverheadKad    = ini.GetUInt64( "DownOverheadKad");
 cumDownOverheadTotalPackets  = ini.GetUInt64( "DownOverheadTotalPackets");
 cumDownOverheadFileReqPackets = ini.GetUInt64( "DownOverheadFileReqPackets");
 cumDownOverheadSrcExPackets  = ini.GetUInt64( "DownOverheadSrcExPackets");
 cumDownOverheadServerPackets = ini.GetUInt64( "DownOverheadServerPackets");
 cumDownOverheadKadPackets  = ini.GetUInt64( "DownOverheadKadPackets");

 // Load stats for cumulative upline overhead
 cumUpOverheadTotal    = ini.GetUInt64( "UpOverHeadTotal");
 cumUpOverheadFileReq   = ini.GetUInt64( "UpOverheadFileReq");
 cumUpOverheadSrcEx    = ini.GetUInt64( "UpOverheadSrcEx");
 cumUpOverheadServer    = ini.GetUInt64( "UpOverheadServer");
 cumUpOverheadKad    = ini.GetUInt64( "UpOverheadKad");
 cumUpOverheadTotalPackets  = ini.GetUInt64( "UpOverHeadTotalPackets");
 cumUpOverheadFileReqPackets  = ini.GetUInt64( "UpOverheadFileReqPackets");
 cumUpOverheadSrcExPackets  = ini.GetUInt64( "UpOverheadSrcExPackets");
 cumUpOverheadServerPackets  = ini.GetUInt64( "UpOverheadServerPackets");
 cumUpOverheadKadPackets   = ini.GetUInt64( "UpOverheadKadPackets");

 // Load stats for cumulative upline data
 cumUpSuccessfulSessions   = ini.GetInt( "UpSuccessfulSessions");
 cumUpFailedSessions    = ini.GetInt( "UpFailedSessions");
 cumUpAvgTime     = ini.GetInt( "UpAvgTime");

 // Load cumulative client breakdown stats for sent bytes
 cumUpData_EDONKEY    = ini.GetUInt64( "UpData_EDONKEY");
 cumUpData_EDONKEYHYBRID   = ini.GetUInt64( "UpData_EDONKEYHYBRID");
 cumUpData_EMULE     = ini.GetUInt64( "UpData_EMULE");
 cumUpData_MLDONKEY    = ini.GetUInt64( "UpData_MLDONKEY");
 cumUpData_EMULECOMPAT   = ini.GetUInt64( "UpData_LMULE");
 cumUpData_AMULE     = ini.GetUInt64( "UpData_AMULE");
 cumUpData_SHAREAZA    = ini.GetUInt64( "UpData_SHAREAZA");

 // Load cumulative port breakdown stats for sent bytes
 cumUpDataPort_4662    = ini.GetUInt64( "UpDataPort_4662");
 cumUpDataPort_OTHER    = ini.GetUInt64( "UpDataPort_OTHER");
 cumUpDataPort_PeerCache   = ini.GetUInt64( "UpDataPort_PeerCache");

 // Load cumulative source breakdown stats for sent bytes
 cumUpData_File     = ini.GetUInt64( "UpData_File");
 cumUpData_Partfile    = ini.GetUInt64( "UpData_Partfile");

 // Load stats for cumulative downline data
 cumDownCompletedFiles   = ini.GetInt( "DownCompletedFiles");
 cumDownSuccessfulSessions  = ini.GetInt( "DownSuccessfulSessions");
 cumDownFailedSessions   = ini.GetInt( "DownFailedSessions");
 cumDownAvgTime     = ini.GetInt( "DownAvgTime");

 // Cumulative statistics for saved due to compression/lost due to corruption
 cumLostFromCorruption   = ini.GetUInt64( "LostFromCorruption");
 cumSavedFromCompression   = ini.GetUInt64( "SavedFromCompression");
 cumPartsSavedByICH    = ini.GetInt( "PartsSavedByICH");

 // Load cumulative client breakdown stats for received bytes
 cumDownData_EDONKEY    = ini.GetUInt64( "DownData_EDONKEY");
 cumDownData_EDONKEYHYBRID  = ini.GetUInt64( "DownData_EDONKEYHYBRID");
 cumDownData_EMULE    = ini.GetUInt64( "DownData_EMULE");
 cumDownData_MLDONKEY   = ini.GetUInt64( "DownData_MLDONKEY");
 cumDownData_EMULECOMPAT   = ini.GetUInt64( "DownData_LMULE");
 cumDownData_AMULE    = ini.GetUInt64( "DownData_AMULE");
 cumDownData_SHAREAZA   = ini.GetUInt64( "DownData_SHAREAZA");
 cumDownData_URL     = ini.GetUInt64( "DownData_UR ");

 // Load cumulative port breakdown stats for received bytes
 cumDownDataPort_4662   = ini.GetUInt64( "DownDataPort_4662");
 cumDownDataPort_OTHER   = ini.GetUInt64( "DownDataPort_OTHER");
 cumDownDataPort_PeerCache  = ini.GetUInt64( "DownDataPort_PeerCache");

 // Load stats for cumulative connection data
 cumConnAvgDownRate    = ini.GetFloat( "ConnAvgDownRate");
 cumConnMaxAvgDownRate   = ini.GetFloat( "ConnMaxAvgDownRate");
 cumConnMaxDownRate    = ini.GetFloat( "ConnMaxDownRate");
 cumConnAvgUpRate    = ini.GetFloat( "ConnAvgUpRate");
 cumConnMaxAvgUpRate    = ini.GetFloat( "ConnMaxAvgUpRate");
 cumConnMaxUpRate    = ini.GetFloat( "ConnMaxUpRate");
 cumConnRunTime     = ini.GetInt( "ConnRunTime");
 cumConnTransferTime    = ini.GetInt( "ConnTransferTime");
 cumConnDownloadTime    = ini.GetInt( "ConnDownloadTime");
 cumConnUploadTime    = ini.GetInt( "ConnUploadTime");
 cumConnServerDuration   = ini.GetInt( "ConnServerDuration");
 cumConnNumReconnects   = ini.GetInt( "ConnNumReconnects");
 cumConnAvgConnections   = ini.GetInt( "ConnAvgConnections");
 cumConnMaxConnLimitReached  = ini.GetInt( "ConnMaxConnLimitReached");
 cumConnPeakConnections   = ini.GetInt( "ConnPeakConnections");

 // Load date/time of last reset
 stat_datetimeLastReset   = ini.GetInt( "statsDateTimeLastReset");

 // Smart Load For Restores - Don't overwrite records that are greater than the backed up ones
 if (loadBackUp == 1)
 {
  // Load records for servers / network
  if ((unsigned int)ini.GetInt( "SrvrsMostWorkingServers") > cumSrvrsMostWorkingServers)
   cumSrvrsMostWorkingServers = ini.GetInt( "SrvrsMostWorkingServers");

  if ((unsigned int)ini.GetInt( "SrvrsMostUsersOnline") > cumSrvrsMostUsersOnline)
   cumSrvrsMostUsersOnline = ini.GetInt( "SrvrsMostUsersOnline");

  if ((unsigned int)ini.GetInt( "SrvrsMostFilesAvail") > cumSrvrsMostFilesAvail)
   cumSrvrsMostFilesAvail = ini.GetInt( "SrvrsMostFilesAvail");

  // Load records for shared files
  if ((unsigned int)ini.GetInt( "SharedMostFilesShared") > cumSharedMostFilesShared)
   cumSharedMostFilesShared = ini.GetInt( "SharedMostFilesShared");

  uint64 temp64 = ini.GetUInt64( "SharedLargestShareSize");
  if (temp64 > cumSharedLargestShareSize)
   cumSharedLargestShareSize = temp64;

  temp64 = ini.GetUInt64( "SharedLargestAvgFileSize");
  if (temp64 > cumSharedLargestAvgFileSize)
   cumSharedLargestAvgFileSize = temp64;

  temp64 = ini.GetUInt64( "SharedLargestFileSize");
  if (temp64 > cumSharedLargestFileSize)
   cumSharedLargestFileSize = temp64;

  // Check to make sure the backup of the values we just overwrote exists.  If so, rename it to the backup file.
  // This allows us to undo a restore, so to speak, just in case we don't like the restored values...
  CString sINIBackUp;
  sINIBackUp.Format( "%sstatbkuptmp.ini", GetMuleDirectory(EMULE_CONFIGDIR));
  if (findBackUp.FindFile(sINIBackUp)){
   CFile::Remove(sINI);    // Remove the backup that we just restored from
   CFile::Rename(sINIBackUp, sINI); // Rename our temporary backup to the normal statbkup.ini filename.
  }

  // Since we know this is a restore, now we should call ShowStatistics to update the data items to the new       ones we just loaded.
  // Otherwise user is left waiting around for the tick counter to reach the next automatic
  theApp.emuledlg->statisticswnd->ShowStatistics();
 }
 // Stupid Load -> Just load the values.
 else
 {
  // Load records for servers / network
  cumSrvrsMostWorkingServers = ini.GetInt( "SrvrsMostWorkingServers");
  cumSrvrsMostUsersOnline  = ini.GetInt( "SrvrsMostUsersOnline");
  cumSrvrsMostFilesAvail  = ini.GetInt( "SrvrsMostFilesAvail");

  // Load records for shared files
  cumSharedMostFilesShared = ini.GetInt( "SharedMostFilesShared");
  cumSharedLargestShareSize = ini.GetUInt64( "SharedLargestShareSize");
  cumSharedLargestAvgFileSize = ini.GetUInt64( "SharedLargestAvgFileSize");
  cumSharedLargestFileSize = ini.GetUInt64( "SharedLargestFileSize");

  // Initialize new       session statistic variables...
  sesDownCompletedFiles  = 0;

  sesUpData_EDONKEY   = 0;
  sesUpData_EDONKEYHYBRID  = 0;
  sesUpData_EMULE    = 0;
  sesUpData_MLDONKEY   = 0;
  sesUpData_AMULE    = 0;
  sesUpData_EMULECOMPAT  = 0;
  sesUpData_SHAREAZA   = 0;
  sesUpDataPort_4662   = 0;
  sesUpDataPort_OTHER   = 0;
  sesUpDataPort_PeerCache  = 0;

  sesDownData_EDONKEY   = 0;
  sesDownData_EDONKEYHYBRID = 0;
  sesDownData_EMULE   = 0;
  sesDownData_MLDONKEY  = 0;
  sesDownData_AMULE   = 0;
  sesDownData_EMULECOMPAT  = 0;
  sesDownData_SHAREAZA  = 0;
  sesDownData_URL    = 0;
  sesDownDataPort_4662  = 0;
  sesDownDataPort_OTHER  = 0;
  sesDownDataPort_PeerCache = 0;

  sesDownSuccessfulSessions = 0;
  sesDownFailedSessions  = 0;
  sesPartsSavedByICH   = 0;
 }

 if (!fileex || (stat_datetimeLastReset==0 && totalDownloadedBytes==0 && totalUploadedBytes==0))
 {
  time_t timeNow;
  time(&timeNow);
  stat_datetimeLastReset = timeNow;
 }

 return true;
}

// This formats the     long value that is saved for stat_datetimeLastReset
// If this value is 0 (Never reset), then it returns Unknown.
CString CPreferences::GetStatsLastResetStr(bool formatLong)
{
 // formatLong dictates the format of the string returned.
 // For example...
 // true: DateTime format from the .ini
 // false: DateTime format from the .ini for the log
 CString returnStr;
 if (GetStatsLastResetLng()) {
  tm *statsReset;
  char  szDateReset[128];
  time_t lastResetDateTime = (time_t) GetStatsLastResetLng();
  statsReset = localtime(&lastResetDateTime);
  if (statsReset){
   _tcsftime(szDateReset, _countof(szDateReset), formatLong ? GetDateTimeFormat() :  "%c", statsReset);
   returnStr = szDateReset;
  }
 }
 if (returnStr.IsEmpty())
  returnStr = GetResString(IDS_UNKNOWN);
 return returnStr;
}

// <-----khaos-

bool CPreferences::Save(){

 bool error = false;
 CString strFullPath;
 strFullPath = GetMuleDirectory(EMULE_CONFIGDIR) +  "preferences.dat";

 FILE* preffile = _tfsopen(strFullPath,  "wb", _SH_DENYWR);
 prefsExt->version = PREFFILE_VERSION;
 if (preffile){
  prefsExt->version=PREFFILE_VERSION;
  prefsExt->EmuleWindowPlacement=EmuleWindowPlacement;
  md4cpy(prefsExt->userhash, userhash);

  error = fwrite(prefsExt,sizeof(Preferences_Ext_Struct),1,preffile)!=1;
  if (thePrefs.GetCommitFiles() >= 2 || (thePrefs.GetCommitFiles() >= 1 && !theApp.emuledlg->IsRunning())){
   fflush(preffile); // flush file stream buffers to disk
_commit(_fileno(preffile)); // commit disk buffers to disk
  }
  fclose(preffile);
 }
 else
  error = true;

 SavePreferences();
 SaveStats();

 strFullPath = GetMuleDirectory(EMULE_CONFIGDIR) +  "shareddir.dat";
 CStdioFile sdirfile;
 if (sdirfile.Open(strFullPath, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::typeBinary))
 {
  try{
   // write Unicode byte-order mark 0xFEFF
   unsigned short wBOM = 0xFEFF;
   sdirfile.Write(&wBOM, sizeof(wBOM));

   for (POSITION pos = shareddir_list.GetHeadPosition();pos != 0;){
    sdirfile.WriteString(shareddir_list.GetNext(pos));
    sdirfile.Write( "\r\n", sizeof(char )*2);
   }
   if (thePrefs.GetCommitFiles() >= 2 || (thePrefs.GetCommitFiles() >= 1 && !theApp.emuledlg->IsRunning())){
    sdirfile.Flush(); // flush file stream buffers to disk buffers
    if (_commit(_fileno(sdirfile.m_pStream)) != 0) // commit disk buffers to disk
     AfxThrowFileException(CFileException::hardIO, GetLastError(), sdirfile.GetFileName());
   }
   sdirfile.Close();
  }
  catch(CFileException* error){
   char  buffer[MAX_CFEXP_ERRORMSG];
   error->GetErrorMessage(buffer,_countof(buffer));
   if (thePrefs.GetVerbose())
    AddDebugLogLine(true,  "Failed to save %s - %s", strFullPath, buffer);
   error->Delete();
  }
 }
 else
  error = true;

 ::CreateDirectory(GetMuleDirectory(EMULE_INCOMINGDIR), 0);
 ::CreateDirectory(GetTempDir(), 0);
 return error;
}

void CPreferences::CreateUserHash()
{
 for (int i = 0; i < 8; i++)
 {
  uint16 random = GetRandomUInt16();
  memcpy(&userhash[i*2], &random, 2);
 }

 // mark as emule client. that will be need in later version
 userhash[5] = 14;
 userhash[14] = 111;
}

int CPreferences::GetRecommendedMaxConnections() {
 int iRealMax = ::GetMaxWindowsTCPConnections();
 if(iRealMax == -1 || iRealMax > 520)
  return 500;

 if(iRealMax < 20)
  return iRealMax;

 if(iRealMax <= 256)
  return iRealMax - 10;

 return iRealMax - 20;
}

void CPreferences::SavePreferences()
{
 CString buffer;

 CIni ini(GetConfigFile(),  "eMule");
 //---
 ini.WriteString( "AppVersion", theApp.m_strCurVersionLong);
 //---


 ini.WriteInt( "DebugHeap", m_iDbgHeap);


 ini.WriteStringUTF8( "Nick", strNick);
 ini.WriteString( "IncomingDir", m_strIncomingDir);

 ini.WriteString( "TempDir", tempdir.GetAt(0));

 CString tempdirs;
 for (int i=1;i<tempdir.GetCount();i++) {
  tempdirs.Append(tempdir.GetAt(i) );
  if (i+1<tempdir.GetCount())
   tempdirs.Append( "|");
 }
 ini.WriteString( "TempDirs", tempdirs);

    ini.WriteInt( "MinUpload", minupload);
 ini.WriteInt( "MaxUpload",maxupload);
 ini.WriteInt( "MaxDownload",maxdownload);
 ini.WriteInt( "MaxConnections",maxconnections);
 ini.WriteInt( "MaxHalfConnections",maxhalfconnections);
 ini.WriteBool( "ConditionalTCPAccept", m_bConditionalTCPAccept);
 ini.WriteInt( "Port",port);
 ini.WriteInt( "UDPPort",udpport);
 ini.WriteInt( "ServerUDPPort", nServerUDPPort);
 ini.WriteInt( "MaxSourcesPerFile",maxsourceperfile );
 ini.WriteWORD( "Language",m_wLanguageID);
 ini.WriteInt( "SeeShare",m_iSeeShares);
 ini.WriteInt( "ToolTipDelay",m_iToolDelayTime);
 ini.WriteInt( "StatGraphsInterval",trafficOMeterInterval);
 ini.WriteInt( "StatsInterval",statsInterval);
 ini.WriteBool( "StatsFillGraphs",m_bFillGraphs);
 ini.WriteInt( "DownloadCapacity",maxGraphDownloadRate);
 ini.WriteInt( "UploadCapacityNew",maxGraphUploadRate);
 ini.WriteInt( "DeadServerRetry",m_uDeadServerRetries);
 ini.WriteInt( "ServerKeepAliveTimeout",m_dwServerKeepAliveTimeout);
 ini.WriteInt( "SplitterbarPosition",splitterbarPosition+2);
 ini.WriteInt( "SplitterbarPositionServer",splitterbarPositionSvr);
 ini.WriteInt( "SplitterbarPositionStat",splitterbarPositionStat+1);
 ini.WriteInt( "SplitterbarPositionStat_H ",splitterbarPositionStat_HL+1);
 ini.WriteInt( "SplitterbarPositionStat_HR",splitterbarPositionStat_HR+1);
 ini.WriteInt( "SplitterbarPositionFriend",splitterbarPositionFriend);
 ini.WriteInt( "SplitterbarPositionIRC",splitterbarPositionIRC);
 ini.WriteInt( "SplitterbarPositionShared",splitterbarPositionShared);
 ini.WriteInt( "TransferWnd1",m_uTransferWnd1);
 ini.WriteInt( "TransferWnd2",m_uTransferWnd2);
 ini.WriteInt( "VariousStatisticsMaxValue",statsMax);
 ini.WriteInt( "StatsAverageMinutes",statsAverageMinutes);
 ini.WriteInt( "MaxConnectionsPerFiveSeconds",MaxConperFive);
 ini.WriteInt( "Check4NewVersionDelay",versioncheckdays);

 ini.WriteBool( "Reconnect",reconnect);
 ini.WriteBool( "Scoresystem",m_bUseServerPriorities);
 ini.WriteBool( "Serverlist",m_bAutoUpdateServerList);
 ini.WriteBool( "UpdateNotifyTestClient",updatenotify);
 if (IsRunningAeroGlassTheme())
  ini.WriteBool( "MinToTray_Aero",mintotray);
 else
  ini.WriteBool( "MinToTray",mintotray);
 ini.WriteBool( "PreventStandby", m_bPreventStandby);
 ini.WriteBool( "StoreSearches", m_bStoreSearches);
 ini.WriteBool( "AddServersFromServer",m_bAddServersFromServer);
 ini.WriteBool( "AddServersFromClient",m_bAddServersFromClients);
 ini.WriteBool( "Splashscreen",splashscreen);
 ini.WriteBool( "BringToFront",bringtoforeground);
 ini.WriteBool( "TransferDoubleClick",transferDoubleclick);
 ini.WriteBool( "BeepOnError",beepOnError);
 ini.WriteBool( "ConfirmExit",confirmExit);
 ini.WriteBool( "FilterBadIPs",filterLANIPs);
    ini.WriteBool( "Autoconnect",autoconnect);
 ini.WriteBool( "OnlineSignature",onlineSig);
 ini.WriteBool( "StartupMinimized",startMinimized);
 ini.WriteBool( "AutoStart",m_bAutoStart);
 ini.WriteInt( "LastMainWndDlgID",m_iLastMainWndDlgID);
 ini.WriteInt( "LastLogPaneID",m_iLastLogPaneID);
 ini.WriteBool( "SafeServerConnect",m_bSafeServerConnect);
 ini.WriteBool( "ShowRatesOnTitle",showRatesInTitle);
 ini.WriteBool( "IndicateRatings",indicateratings);
 ini.WriteBool( "WatchClipboard4ED2kFilelinks",watchclipboard);
 ini.WriteInt( "SearchMethod",m_iSearchMethod);
 ini.WriteBool( "CheckDiskspace",checkDiskspace);
 ini.WriteInt( "MinFreeDiskSpace",m_uMinFreeDiskSpace);
 ini.WriteBool( "SparsePartFiles",m_bSparsePartFiles);
 ini.WriteString( "YourHostname",m_strYourHostname);

 // Barry - New properties...
    ini.WriteBool( "AutoConnectStaticOnly", m_bAutoConnectToStaticServersOnly);
 ini.WriteBool( "AutoTakeED2KLinks", autotakeed2klinks);
    ini.WriteBool( "AddNewFilesPaused", addnewfilespaused);
    ini.WriteInt ( "3DDepth", depth3D);
 ini.WriteBool( "MiniMule", m_bEnableMiniMule);

 ini.WriteString( "NotifierConfiguration", notifierConfiguration);
 ini.WriteBool( "NotifyOnDownload", notifierOnDownloadFinished);
 ini.WriteBool( "NotifyOnNewDownload", notifierOnNewDownload);
 ini.WriteBool( "NotifyOnChat", notifierOnChat);
 ini.WriteBool( "NotifyOnLog", notifierOnLog);
 ini.WriteBool( "NotifyOnImportantError", notifierOnImportantError);
 ini.WriteBool( "NotifierPopEveryChatMessage", notifierOnEveryChatMsg);
 ini.WriteBool( "NotifierPopNewVersion", notifierOnNewVersion);
 ini.WriteInt( "NotifierUseSound", (int)notifierSoundType);
 ini.WriteString( "NotifierSoundPath", notifierSoundFile);

 ini.WriteString( "TxtEditor",m_strTxtEditor);
 ini.WriteString( "VideoPlayer",m_strVideoPlayer);
 ini.WriteString( "VideoPlayerArgs",m_strVideoPlayerArgs);
 ini.WriteString( "MessageFilter",messageFilter);
 ini.WriteString( "CommentFilter",commentFilter);
 ini.WriteString( "DateTimeFormat",GetDateTimeFormat());
 ini.WriteString( "DateTimeFormat4Log",GetDateTimeFormat4Log());
 ini.WriteString( "WebTemplateFile",m_strTemplateFile);
 ini.WriteString( "FilenameCleanups",filenameCleanups);
 ini.WriteInt( "ExtractMetaData",m_iExtractMetaData);

 ini.WriteString( "DefaultIRCServerNew", m_strIRCServer);
 ini.WriteString( "IRCNick", m_strIRCNick);
 ini.WriteBool( "IRCAddTimestamp", m_bIRCAddTimeStamp);
 ini.WriteString( "IRCFilterName", m_strIRCChannelFilter);
 ini.WriteInt( "IRCFilterUser", m_uIRCChannelUserFilter);
 ini.WriteBool( "IRCUseFilter", m_bIRCUseChannelFilter);
 ini.WriteString( "IRCPerformString", m_strIRCPerformString);
 ini.WriteBool( "IRCUsePerform", m_bIRCUsePerform);
 ini.WriteBool( "IRCListOnConnect", m_bIRCGetChannelsOnConnect);
 ini.WriteBool( "IRCAcceptLink", m_bIRCAcceptLinks);
 ini.WriteBool( "IRCAcceptLinkFriends", m_bIRCAcceptLinksFriendsOnly);
 ini.WriteBool( "IRCSoundEvents", m_bIRCPlaySoundEvents);
 ini.WriteBool( "IRCIgnoreMiscMessages", m_bIRCIgnoreMiscMessages);
 ini.WriteBool( "IRCIgnoreJoinMessages", m_bIRCIgnoreJoinMessages);
 ini.WriteBool( "IRCIgnorePartMessages", m_bIRCIgnorePartMessages);
 ini.WriteBool( "IRCIgnoreQuitMessages", m_bIRCIgnoreQuitMessages);
 ini.WriteBool( "IRCIgnoreEmuleAddFriendMsgs", m_bIRCIgnoreEmuleAddFriendMsgs);
 ini.WriteBool( "IRCAllowEmuleAddFriend", m_bIRCAllowEmuleAddFriend);
 ini.WriteBool( "IRCIgnoreEmuleSendLinkMsgs", m_bIRCIgnoreEmuleSendLinkMsgs);
 ini.WriteBool( "IRCHelpChannel", m_bIRCJoinHelpChannel);
 ini.WriteBool( "IRCEnableSmileys",m_bIRCEnableSmileys);
 ini.WriteBool( "MessageEnableSmileys",m_bMessageEnableSmileys);

 ini.WriteBool( "SmartIdCheck", m_bSmartServerIdCheck);
 ini.WriteBool( "Verbose", m_bVerbose);
 ini.WriteBool( "DebugSourceExchange", m_bDebugSourceExchange); // do *not* use the according 'Get...' function here!
 ini.WriteBool( "LogBannedClients", m_bLogBannedClients);   // do *not* use the according 'Get...' function here!
 ini.WriteBool( "LogRatingDescReceived", m_bLogRatingDescReceived);// do *not* use the according 'Get...' function here!
 ini.WriteBool( "LogSecureIdent", m_bLogSecureIdent);    // do *not* use the according 'Get...' function here!
 ini.WriteBool( "LogFilteredIPs", m_bLogFilteredIPs);    // do *not* use the according 'Get...' function here!
 ini.WriteBool( "LogFileSaving", m_bLogFileSaving);    // do *not* use the according 'Get...' function here!
    ini.WriteBool( "LogA4AF", m_bLogA4AF);                           // do *not* use the according 'Get...' function here!
 ini.WriteBool( "LogUlDlEvents", m_bLogUlDlEvents);

 // following options are for debugging or when using an external debug device viewer only.
 ini.WriteInt( "DebugServerTCP",m_iDebugServerTCPLevel);
 ini.WriteInt( "DebugServerUDP",m_iDebugServerUDPLevel);
 ini.WriteInt( "DebugServerSources",m_iDebugServerSourcesLevel);
 ini.WriteInt( "DebugServerSearches",m_iDebugServerSearchesLevel);
 ini.WriteInt( "DebugClientTCP",m_iDebugClientTCPLevel);
 ini.WriteInt( "DebugClientUDP",m_iDebugClientUDPLevel);
 ini.WriteInt( "DebugClientKadUDP",m_iDebugClientKadUDPLevel);

 ini.WriteBool( "PreviewPrio", m_bpreviewprio);
 ini.WriteBool( "UpdateQueueListPref", m_bupdatequeuelist);
 ini.WriteBool( "ManualHighPrio", m_bManualAddedServersHighPriority);
 ini.WriteBool( "FullChunkTransfers", m_btransferfullchunks);
 ini.WriteBool( "ShowOverhead", m_bshowoverhead);
 ini.WriteBool( "VideoPreviewBackupped", moviePreviewBackup);
 ini.WriteInt( "StartNextFile", m_istartnextfile);

 ini.DeleteKey( "FileBufferSizePref"); // delete old 'file buff size' setting
 ini.WriteInt( "FileBufferSize", m_iFileBufferSize);

 ini.DeleteKey( "QueueSizePref"); // delete old 'queue size' setting
 ini.WriteInt( "QueueSize", m_iQueueSize);

 ini.WriteInt( "CommitFiles", m_iCommitFiles);
 ini.WriteBool( "DAPPref", m_bDAP);
 ini.WriteBool( "UAPPref", m_bUAP);
 ini.WriteBool( "FilterServersByIP",filterserverbyip);
 ini.WriteBool( "DisableKnownClientList",m_bDisableKnownClientList);
 ini.WriteBool( "DisableQueueList",m_bDisableQueueList);
 ini.WriteBool( "UseCreditSystem",m_bCreditSystem);
 ini.WriteBool( "SaveLogToDisk",log2disk);
 ini.WriteBool( "SaveDebugToDisk",debug2disk);
 ini.WriteBool( "EnableScheduler",scheduler);
 ini.WriteBool( "MessagesFromFriendsOnly",msgonlyfriends);
 ini.WriteBool( "MessageFromValidSourcesOnly",msgsecure);
 ini.WriteBool( "MessageUseCaptchas", m_bUseChatCaptchas);
 ini.WriteBool( "ShowInfoOnCatTabs",showCatTabInfos);
 ini.WriteBool( "DontRecreateStatGraphsOnResize",dontRecreateGraphs);
 ini.WriteBool( "AutoFilenameCleanup",autofilenamecleanup);
 ini.WriteBool( "ShowExtControls",m_bExtControls);
 ini.WriteBool( "UseAutocompletion",m_bUseAutocompl);
 ini.WriteBool( "NetworkKademlia",networkkademlia);
 ini.WriteBool( "NetworkED2K",networked2k);
 ini.WriteBool( "AutoClearCompleted",m_bRemoveFinishedDownloads);
 ini.WriteBool( "TransflstRemainOrder",m_bTransflstRemain);
 ini.WriteBool( "UseSimpleTimeRemainingcomputation",m_bUseOldTimeRemaining);
 ini.WriteBool( "AllocateFullFile",m_bAllocFull);

 ini.WriteInt( "VersionCheckLastAutomatic", versioncheckLastAutomatic);
 ini.WriteInt( "FilterLevel",filterlevel);

 ini.WriteBool( "SecureIdent", m_bUseSecureIdent);// change the name in future version to enable it by default
 ini.WriteBool( "AdvancedSpamFilter",m_bAdvancedSpamfilter);
 ini.WriteBool( "ShowDwlPercentage",m_bShowDwlPercentage);
 ini.WriteBool( "RemoveFilesToBin",m_bRemove2bin);
 //ini.WriteBool( "ShowCopyEd2kLinkCmd",m_bShowCopyEd2kLinkCmd);
 ini.WriteBool( "AutoArchivePreviewStart", m_bAutomaticArcPreviewStart);

 // Toolbar
 ini.WriteString( "ToolbarSetting", m_sToolbarSettings);
 ini.WriteString( "ToolbarBitmap", m_sToolbarBitmap );
 ini.WriteString( "ToolbarBitmapFolder", m_sToolbarBitmapFolder);
 ini.WriteInt( "ToolbarLabels", m_nToolbarLabels);
 ini.WriteInt( "ToolbarIconSize", m_sizToolbarIconSize.cx);
 ini.WriteString( "SkinProfile", m_strSkinProfile);
 ini.WriteString( "SkinProfileDir", m_strSkinProfileDir);

 ini.WriteBinary( "HyperTextFont", (LPBYTE)&m_lfHyperText, sizeof m_lfHyperText);
 ini.WriteBinary( "LogTextFont", (LPBYTE)&m_lfLogText, sizeof m_lfLogText);

 // ZZ:UploadSpeedSense -->
    ini.WriteBool( "USSEnabled", m_bDynUpEnabled);
    ini.WriteBool( "USSUseMillisecondPingTolerance", m_bDynUpUseMillisecondPingTolerance);
    ini.WriteInt( "USSPingTolerance", m_iDynUpPingTolerance);
 ini.WriteInt( "USSPingToleranceMilliseconds", m_iDynUpPingToleranceMilliseconds); // EastShare - Add by TAHO, USS limit
    ini.WriteInt( "USSGoingUpDivider", m_iDynUpGoingUpDivider);
    ini.WriteInt( "USSGoingDownDivider", m_iDynUpGoingDownDivider);
    ini.WriteInt( "USSNumberOfPings", m_iDynUpNumberOfPings);
 // ZZ:UploadSpeedSense <--

    ini.WriteBool( "A4AFSaveCpu", m_bA4AFSaveCpu); // ZZ:DownloadManager
    ini.WriteBool( "HighresTimer", m_bHighresTimer);
 ini.WriteInt( "WebMirrorAlertLevel", m_nWebMirrorAlertLevel);
 ini.WriteBool( "RunAsUnprivilegedUser", m_bRunAsUser);
 ini.WriteBool( "OpenPortsOnStartUp", m_bOpenPortsOnStartUp);
 ini.WriteInt( "DebugLogLevel", m_byLogLevel);
 ini.WriteInt( "WinXPSP2OrHigher", IsRunningXPSP2OrHigher());
 ini.WriteBool( "RememberCancelledFiles", m_bRememberCancelledFiles);
 ini.WriteBool( "RememberDownloadedFiles", m_bRememberDownloadedFiles);

 ini.WriteBool( "NotifierSendMail", m_bNotifierSendMail);
 ini.WriteString( "NotifierMailSender", m_strNotifierMailSender);
 ini.WriteString( "NotifierMailServer", m_strNotifierMailServer);
 ini.WriteString( "NotifierMailRecipient", m_strNotifierMailReceiver);

 ini.WriteBool( "WinaTransToolbar", m_bWinaTransToolbar);

 ini.WriteBool( "CryptLayerRequested", m_bCryptLayerRequested);
 ini.WriteBool( "CryptLayerRequired", m_bCryptLayerRequired);
 ini.WriteBool( "CryptLayerSupported", m_bCryptLayerSupported);
 ini.WriteInt( "KadUDPKey", m_dwKadUDPKey);

 ini.WriteBool( "EnableSearchResultSpamFilter", m_bEnableSearchResultFilter);


 ///////////////////////////////////////////////////////////////////////////
 // Section: "Proxy"
 //
 ini.WriteBool( "ProxyEnablePassword",proxy.EnablePassword, "Proxy");
 ini.WriteBool( "ProxyEnableProxy",proxy.UseProxy, "Proxy");
 ini.WriteString( "ProxyName",CStringW(proxy.name), "Proxy");
 ini.WriteString( "ProxyPassword",CStringW(proxy.password), "Proxy");
 ini.WriteString( "ProxyUser",CStringW(proxy.user), "Proxy");
 ini.WriteInt( "ProxyPort",proxy.port, "Proxy");
 ini.WriteInt( "ProxyType",proxy.type, "Proxy");


 ///////////////////////////////////////////////////////////////////////////
 // Section: "Statistics"
 //
 ini.WriteInt( "statsConnectionsGraphRatio", statsConnectionsGraphRatio, "Statistics");
 ini.WriteString( "statsExpandedTreeItems", m_strStatsExpandedTreeItems);
 CString buffer2;
 for (int i=0;i<15;i++) {
  buffer.Format( "0x%06x",GetStatsColor(i));
  buffer2.Format( "StatColor%i",i);
  ini.WriteString(buffer2,buffer, "Statistics" );
 }


 ///////////////////////////////////////////////////////////////////////////
 // Section: "WebServer"
 //
 ini.WriteString( "Password", GetWSPass(),  "WebServer");
 ini.WriteString( "PasswordLow", GetWSLowPass());
 ini.WriteInt( "Port", m_nWebPort);
 ini.WriteBool( "Enabled", m_bWebEnabled);
 ini.WriteBool( "UseGzip", m_bWebUseGzip);
 ini.WriteInt( "PageRefreshTime", m_nWebPageRefresh);
 ini.WriteBool( "UseLowRightsUser", m_bWebLowEnabled);
 ini.WriteBool( "AllowAdminHiLevelFunc",m_bAllowAdminHiLevFunc);
 ini.WriteInt( "WebTimeoutMins", m_iWebTimeoutMins);


 ///////////////////////////////////////////////////////////////////////////
 // Section: "MobileMule"
 //
 ini.WriteString( "Password", GetMMPass(),  "MobileMule");
 ini.WriteBool( "Enabled", m_bMMEnabled);
 ini.WriteInt( "Port", m_nMMPort);


 ///////////////////////////////////////////////////////////////////////////
 // Section: "PeerCache"
 //
 ini.WriteInt( "LastSearch", m_uPeerCacheLastSearch,  "PeerCache");
 ini.WriteBool( "Found", m_bPeerCacheWasFound);
 ini.WriteBool( "EnabledDeprecated", m_bPeerCacheEnabled);
 ini.WriteInt( "PCPort", m_nPeerCachePort);

 ///////////////////////////////////////////////////////////////////////////
 // Section: "UPnP"
 //
 ini.WriteBool( "EnableUPnP", m_bEnableUPnP,  "UPnP");
 ini.WriteBool( "SkipWANIPSetup", m_bSkipWANIPSetup);
 ini.WriteBool( "SkipWANPPPSetup", m_bSkipWANPPPSetup);
 ini.WriteBool( "CloseUPnPOnExit", m_bCloseUPnPOnExit);
 ini.WriteInt( "LastWorkingImplementation", m_nLastWorkingImpl);

}

void CPreferences::ResetStatsColor(int index)
{
 switch(index)
 {
  case  0: m_adwStatsColors[ 0]=RGB(  0,  0, 64);break;
  case  1: m_adwStatsColors[ 1]=RGB(192,192,255);break;
  case  2: m_adwStatsColors[ 2]=RGB(128,255,128);break;
  case  3: m_adwStatsColors[ 3]=RGB(  0,210,  0);break;
  case  4: m_adwStatsColors[ 4]=RGB(  0,128,  0);break;
  case  5: m_adwStatsColors[ 5]=RGB(255,128,128);break;
  case  6: m_adwStatsColors[ 6]=RGB(200,  0,  0);break;
  case  7: m_adwStatsColors[ 7]=RGB(140,  0,  0);break;
  case  8: m_adwStatsColors[ 8]=RGB(150,150,255);break;
  case  9: m_adwStatsColors[ 9]=RGB(192,  0,192);break;
  case 10: m_adwStatsColors[10]=RGB(255,255,128);break;
  case 11: m_adwStatsColors[11]=RGB(  0,  0,  0);break;
  case 12: m_adwStatsColors[12]=RGB(255,255,255);break;
  case 13: m_adwStatsColors[13]=RGB(255,255,255);break;
  case 14: m_adwStatsColors[14]=RGB(255,190,190);break;
 }
}

void CPreferences::GetAllStatsColors(int iCount, unsigned long * pdwColors)
{
 memset(pdwColors, 0, sizeof(*pdwColors) * iCount);
 memcpy(pdwColors, m_adwStatsColors, sizeof(*pdwColors) * min(_countof(m_adwStatsColors), iCount));
}

bool CPreferences::SetAllStatsColors(int iCount, const unsigned long* pdwColors)
{
 bool bModified = false;
 int iMin = min(_countof(m_adwStatsColors), iCount);
 for (int i = 0; i < iMin; i++)
 {
  if (m_adwStatsColors[i] != pdwColors[i])
  {
   m_adwStatsColors[i] = pdwColors[i];
   bModified = true;
  }
 }
 return bModified;
}

void CPreferences::IniCopy(CString si, CString di)
{
 CIni ini(GetConfigFile(),  "eMule");
 CString s = ini.GetString(si);
 // Do     write empty settings, this will mess up reading of default settings in case
 // there were no at all available!
 if (!s.IsEmpty())
 {
  ini.SetSection( "ListControlSetup");
  ini.WriteString(di,s);
 }
}

// Imports the tablesetups of emuleversions (.ini) <0.46b  - temporary
void CPreferences::ImportOldTableSetup() {

 IniCopy( "DownloadColumnHidden" ,  "DownloadListCtrlColumnHidden" );
 IniCopy( "DownloadColumnWidths" ,  "DownloadListCtrlColumnWidths" );
 IniCopy( "DownloadColumnOrder" ,   "DownloadListCtrlColumnOrders" );
 IniCopy( "TableSortItemDownload" ,  "DownloadListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingDownload" ,  "DownloadListCtrlTableSortAscending" );

 IniCopy( "ONContactListCtrlColumnHidden" ,  "ONContactListCtrlColumnHidden" );
 IniCopy( "ONContactListCtrlColumnWidths" ,  "ONContactListCtrlColumnWidths" );
 IniCopy( "ONContactListCtrlColumnOrders" ,   "ONContactListCtrlColumnOrders" );

 IniCopy( "KadSearchListCtrlColumnHidden" ,  "KadSearchListCtrlColumnHidden" );
 IniCopy( "KadSearchListCtrlColumnWidths" ,  "KadSearchListCtrlColumnWidths" );
 IniCopy( "KadSearchListCtrlColumnOrders" ,   "KadSearchListCtrlColumnOrders" );

 IniCopy( "UploadColumnHidden" ,   "UploadListCtrlColumnHidden" );
 IniCopy( "UploadColumnWidths" ,   "UploadListCtrlColumnWidths" );
 IniCopy( "UploadColumnOrder" ,   "UploadListCtrlColumnOrders" );
 IniCopy( "TableSortItemUpload" ,   "UploadListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingUpload",  "UploadListCtrlTableSortAscending" );

 IniCopy( "QueueColumnHidden" ,   "QueueListCtrlColumnHidden" );
 IniCopy( "QueueColumnWidths" ,   "QueueListCtrlColumnWidths" );
 IniCopy( "QueueColumnOrder" ,   "QueueListCtrlColumnOrders" );
 IniCopy( "TableSortItemQueue" ,   "QueueListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingQueue" ,  "QueueListCtrlTableSortAscending" );

 IniCopy( "SearchColumnHidden" ,   "SearchListCtrlColumnHidden" );
 IniCopy( "SearchColumnWidths" ,   "SearchListCtrlColumnWidths" );
 IniCopy( "SearchColumnOrder" ,   "SearchListCtrlColumnOrders" );
 IniCopy( "TableSortItemSearch" ,   "SearchListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingSearch",  "SearchListCtrlTableSortAscending" );

 IniCopy( "SharedColumnHidden" ,   "SharedFilesCtrlColumnHidden" );
 IniCopy( "SharedColumnWidths" ,   "SharedFilesCtrlColumnWidths" );
 IniCopy( "SharedColumnOrder" ,   "SharedFilesCtrlColumnOrders" );
 IniCopy( "TableSortItemShared" ,   "SharedFilesCtrlTableSortItem" );
 IniCopy( "TableSortAscendingShared",  "SharedFilesCtrlTableSortAscending" );

 IniCopy( "ServerColumnHidden" ,   "ServerListCtrlColumnHidden" );
 IniCopy( "ServerColumnWidths" ,   "ServerListCtrlColumnWidths" );
 IniCopy( "ServerColumnOrder" ,   "ServerListCtrlColumnOrders" );
 IniCopy( "TableSortItemServer" ,   "ServerListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingServer",  "ServerListCtrlTableSortAscending" );

 IniCopy( "ClientListColumnHidden" ,   "ClientListCtrlColumnHidden" );
 IniCopy( "ClientListColumnWidths" ,   "ClientListCtrlColumnWidths" );
 IniCopy( "ClientListColumnOrder" ,   "ClientListCtrlColumnOrders" );
 IniCopy( "TableSortItemClientList" ,   "ClientListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingClientList",  "ClientListCtrlTableSortAscending" );

 IniCopy( "FilenamesListColumnHidden" ,  "FileDetailDlgNameColumnHidden" );
 IniCopy( "FilenamesListColumnWidths" ,  "FileDetailDlgNameColumnWidths" );
 IniCopy( "FilenamesListColumnOrder" ,  "FileDetailDlgNameColumnOrders" );
 IniCopy( "TableSortItemFilenames" ,   "FileDetailDlgNameTableSortItem" );
 IniCopy( "TableSortAscendingFilenames",   "FileDetailDlgNameTableSortAscending" );

 IniCopy( "IrcMainColumnHidden" ,   "IrcNickListCtrlColumnHidden" );
 IniCopy( "IrcMainColumnWidths" ,   "IrcNickListCtrlColumnWidths" );
 IniCopy( "IrcMainColumnOrder" ,   "IrcNickListCtrlColumnOrders" );
 IniCopy( "TableSortItemIrcMain" ,  "IrcNickListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingIrcMain", "IrcNickListCtrlTableSortAscending" );

 IniCopy( "IrcChannelsColumnHidden" ,   "IrcChannelListCtrlColumnHidden" );
 IniCopy( "IrcChannelsColumnWidths" ,   "IrcChannelListCtrlColumnWidths" );
 IniCopy( "IrcChannelsColumnOrder" ,   "IrcChannelListCtrlColumnOrders" );
 IniCopy( "TableSortItemIrcChannels" ,  "IrcChannelListCtrlTableSortItem" );
 IniCopy( "TableSortAscendingIrcChannels", "IrcChannelListCtrlTableSortAscending" );

 IniCopy( "DownloadClientsColumnHidden" ,   "DownloadClientsCtrlColumnHidden" );
 IniCopy( "DownloadClientsColumnWidths" ,   "DownloadClientsCtrlColumnWidths" );
 IniCopy( "DownloadClientsColumnOrder" ,   "DownloadClientsCtrlColumnOrders" );
}

void CPreferences::LoadPreferences()
{
 CIni ini(GetConfigFile(),  "eMule");

 // import table setups - temporary
 if (ini.GetInt( "SearchListCtrlTableSortItem",-1, "ListControlSetup")==-1)
  ImportOldTableSetup();
 ini.SetSection( "eMule");

 CString strCurrVersion, strPrefsVersion;

 strCurrVersion = theApp.m_strCurVersionLong;
 strPrefsVersion = ini.GetString( "AppVersion");

 m_bFirstStart = false;

 if (strCurrVersion != strPrefsVersion){
  m_bFirstStart = true;
 }


 m_iDbgHeap = ini.GetInt( "DebugHeap", 1);




 m_nWebMirrorAlertLevel = ini.GetInt( "WebMirrorAlertLevel",0);
 updatenotify=ini.GetBool( "UpdateNotifyTestClient",true);

 SetUserNick(ini.GetStringUTF8( "Nick", DEFAULT_NICK));
 if (strNick.IsEmpty() || IsDefaultNick(strNick))
  SetUserNick(DEFAULT_NICK);

 m_strIncomingDir = ini.GetString( "IncomingDir", _T(""));
 if (m_strIncomingDir.IsEmpty()) // We want GetDefaultDirectory to also create the folder, so we have to know if we use the default or not
  m_strIncomingDir = GetDefaultDirectory(EMULE_INCOMINGDIR, true);
 MakeFoldername(m_strIncomingDir);

 // load setting
 CString tempdirs;
 tempdirs = ini.GetString( "TempDir", _T(""));
 if (tempdirs.IsEmpty()) // We want GetDefaultDirectory to also create the folder, so we have to know if we use the default or not
  tempdirs = GetDefaultDirectory(EMULE_TEMPDIR, true);
 tempdirs +=  "|" + ini.GetString( "TempDirs");

 int curPos=0;
 bool doubled;
 CString atmp=tempdirs.Tokenize( "|", curPos);
 while (!atmp.IsEmpty())
 {
  atmp.Trim();
  if (!atmp.IsEmpty()) {
   MakeFoldername(atmp);
   doubled=false;
   for (int i=0;i<tempdir.GetCount();i++) // avoid double tempdirs
    if (atmp.CompareNoCase(GetTempDir(i))==0) {
     doubled=true;
     break;
    }
   if (!doubled) {
    if (PathFileExists(atmp)==FALSE) {
     CreateDirectory(atmp,NULL);
     if (PathFileExists(atmp)==TRUE || tempdir.GetCount()==0)
      tempdir.Add(atmp);
    }
    else
     tempdir.Add(atmp);
   }
  }
  atmp = tempdirs.Tokenize( "|", curPos);
 }

 maxGraphDownloadRate=ini.GetInt( "DownloadCapacity",96);
 if (maxGraphDownloadRate==0)
  maxGraphDownloadRate=96;

 maxGraphUploadRate = ini.GetInt( "UploadCapacityNew",-1);
 if (maxGraphUploadRate == 0)
  maxGraphUploadRate = UNLIMITED;
 else if (maxGraphUploadRate == -1){
  // converting value from prior versions
  int nOldUploadCapacity = ini.GetInt( "UploadCapacity", 16);
  if (nOldUploadCapacity == 16 && ini.GetInt( "MaxUpload",12) == 12){
   // either this is a complete new       install, or the prior version used the default value
   // in both cases, set the new       default values to unlimited
   maxGraphUploadRate = UNLIMITED;
   ini.WriteInt( "MaxUpload",UNLIMITED,  "eMule");
  }
  else
   maxGraphUploadRate = nOldUploadCapacity; // use old custoum value
 }

 minupload=(uint16)ini.GetInt( "MinUpload", 1);
 maxupload=(uint16)ini.GetInt( "MaxUpload",UNLIMITED);
 if (maxupload > maxGraphUploadRate && maxupload != UNLIMITED)
  maxupload = (uint16)(maxGraphUploadRate * .8);

 maxdownload=(uint16)ini.GetInt( "MaxDownload", UNLIMITED);
 if (maxdownload > maxGraphDownloadRate && maxdownload != UNLIMITED)
  maxdownload = (uint16)(maxGraphDownloadRate * .8);
 maxconnections=ini.GetInt( "MaxConnections",GetRecommendedMaxConnections());
 maxhalfconnections=ini.GetInt( "MaxHalfConnections",9);
 m_bConditionalTCPAccept = ini.GetBool( "ConditionalTCPAccept", false);

 // reset max halfopen to a default if    changed to or away
 int dwSP2OrHigher = ini.GetInt( "WinXPSP2OrHigher", -1);
 int dwCurSP2OrHigher = IsRunningXPSP2OrHigher();
 if (dwSP2OrHigher != dwCurSP2OrHigher){
  if (dwCurSP2OrHigher == 0)
   maxhalfconnections = 50;
  else if (dwCurSP2OrHigher == 1)
   maxhalfconnections = 9;
 }

 m_strBindAddrW = ini.GetString( "BindAddr");
 m_strBindAddrW.Trim();
 m_pszBindAddrW = m_strBindAddrW.IsEmpty() ? NULL : (const long*)m_strBindAddrW;
 m_strBindAddrA = m_strBindAddrW;
 m_pszBindAddrA = m_strBindAddrA.IsEmpty() ? NULL : (const char*)m_strBindAddrA;

 port = (uint16)ini.GetInt( "Port", 0);
 if (port == 0)
  port = thePrefs.GetRandomTCPPort();

 // 0 is a valid value for the     port setting, as it is used for disabling it.
 int iPort = ini.GetInt( "UDPPort", INT_MAX/*invalid port value*/);
 if (iPort == INT_MAX)
  udpport = thePrefs.GetRandomUDPPort();
 else
  udpport = (uint16)iPort;

 nServerUDPPort = (uint16)ini.GetInt( "ServerUDPPort", -1); // 0 = Don't use     port for servers, -1 =     a random
 maxsourceperfile=ini.GetInt( "MaxSourcesPerFile",400 );
 m_wLanguageID=ini.GetWORD( "Language",0);
 m_iSeeShares=(EViewSharedFilesAccess)ini.GetInt( "SeeShare",vsfaNobody);
 m_iToolDelayTime=ini.GetInt( "ToolTipDelay",1);
 trafficOMeterInterval=ini.GetInt( "StatGraphsInterval",3);
 statsInterval=ini.GetInt( "statsInterval",5);
 m_bFillGraphs=ini.GetBool( "StatsFillGraphs");
 dontcompressavi=ini.GetBool( "DontCompressAvi",false);

 m_uDeadServerRetries=ini.GetInt( "DeadServerRetry",1);
 if (m_uDeadServerRetries > MAX_SERVERFAILCOUNT)
  m_uDeadServerRetries = MAX_SERVERFAILCOUNT;
 m_dwServerKeepAliveTimeout=ini.GetInt( "ServerKeepAliveTimeout",0);
 splitterbarPosition=ini.GetInt( "SplitterbarPosition",75);
 if (splitterbarPosition < 9)
  splitterbarPosition = 9;
 else if (splitterbarPosition > 93)
  splitterbarPosition = 93;
 splitterbarPositionStat=ini.GetInt( "SplitterbarPositionStat",30);
 splitterbarPositionStat_HL=ini.GetInt( "SplitterbarPositionStat_H ",66);
 splitterbarPositionStat_HR=ini.GetInt( "SplitterbarPositionStat_HR",33);
 if (splitterbarPositionStat_HR+1>=splitterbarPositionStat_HL){
  splitterbarPositionStat_HL = 66;
  splitterbarPositionStat_HR = 33;
 }
 splitterbarPositionFriend=ini.GetInt( "SplitterbarPositionFriend",170);
 splitterbarPositionShared=ini.GetInt( "SplitterbarPositionShared",179);
 splitterbarPositionIRC=ini.GetInt( "SplitterbarPositionIRC",170);
 splitterbarPositionSvr=ini.GetInt( "SplitterbarPositionServer",75);
 if (splitterbarPositionSvr>90 || splitterbarPositionSvr<10)
  splitterbarPositionSvr=75;

 m_uTransferWnd1 = ini.GetInt( "TransferWnd1",0);
 m_uTransferWnd2 = ini.GetInt( "TransferWnd2",1);

 statsMax=ini.GetInt( "VariousStatisticsMaxValue",100);
 statsAverageMinutes=ini.GetInt( "StatsAverageMinutes",5);
 MaxConperFive=ini.GetInt( "MaxConnectionsPerFiveSeconds",GetDefaultMaxConperFive());

 reconnect = ini.GetBool( "Reconnect", true);
 m_bUseServerPriorities = ini.GetBool( "Scoresystem", true);
 m_bUseUserSortedServerList = ini.GetBool( "UserSortedServerList", false);
 ICH = ini.GetBool( "ICH", true);
 m_bAutoUpdateServerList = ini.GetBool( "Serverlist", false);

 // since the minimize to tray button is not working under Aero (at least not at this point),
 // we enable map the minimize to tray on the minimize button by default if Aero is running
 if (IsRunningAeroGlassTheme())
  mintotray=ini.GetBool( "MinToTray_Aero", true);
 else
  mintotray=ini.GetBool( "MinToTray", false);

 m_bPreventStandby = ini.GetBool( "PreventStandby", false);
 m_bStoreSearches = ini.GetBool( "StoreSearches", true);
 m_bAddServersFromServer=ini.GetBool( "AddServersFromServer",false);
 m_bAddServersFromClients=ini.GetBool( "AddServersFromClient",false);
 splashscreen=ini.GetBool( "Splashscreen",true);
 bringtoforeground=ini.GetBool( "BringToFront",true);
 transferDoubleclick=ini.GetBool( "TransferDoubleClick",true);
 beepOnError=ini.GetBool( "BeepOnError",true);
 confirmExit=ini.GetBool( "ConfirmExit",true);
 filterLANIPs=ini.GetBool( "FilterBadIPs",true);
 m_bAllocLocalHostIP=ini.GetBool( "AllowLocalHostIP",false);
 autoconnect=ini.GetBool( "Autoconnect",false);
 showRatesInTitle=ini.GetBool( "ShowRatesOnTitle",false);
 m_bIconflashOnNewMessage=ini.GetBool( "IconflashOnNewMessage",false);

 onlineSig=ini.GetBool( "OnlineSignature",false);
 startMinimized=ini.GetBool( "StartupMinimized",false);
 m_bAutoStart=ini.GetBool( "AutoStart",false);
 m_bRestoreLastMainWndDlg=ini.GetBool( "RestoreLastMainWndDlg",false);
 m_iLastMainWndDlgID=ini.GetInt( "LastMainWndDlgID",0);
 m_bRestoreLastLogPane=ini.GetBool( "RestoreLastLogPane",false);
 m_iLastLogPaneID=ini.GetInt( "LastLogPaneID",0);
 m_bSafeServerConnect =ini.GetBool( "SafeServerConnect",false);

 m_bTransflstRemain =ini.GetBool( "TransflstRemainOrder",false);
 filterserverbyip=ini.GetBool( "FilterServersByIP",false);
 filterlevel=ini.GetInt( "FilterLevel",127);
 checkDiskspace=ini.GetBool( "CheckDiskspace",false);
 m_uMinFreeDiskSpace=ini.GetInt( "MinFreeDiskSpace",20*1024*1024);
 m_bSparsePartFiles=ini.GetBool( "SparsePartFiles",false);
 m_strYourHostname=ini.GetString( "YourHostname",  "");

 // Barry - New properties...
 m_bAutoConnectToStaticServersOnly = ini.GetBool( "AutoConnectStaticOnly",false);
 autotakeed2klinks = ini.GetBool( "AutoTakeED2KLinks",true);
 addnewfilespaused = ini.GetBool( "AddNewFilesPaused",false);
 depth3D = ini.GetInt( "3DDepth", 5);
 m_bEnableMiniMule = ini.GetBool( "MiniMule", true);

 // Notifier
 notifierConfiguration = ini.GetString( "NotifierConfiguration", GetMuleDirectory(EMULE_CONFIGDIR) +  "Notifier.ini");
    notifierOnDownloadFinished = ini.GetBool( "NotifyOnDownload");
 notifierOnNewDownload = ini.GetBool( "NotifyOnNewDownload");
    notifierOnChat = ini.GetBool( "NotifyOnChat");
    notifierOnLog = ini.GetBool( "NotifyOnLog");
 notifierOnImportantError = ini.GetBool( "NotifyOnImportantError");
 notifierOnEveryChatMsg = ini.GetBool( "NotifierPopEveryChatMessage");
 notifierOnNewVersion = ini.GetBool( "NotifierPopNewVersion");
    notifierSoundType = (ENotifierSoundType)ini.GetInt( "NotifierUseSound", ntfstNoSound);
 notifierSoundFile = ini.GetString( "NotifierSoundPath");

 m_strDateTimeFormat = ini.GetString( "DateTimeFormat",  "%A, %c");
 m_strDateTimeFormat4Log = ini.GetString( "DateTimeFormat4Log",  "%c");

 m_strIRCServer = ini.GetString( "DefaultIRCServerNew",  "ircchat.emule-project.net");
 m_strIRCNick = ini.GetString( "IRCNick");
 m_bIRCAddTimeStamp = ini.GetBool( "IRCAddTimestamp", true);
 m_bIRCUseChannelFilter = ini.GetBool( "IRCUseFilter", true);
 m_strIRCChannelFilter = ini.GetString( "IRCFilterName",  "#emule-*");
 if (m_strIRCChannelFilter.IsEmpty())
  m_bIRCUseChannelFilter = false;
 m_uIRCChannelUserFilter = ini.GetInt( "IRCFilterUser", 0);
 m_strIRCPerformString = ini.GetString( "IRCPerformString");
 m_bIRCUsePerform = ini.GetBool( "IRCUsePerform", false);
 m_bIRCGetChannelsOnConnect = ini.GetBool( "IRCListOnConnect", true);
 m_bIRCAcceptLinks = ini.GetBool( "IRCAcceptLink", true);
 m_bIRCAcceptLinksFriendsOnly = ini.GetBool( "IRCAcceptLinkFriends", true);
 m_bIRCPlaySoundEvents = ini.GetBool( "IRCSoundEvents", false);
 m_bIRCIgnoreMiscMessages = ini.GetBool( "IRCIgnoreMiscMessages", false);
 m_bIRCIgnoreJoinMessages = ini.GetBool( "IRCIgnoreJoinMessages", true);
 m_bIRCIgnorePartMessages = ini.GetBool( "IRCIgnorePartMessages", true);
 m_bIRCIgnoreQuitMessages = ini.GetBool( "IRCIgnoreQuitMessages", true);
 m_bIRCIgnoreEmuleAddFriendMsgs = ini.GetBool( "IRCIgnoreEmuleAddFriendMsgs", false);
 m_bIRCAllowEmuleAddFriend = ini.GetBool( "IRCAllowEmuleAddFriend", true);
 m_bIRCIgnoreEmuleSendLinkMsgs = ini.GetBool( "IRCIgnoreEmuleSendLinkMsgs", false);
 m_bIRCJoinHelpChannel = ini.GetBool( "IRCHelpChannel", true);
 m_bIRCEnableSmileys = ini.GetBool( "IRCEnableSmileys", true);
 m_bMessageEnableSmileys = ini.GetBool( "MessageEnableSmileys", true);

 m_bSmartServerIdCheck = ini.GetBool( "SmartIdCheck",true);
 log2disk = ini.GetBool( "SaveLogToDisk",false);
 uMaxLogFileSize = ini.GetInt( "MaxLogFileSize", 1024*1024);
 iMaxLogBuff = ini.GetInt( "MaxLogBuff",64) * 1024;
 m_iLogFileFormat = (ELogFileFormat)ini.GetInt( "LogFileFormat", Unicode);
 m_bEnableVerboseOptions=ini.GetBool( "VerboseOptions", true);
 if (m_bEnableVerboseOptions)
 {
  m_bVerbose=ini.GetBool( "Verbose",false);
  m_bFullVerbose=ini.GetBool( "FullVerbose",false);
  debug2disk=ini.GetBool( "SaveDebugToDisk",false);
  m_bDebugSourceExchange=ini.GetBool( "DebugSourceExchange",false);
  m_bLogBannedClients=ini.GetBool( "LogBannedClients", true);
  m_bLogRatingDescReceived=ini.GetBool( "LogRatingDescReceived",true);
  m_bLogSecureIdent=ini.GetBool( "LogSecureIdent",true);
  m_bLogFilteredIPs=ini.GetBool( "LogFilteredIPs",true);
  m_bLogFileSaving=ini.GetBool( "LogFileSaving",false);
        m_bLogA4AF=ini.GetBool( "LogA4AF",false); // ZZ:DownloadManager
  m_bLogUlDlEvents=ini.GetBool( "LogUlDlEvents",true);
 }
 else
 {
  if (m_bRestoreLastLogPane && m_iLastLogPaneID>=2)
   m_iLastLogPaneID = 1;
 }

 // following options are for debugging or when using an external debug device viewer only.
 m_iDebugServerTCPLevel = ini.GetInt( "DebugServerTCP", 0);
 m_iDebugServerUDPLevel = ini.GetInt( "DebugServerUDP", 0);
 m_iDebugServerSourcesLevel = ini.GetInt( "DebugServerSources", 0);
 m_iDebugServerSearchesLevel = ini.GetInt( "DebugServerSearches", 0);
 m_iDebugClientTCPLevel = ini.GetInt( "DebugClientTCP", 0);
 m_iDebugClientUDPLevel = ini.GetInt( "DebugClientUDP", 0);
 m_iDebugClientKadUDPLevel = ini.GetInt( "DebugClientKadUDP", 0);
 m_iDebugSearchResultDetailLevel = ini.GetInt( "DebugSearchResultDetailLevel", 0);












 m_bpreviewprio=ini.GetBool( "PreviewPrio",false);
 m_bupdatequeuelist=ini.GetBool( "UpdateQueueListPref",false);
 m_bManualAddedServersHighPriority=ini.GetBool( "ManualHighPrio",false);
 m_btransferfullchunks=ini.GetBool( "FullChunkTransfers",true);
 m_istartnextfile=ini.GetInt( "StartNextFile",0);
 m_bshowoverhead=ini.GetBool( "ShowOverhead",false);
 moviePreviewBackup=ini.GetBool( "VideoPreviewBackupped",true);
 m_iPreviewSmallBlocks=ini.GetInt( "PreviewSmallBlocks", 0);
 m_bPreviewCopiedArchives=ini.GetBool( "PreviewCopiedArchives", true);
 m_iInspectAllFileTypes=ini.GetInt( "InspectAllFileTypes", 0);
 m_bAllocFull=ini.GetBool( "AllocateFullFile",0);
 m_bAutomaticArcPreviewStart=ini.GetBool( "AutoArchivePreviewStart", true );

 // read file buffer
 m_iFileBufferSize=ini.GetInt( "FileBufferSizePref",0); // old setting
 if (m_iFileBufferSize == 0)
  m_iFileBufferSize = 256*1024;
 else
  m_iFileBufferSize = ((m_iFileBufferSize*15000 + 512)/1024)*1024;
 m_iFileBufferSize=ini.GetInt( "FileBufferSize",m_iFileBufferSize);

 // read queue
 m_iQueueSize=ini.GetInt( "QueueSizePref",0); // old setting
 if (m_iQueueSize == 0)
  m_iQueueSize = 50*100;
 else
  m_iQueueSize = m_iQueueSize*100;
 m_iQueueSize=ini.GetInt( "QueueSize",m_iQueueSize);

 m_iCommitFiles=ini.GetInt( "CommitFiles", 1); // 1 = "commit" on application shut down; 2 = "commit" on each file saveing
 versioncheckdays=ini.GetInt( "Check4NewVersionDelay",5);
 m_bDAP=ini.GetBool( "DAPPref",true);
 m_bUAP=ini.GetBool( "UAPPref",true);
 m_bPreviewOnIconDblClk=ini.GetBool( "PreviewOnIconDblClk",false);
 indicateratings=ini.GetBool( "IndicateRatings",true);
 watchclipboard=ini.GetBool( "WatchClipboard4ED2kFilelinks",false);
 m_iSearchMethod=ini.GetInt( "SearchMethod",0);

 showCatTabInfos=ini.GetBool( "ShowInfoOnCatTabs",false);
// resumeSameCat=ini.GetBool( "ResumeNextFromSameCat",false);
 dontRecreateGraphs =ini.GetBool( "DontRecreateStatGraphsOnResize",false);
 m_bExtControls =ini.GetBool( "ShowExtControls",false);

 versioncheckLastAutomatic=ini.GetInt( "VersionCheckLastAutomatic",0);
 m_bDisableKnownClientList=ini.GetBool( "DisableKnownClientList",false);
 m_bDisableQueueList=ini.GetBool( "DisableQueueList",false);
 m_bCreditSystem=ini.GetBool( "UseCreditSystem",true);
 scheduler=ini.GetBool( "EnableScheduler",false);
 msgonlyfriends=ini.GetBool( "MessagesFromFriendsOnly",false);
 msgsecure=ini.GetBool( "MessageFromValidSourcesOnly",true);
 m_bUseChatCaptchas = ini.GetBool( "MessageUseCaptchas", true);
 autofilenamecleanup=ini.GetBool( "AutoFilenameCleanup",false);
 m_bUseAutocompl=ini.GetBool( "UseAutocompletion",true);
 m_bShowDwlPercentage=ini.GetBool( "ShowDwlPercentage",false);
 networkkademlia=ini.GetBool( "NetworkKademlia",true);
 networked2k=ini.GetBool( "NetworkED2K",true);
 m_bRemove2bin=ini.GetBool( "RemoveFilesToBin",true);
 m_bShowCopyEd2kLinkCmd=ini.GetBool( "ShowCopyEd2kLinkCmd",false);

 m_iMaxChatHistory=ini.GetInt( "MaxChatHistoryLines",100);
 if (m_iMaxChatHistory < 1)
  m_iMaxChatHistory = 100;
 maxmsgsessions=ini.GetInt( "MaxMessageSessions",50);
 m_bShowActiveDownloadsBold = ini.GetBool( "ShowActiveDownloadsBold", false);

 m_strTxtEditor = ini.GetString( "TxtEditor",  "notepad.exe");
 m_strVideoPlayer = ini.GetString( "VideoPlayer",  "");
 m_strVideoPlayerArgs = ini.GetString( "VideoPlayerArgs", "");

 m_strTemplateFile = ini.GetString( "WebTemplateFile", GetMuleDirectory(EMULE_EXECUTEABLEDIR) +  "eMule.tmpl");
 // if emule is using the default, check if the file is in the config folder, as it used to be in prior version
 // and might be wanted by the user when switching to a personalized template
 if (m_strTemplateFile.Compare(GetMuleDirectory(EMULE_EXECUTEABLEDIR) +  "eMule.tmpl") == 0){
  CFileFind ff;
  if (ff.FindFile(GetMuleDirectory(EMULE_CONFIGDIR) +  "eMule.tmpl"))
   m_strTemplateFile = GetMuleDirectory(EMULE_CONFIGDIR) +  "eMule.tmpl";
  ff.Close();
 }

 messageFilter=ini.GetStringLong( "MessageFilter", "fastest download speed|fastest eMule");
 commentFilter = ini.GetStringLong( "CommentFilter", "http://|https://|ftp://|www.|ftp.");
 commentFilter.MakeLower();
 filenameCleanups=ini.GetStringLong( "FilenameCleanups", "http|www.|.com|.de|.org|.net|shared|powered|sponsored|sharelive|filedonkey|");
 m_iExtractMetaData = ini.GetInt( "ExtractMetaData", 1); // 0=disable, 1=mp3, 2=        
 if (m_iExtractMetaData > 1)
  m_iExtractMetaData = 1;
 m_bAdjustNTFSDaylightFileTime=ini.GetBool( "AdjustNTFSDaylightFileTime", true);

 m_bUseSecureIdent=ini.GetBool( "SecureIdent",true);
 m_bAdvancedSpamfilter=ini.GetBool( "AdvancedSpamFilter",true);
 m_bRemoveFinishedDownloads=ini.GetBool( "AutoClearCompleted",false);
 m_bUseOldTimeRemaining= ini.GetBool( "UseSimpleTimeRemainingcomputation",false);

 // Toolbar
 m_sToolbarSettings = ini.GetString( "ToolbarSetting", strDefaultToolbar);
 m_sToolbarBitmap = ini.GetString( "ToolbarBitmap",  "");
 m_sToolbarBitmapFolder = ini.GetString( "ToolbarBitmapFolder", _T(""));
 if (m_sToolbarBitmapFolder.IsEmpty()) // We want GetDefaultDirectory to also create the folder, so we have to know if we use the default or not
  m_sToolbarBitmapFolder = GetDefaultDirectory(EMULE_TOOLBARDIR, true);
 m_nToolbarLabels = (EToolbarLabelType)ini.GetInt( "ToolbarLabels", CMuleToolbarCtrl::GetDefaultLabelType());
 m_bReBarToolbar = ini.GetBool( "ReBarToolbar", 1);
 m_sizToolbarIconSize.cx = m_sizToolbarIconSize.cy = ini.GetInt( "ToolbarIconSize", 32);
 m_iStraightWindowStyles=ini.GetInt( "StraightWindowStyles",0);
 m_bUseSystemFontForMainControls=ini.GetBool( "UseSystemFontForMainControls",0);
 m_bRTLWindowsLayout = ini.GetBool( "RTLWindowsLayout");
 m_strSkinProfile = ini.GetString( "SkinProfile",  "");
 m_strSkinProfileDir = ini.GetString( "SkinProfileDir", _T(""));
 if (m_strSkinProfileDir.IsEmpty()) // We want GetDefaultDirectory to also create the folder, so we have to know if we use the default or not
  m_strSkinProfileDir = GetDefaultDirectory(EMULE_SKINDIR, true);


 LPBYTE pData = NULL;
 unsigned int uSize = sizeof m_lfHyperText;
 if (ini.GetBinary( "HyperTextFont", &pData, &uSize) && uSize == sizeof m_lfHyperText)
  memcpy(&m_lfHyperText, pData, sizeof m_lfHyperText);
 else
  memset(&m_lfHyperText, 0, sizeof m_lfHyperText);
 delete[] pData;

 pData = NULL;
 uSize = sizeof m_lfLogText;
 if (ini.GetBinary( "LogTextFont", &pData, &uSize) && uSize == sizeof m_lfLogText)
  memcpy(&m_lfLogText, pData, sizeof m_lfLogText);
 else
  memset(&m_lfLogText, 0, sizeof m_lfLogText);
 delete[] pData;

 m_crLogError = ini.GetColRef( "LogErrorColor", m_crLogError);
 m_crLogWarning = ini.GetColRef( "LogWarningColor", m_crLogWarning);
 m_crLogSuccess = ini.GetColRef( "LogSuccessColor", m_crLogSuccess);

 if (statsAverageMinutes < 1)
  statsAverageMinutes = 5;

 // ZZ:UploadSpeedSense -->
    m_bDynUpEnabled = ini.GetBool( "USSEnabled", false);
    m_bDynUpUseMillisecondPingTolerance = ini.GetBool( "USSUseMillisecondPingTolerance", false);
    m_iDynUpPingTolerance = ini.GetInt( "USSPingTolerance", 500);
 m_iDynUpPingToleranceMilliseconds = ini.GetInt( "USSPingToleranceMilliseconds", 200);
 if( minupload < 1 )
  minupload = 1;
 m_iDynUpGoingUpDivider = ini.GetInt( "USSGoingUpDivider", 1000);
    m_iDynUpGoingDownDivider = ini.GetInt( "USSGoingDownDivider", 1000);
    m_iDynUpNumberOfPings = ini.GetInt( "USSNumberOfPings", 1);
 // ZZ:UploadSpeedSense <--

    m_bA4AFSaveCpu = ini.GetBool( "A4AFSaveCpu", false); // ZZ:DownloadManager
    m_bHighresTimer = ini.GetBool( "HighresTimer", false);
 m_bRunAsUser = ini.GetBool( "RunAsUnprivilegedUser", false);
 m_bPreferRestrictedOverUser = ini.GetBool( "PreferRestrictedOverUser", false);
 m_bOpenPortsOnStartUp = ini.GetBool( "OpenPortsOnStartUp", false);
 m_byLogLevel = ini.GetInt( "DebugLogLevel", DLP_VERYLOW);
 m_bTrustEveryHash = ini.GetBool( "AICHTrustEveryHash", false);
 m_bRememberCancelledFiles = ini.GetBool( "RememberCancelledFiles", true);
 m_bRememberDownloadedFiles = ini.GetBool( "RememberDownloadedFiles", true);

 m_bNotifierSendMail = ini.GetBool( "NotifierSendMail", false);

 if (!IsRunningXPSP2OrHigher())
  m_bNotifierSendMail = false;

 m_strNotifierMailSender = ini.GetString( "NotifierMailSender",  "");
 m_strNotifierMailServer = ini.GetString( "NotifierMailServer",  "");
 m_strNotifierMailReceiver = ini.GetString( "NotifierMailRecipient",  "");

 m_bWinaTransToolbar = ini.GetBool( "WinaTransToolbar", true);

 m_bCryptLayerRequested = ini.GetBool( "CryptLayerRequested", false);
 m_bCryptLayerRequired = ini.GetBool( "CryptLayerRequired", false);
 m_bCryptLayerSupported = ini.GetBool( "CryptLayerSupported", true);
 m_dwKadUDPKey = ini.GetInt( "KadUDPKey", GetRandomUInt32());
 m_byCryptTCPPaddingLength = (uint8)ini.GetInt( "CryptTCPPaddingLength", 128);

 m_bEnableSearchResultFilter = ini.GetBool( "EnableSearchResultSpamFilter", true);

 ///////////////////////////////////////////////////////////////////////////
 // Section: "Proxy"
 //
 proxy.EnablePassword = ini.GetBool( "ProxyEnablePassword",false, "Proxy");
 proxy.UseProxy = ini.GetBool( "ProxyEnableProxy",false, "Proxy");
 proxy.name = CStringA(ini.GetString( "ProxyName",  "",  "Proxy"));
 proxy.user = CStringA(ini.GetString( "ProxyUser",  "",  "Proxy"));
 proxy.password = CStringA(ini.GetString( "ProxyPassword",  "",  "Proxy"));
 proxy.port = (uint16)ini.GetInt( "ProxyPort",1080, "Proxy");
 proxy.type = (uint16)ini.GetInt( "ProxyType",PROXYTYPE_NOPROXY, "Proxy");


 ///////////////////////////////////////////////////////////////////////////
 // Section: "Statistics"
 //
 statsSaveInterval = ini.GetInt( "SaveInterval", 60,  "Statistics");
 statsConnectionsGraphRatio = ini.GetInt( "statsConnectionsGraphRatio", 3,  "Statistics");
 m_strStatsExpandedTreeItems = ini.GetString( "statsExpandedTreeItems", "111000000100000110000010000011110000010010", "Statistics");
 CString buffer2;
 for (int i = 0; i < _countof(m_adwStatsColors); i++) {
  buffer2.Format( "StatColor%i", i);
  m_adwStatsColors[i] = 0;
  if (_stscanf(ini.GetString(buffer2,  "",  "Statistics"),  "%i", &m_adwStatsColors[i]) != 1)
   ResetStatsColor(i);
 }
 m_bShowVerticalHourMarkers = ini.GetBool( "ShowVerticalHourMarkers", true,  "Statistics");

 // -khaos--+++> Load Stats
 // I changed this to a seperate function because it is now also used
 // to load the stats backup and to load stats from preferences.ini.old.
 LoadStats();
 // <-----khaos-

 ///////////////////////////////////////////////////////////////////////////
 // Section: "WebServer"
 //
 m_strWebPassword = ini.GetString( "Password",  "",  "WebServer");
 m_strWebLowPassword = ini.GetString( "PasswordLow",  "");
 m_nWebPort=(uint16)ini.GetInt( "Port", 4711);
 m_bWebEnabled=ini.GetBool( "Enabled", false);
 m_bWebUseGzip=ini.GetBool( "UseGzip", true);
 m_bWebLowEnabled=ini.GetBool( "UseLowRightsUser", false);
 m_nWebPageRefresh=ini.GetInt( "PageRefreshTime", 120);
 m_iWebTimeoutMins=ini.GetInt( "WebTimeoutMins", 5 );
 m_iWebFileUploadSizeLimitMB=ini.GetInt( "MaxFileUploadSizeMB", 5 );
 m_bAllowAdminHiLevFunc=ini.GetBool( "AllowAdminHiLevelFunc", false);
 buffer2 = ini.GetString( "AllowedIPs");
 int iPos = 0;
 CString strIP = buffer2.Tokenize( ";", iPos);
 while (!strIP.IsEmpty())
 {
  u_long nIP = inet_addr(CStringA(strIP));
  if (nIP != INADDR_ANY && nIP != INADDR_NONE)
   m_aAllowedRemoteAccessIPs.Add(nIP);
  strIP = buffer2.Tokenize( ";", iPos);
 }

 ///////////////////////////////////////////////////////////////////////////
 // Section: "MobileMule"
 //
 m_strMMPassword = ini.GetString( "Password",  "",  "MobileMule");
 m_bMMEnabled = ini.GetBool( "Enabled", false);
 m_nMMPort = (uint16)ini.GetInt( "Port", 80);

 ///////////////////////////////////////////////////////////////////////////
 // Section: "PeerCache"
 //
 m_uPeerCacheLastSearch = ini.GetInt( "LastSearch", 0,  "PeerCache");
 m_bPeerCacheWasFound = ini.GetBool( "Found", false);
 m_bPeerCacheEnabled = ini.GetBool( "EnabledDeprecated", false);
 m_nPeerCachePort = (uint16)ini.GetInt( "PCPort", 0);
 m_bPeerCacheShow = ini.GetBool( "Show", false);

 ///////////////////////////////////////////////////////////////////////////
 // Section: "UPnP"
 //
 m_bEnableUPnP = ini.GetBool( "EnableUPnP", false,  "UPnP");
 m_bSkipWANIPSetup = ini.GetBool( "SkipWANIPSetup", false);
 m_bSkipWANPPPSetup = ini.GetBool( "SkipWANPPPSetup", false);
 m_bCloseUPnPOnExit = ini.GetBool( "CloseUPnPOnExit", true);
 m_nLastWorkingImpl = ini.GetInt( "LastWorkingImplementation", 1 /*MiniUPnPLib*/);
 m_bIsMinilibImplDisabled = ini.GetBool( "DisableMiniUPNPLibImpl", false);
 m_bIsWinServImplDisabled = ini.GetBool( "DisableWinServImpl", false);

 LoadCats();
 SetLanguage();
}


unsigned short CPreferences::GetWindowsVersion(){
 static bool bWinVerAlreadyDetected = false;
 if(!bWinVerAlreadyDetected)
 {
  bWinVerAlreadyDetected = true;
  m_wWinVer = DetectWinVersion();
 }
 return m_wWinVer;
}

unsigned int CPreferences::GetDefaultMaxConperFive(){
 switch (GetWindowsVersion()){
  case _WINVER_98_:
   return 5;
  case _WINVER_95_:
  case _WINVER_ME_:
   return MAXCON5WIN9X;
  case _WINVER_2K_:
  case _WINVER_XP_:
   return MAXCONPER5SEC;
  default:
   return MAXCONPER5SEC;
 }
}

//////////////////////////////////////////////////////////
// category implementations
//////////////////////////////////////////////////////////

void CPreferences::SaveCats()
{
 CString strCatIniFilePath;
 strCatIniFilePath.Format( "%sCategory.ini", GetMuleDirectory(EMULE_CONFIGDIR));
 (void)_tremove(strCatIniFilePath);
 CIni ini(strCatIniFilePath);
 ini.WriteInt( "Count", catMap.GetCount() - 1,  "General");
 for (int i = 0; i < catMap.GetCount(); i++)
 {
  CString strSection;
  strSection.Format( "Cat#%i", i);
  ini.SetSection(strSection);

  ini.WriteStringUTF8( "Title", catMap.GetAt(i)->strTitle);
  ini.WriteStringUTF8( "Incoming", catMap.GetAt(i)->strIncomingPath);
  ini.WriteStringUTF8( "Comment", catMap.GetAt(i)->strComment);
  ini.WriteStringUTF8( "RegularExpression", catMap.GetAt(i)->regexp);
  ini.WriteInt( "Color", catMap.GetAt(i)->color);
  ini.WriteInt( "a4afPriority", catMap.GetAt(i)->prio); // ZZ:DownloadManager
  ini.WriteStringUTF8( "AutoCat", catMap.GetAt(i)->autocat);
  ini.WriteInt( "Filter", catMap.GetAt(i)->filter);
  ini.WriteBool( "FilterNegator", catMap.GetAt(i)->filterNeg);
  ini.WriteBool( "AutoCatAsRegularExpression", catMap.GetAt(i)->ac_regexpeval);
        ini.WriteBool( "downloadInAlphabeticalOrder", catMap.GetAt(i)->downloadInAlphabeticalOrder!=FALSE);
  ini.WriteBool( "Care4All", catMap.GetAt(i)->care4all);
 }
}

void CPreferences::LoadCats()
{
 CString strCatIniFilePath;
 strCatIniFilePath.Format( "%sCategory.ini", GetMuleDirectory(EMULE_CONFIGDIR));
 CIni ini(strCatIniFilePath);
 int iNumCategories = ini.GetInt( "Count", 0,  "General");
 for (int i = 0; i <= iNumCategories; i++)
 {
  CString strSection;
  strSection.Format( "Cat#%i", i);
  ini.SetSection(strSection);

  Category_Struct* newcat = new       Category_Struct;
  newcat->filter = 0;
  newcat->strTitle = ini.GetStringUTF8( "Title");
  newcat->strIncomingPath = ini.GetStringUTF8( "Incoming");
  MakeFoldername(newcat->strIncomingPath);
  if (!IsShareableDirectory(newcat->strIncomingPath)
   || (!PathFileExists(newcat->strIncomingPath) && !::CreateDirectory(newcat->strIncomingPath, 0)))
  {
   newcat->strIncomingPath = GetMuleDirectory(EMULE_INCOMINGDIR);
   MakeFoldername(newcat->strIncomingPath);
  }
  newcat->strComment = ini.GetStringUTF8( "Comment");
  newcat->prio = ini.GetInt( "a4afPriority", PR_NORMAL); // ZZ:DownloadManager
  newcat->filter = ini.GetInt( "Filter", 0);
  newcat->filterNeg = ini.GetBool( "FilterNegator", FALSE);
  newcat->ac_regexpeval = ini.GetBool( "AutoCatAsRegularExpression", FALSE);
  newcat->care4all = ini.GetBool( "Care4All", FALSE);
  newcat->regexp = ini.GetStringUTF8( "RegularExpression");
  newcat->autocat = ini.GetStringUTF8( "Autocat");
        newcat->downloadInAlphabeticalOrder = ini.GetBool( "downloadInAlphabeticalOrder", FALSE); // ZZ:DownloadManager
  newcat->color = ini.GetInt( "Color", (unsigned long)-1 );
  AddCat(newcat);
 }
}

void CPreferences::RemoveCat(int index)
{
 if (index >= 0 && index < catMap.GetCount())
 {
  Category_Struct* delcat = catMap.GetAt(index);
  catMap.RemoveAt(index);
  delete delcat;
 }
}

bool CPreferences::SetCatFilter(int index, int filter)
{
 if (index >= 0 && index < catMap.GetCount())
 {
  catMap.GetAt(index)->filter = filter;
  return true;
 }
 return false;
}

int CPreferences::GetCatFilter(int index)
{
 if (index >= 0 && index < catMap.GetCount())
  return catMap.GetAt(index)->filter;
    return 0;
}

bool CPreferences::GetCatFilterNeg(int index)
{
 if (index >= 0 && index < catMap.GetCount())
  return catMap.GetAt(index)->filterNeg;
    return false;
}

void CPreferences::SetCatFilterNeg(int index, bool val)
{
 if (index >= 0 && index < catMap.GetCount())
  catMap.GetAt(index)->filterNeg = val;
}

bool CPreferences::MoveCat(unsigned int from, unsigned int to)
{
 if (from >= (unsigned int)catMap.GetCount() || to >= (unsigned int)catMap.GetCount() + 1 || from == to)
  return false;

 Category_Struct* tomove = catMap.GetAt(from);
 if (from < to) {
  catMap.RemoveAt(from);
  catMap.InsertAt(to - 1, tomove);
 } else {
  catMap.InsertAt(to, tomove);
  catMap.RemoveAt(from + 1);
 }
 SaveCats();
 return true;
}


unsigned long CPreferences::GetCatColor(int index) {
 if (index>=0 && index<catMap.GetCount()) {
  unsigned long c=catMap.GetAt(index)->color;
  if (c!=(unsigned long)-1)
   return catMap.GetAt(index)->color;
 }

 return GetSysColor(COLOR_BTNTEXT);
}


///////////////////////////////////////////////////////

bool CPreferences::IsInstallationDirectory(const CString& rstrDir)
{
 CString strFullPath;
 if (PathCanonicalize(strFullPath.GetBuffer(MAX_PATH), rstrDir))
  strFullPath.ReleaseBuffer();
 else
  strFullPath = rstrDir;

 // skip sharing of several special eMule folders
 if (!CompareDirectories(strFullPath, GetMuleDirectory(EMULE_EXECUTEABLEDIR)))
  return true;
 if (!CompareDirectories(strFullPath, GetMuleDirectory(EMULE_CONFIGDIR)))
  return true;
 if (!CompareDirectories(strFullPath, GetMuleDirectory(EMULE_WEBSERVERDIR)))
  return true;
 if (!CompareDirectories(strFullPath, GetMuleDirectory(EMULE_INSTLANGDIR)))
  return true;

 return false;
}

bool CPreferences::IsShareableDirectory(const CString& rstrDir)
{
 if (IsInstallationDirectory(rstrDir))
  return false;

 CString strFullPath;
 if (PathCanonicalize(strFullPath.GetBuffer(MAX_PATH), rstrDir))
  strFullPath.ReleaseBuffer();
 else
  strFullPath = rstrDir;

 // skip sharing of several special eMule folders
 for (int i=0;i<GetTempDirCount();i++)
  if (!CompareDirectories(strFullPath, GetTempDir(i)))   // ".\eMule\temp"
   return false;

 return true;
}

void CPreferences::UpdateLastVC()
{
        tm tmTemp;
 versioncheckLastAutomatic = safe_mktime(CTime::GetCurrentTime().GetLocalTm(&tmTemp));
}

void CPreferences::SetWSPass(CString strNewPass)
{
 m_strWebPassword = MD5Sum(strNewPass).GetHash();
}

void CPreferences::SetWSLowPass(CString strNewPass)
{
 m_strWebLowPassword = MD5Sum(strNewPass).GetHash();
}

void CPreferences::SetMMPass(CString strNewPass)
{
 m_strMMPassword = MD5Sum(strNewPass).GetHash();
}

void CPreferences::SetMaxUpload(unsigned int in)
{
 uint16 oldMaxUpload = (uint16)in;
 maxupload = (oldMaxUpload) ? oldMaxUpload : (uint16)UNLIMITED;
}

void CPreferences::SetMaxDownload(unsigned int in)
{
 uint16 oldMaxDownload = (uint16)in;
 maxdownload = (oldMaxDownload) ? oldMaxDownload : (uint16)UNLIMITED;
}

void CPreferences::SetNetworkKademlia(bool val)
{
 networkkademlia = val;
}

CString CPreferences::GetHomepageBaseURLForLevel(int nLevel){
 CString tmp;
 if (nLevel == 0)
  tmp =  "http://emule-project.net";
 else if (nLevel == 1)
  tmp =  "http://www.emule-project.org";
 else if (nLevel == 2)
  tmp =  "http://www.emule-project.com";
 else if (nLevel < 100)
  tmp.Format( "http://www%i.emule-project.net",nLevel-2);
 else if (nLevel < 150)
  tmp.Format( "http://www%i.emule-project.org",nLevel);
 else if (nLevel < 200)
  tmp.Format( "http://www%i.emule-project.com",nLevel);
 else if (nLevel == 200)
  tmp =  "http://emule.sf.net";
 else if (nLevel == 201)
  tmp =  "http://www.emuleproject.net";
 else if (nLevel == 202)
  tmp =  "http://sourceforge.net/projects/emule/";
 else
  tmp =  "http://www.emule-project.net";
 return tmp;
}

CString CPreferences::GetVersionCheckBaseURL(){
 CString tmp;
 unsigned int nWebMirrorAlertLevel = GetWebMirrorAlertLevel();
 if (nWebMirrorAlertLevel < 100)
  tmp =  "http://vcheck.emule-project.net";
 else if (nWebMirrorAlertLevel < 150)
  tmp.Format( "http://vcheck%i.emule-project.org",nWebMirrorAlertLevel);
 else if (nWebMirrorAlertLevel < 200)
  tmp.Format( "http://vcheck%i.emule-project.com",nWebMirrorAlertLevel);
 else if (nWebMirrorAlertLevel == 200)
  tmp =  "http://emule.sf.net";
 else if (nWebMirrorAlertLevel == 201)
  tmp =  "http://www.emuleproject.net";
 else
  tmp =  "http://vcheck.emule-project.net";
 return tmp;
}

bool CPreferences::IsDefaultNick(const CString strCheck){
 // not fast, but this function is called often
 for (int i = 0; i != 255; i++){
  if (GetHomepageBaseURLForLevel(i) == strCheck)
   return true;
 }
 return ( strCheck ==  "http://emule-project.net" );
}

void CPreferences::SetUserNick(const char* pszNick)
{
 strNick = pszNick;
}

unsigned int CPreferences::GetWebMirrorAlertLevel(){
 // Known upcoming DDoS Attacks
 if (m_nWebMirrorAlertLevel == 0){
  // no threats known at this time
 }
 // end
 if (UpdateNotify())
  return m_nWebMirrorAlertLevel;
 else
  return 0;
}

bool CPreferences::IsRunAsUserEnabled(){
 return (GetWindowsVersion() == _WINVER_XP_ || GetWindowsVersion() == _WINVER_2K_ || GetWindowsVersion() == _WINVER_2003_)
  && m_bRunAsUser
  && m_nCurrentUserDirMode == 2;
}

bool CPreferences::GetUseReBarToolbar()
{
 return GetReBarToolbar() && theApp.m_ullComCtrlVer >= MAKEDLLVERULL(5,8,0,0);
}

int CPreferences::GetMaxGraphUploadRate(bool bEstimateIfUnlimited){
 if (maxGraphUploadRate != UNLIMITED || !bEstimateIfUnlimited){
  return maxGraphUploadRate;
 }
 else{
  if (maxGraphUploadRateEstimated != 0){
   return maxGraphUploadRateEstimated +4;
  }
  else
   return 16;
 }
}

void CPreferences::EstimateMaxUploadCap(uint32 nCurrentUpload){
 if (maxGraphUploadRateEstimated+1 < nCurrentUpload){
  maxGraphUploadRateEstimated = nCurrentUpload;
  if (maxGraphUploadRate == UNLIMITED && theApp.emuledlg && theApp.emuledlg->statisticswnd)
   theApp.emuledlg->statisticswnd->SetARange(false, thePrefs.GetMaxGraphUploadRate(true));
 }
}

void CPreferences::SetMaxGraphUploadRate(int in){
 maxGraphUploadRate =(in) ? in : UNLIMITED;
}

bool CPreferences::IsDynUpEnabled() {
 return m_bDynUpEnabled || maxGraphUploadRate == UNLIMITED;
}

bool CPreferences::CanFSHandleLargeFiles() {
 bool bResult = false;
 for (int i = 0; i != tempdir.GetCount(); i++){
  if (!IsFileOnFATVolume(tempdir.GetAt(i))){
   bResult = true;
   break;
  }
 }
 return bResult && !IsFileOnFATVolume(GetMuleDirectory(EMULE_INCOMINGDIR));
}

uint16 CPreferences::GetRandomTCPPort()
{
 // Get table of currently used     ports.
 PMIB_TCPTABLE pTCPTab = NULL;
 // Couple of crash dmp files are showing that we may crash somewhere in 'iphlpapi.dll' when doing the 2nd call
 try   {
  void *  hIpHlpDll = LoadLibrary(_T("iphlpapi.dll"));
  if (hIpHlpDll)
  {
   unsigned long (       *pfnGetTcpTable)(PMIB_TCPTABLE, PDWORD, int );
   (FARPROC&)pfnGetTcpTable = GetProcAddress(hIpHlpDll, "GetTcpTable");
   if (pfnGetTcpTable)
   {
    unsigned long dwSize = 0;
    if ((*pfnGetTcpTable)(NULL, &dwSize, FALSE) == ERROR_INSUFFICIENT_BUFFER)
    {
     // The nr. of     entries could between
     // the two function calls, allocate some more memory.
     dwSize += sizeof(pTCPTab->table[0]) * 50;
     pTCPTab = (PMIB_TCPTABLE)malloc(dwSize);
     if (pTCPTab)
     {
      if ((*pfnGetTcpTable)(pTCPTab, &dwSize, TRUE) != ERROR_SUCCESS)
      {
       free(pTCPTab);
       pTCPTab = NULL;
      }
     }
    }
   }
   FreeLibrary(hIpHlpDll);
  }
 }
 catch(Exception __except){
  free(pTCPTab);
  pTCPTab = NULL;
 }

 const unsigned int uValidPortRange = 61000;
 int iMaxTests = uValidPortRange; // just in case, avoid endless loop
 uint16 nPort;
 bool bPortIsFree;
 do {
  // Get random port
  nPort = 4096 + (GetRandomUInt16() % uValidPortRange);

  // The port is by default assumed to be available. If we got a table of currently
  // used     ports, we verify that this port is currently not used in any way.
  bPortIsFree = true;
  if (pTCPTab)
  {
   uint16 nPortBE = htons(nPort);
   for (unsigned int e = 0; e < pTCPTab->dwNumEntries; e++)
   {
    // If there is a     entry in the table (regardless of its state), the port
    // is treated as not available.
    if (pTCPTab->table[e].dwLocalPort == nPortBE)
    {
     bPortIsFree = false;
     break;
    }
   }
  }
 }
 while (!bPortIsFree && --iMaxTests > 0);
 free(pTCPTab);
 return nPort;
}

uint16 CPreferences::GetRandomUDPPort()
{
 // Get table of currently used     ports.
 PMIB_UDPTABLE pUDPTab = NULL;
 // Couple of crash dmp files are showing that we may crash somewhere in 'iphlpapi.dll' when doing the 2nd call
 try   {
  void *  hIpHlpDll = LoadLibrary(_T("iphlpapi.dll"));
  if (hIpHlpDll)
  {
   unsigned long (       *pfnGetUdpTable)(PMIB_UDPTABLE, PDWORD, int );
   (FARPROC&)pfnGetUdpTable = GetProcAddress(hIpHlpDll, "GetUdpTable");
   if (pfnGetUdpTable)
   {
    unsigned long dwSize = 0;
    if ((*pfnGetUdpTable)(NULL, &dwSize, FALSE) == ERROR_INSUFFICIENT_BUFFER)
    {
     // The nr. of     entries could between
     // the two function calls, allocate some more memory.
     dwSize += sizeof(pUDPTab->table[0]) * 50;
     pUDPTab = (PMIB_UDPTABLE)malloc(dwSize);
     if (pUDPTab)
     {
      if ((*pfnGetUdpTable)(pUDPTab, &dwSize, TRUE) != ERROR_SUCCESS)
      {
       free(pUDPTab);
       pUDPTab = NULL;
      }
     }
    }
   }
   FreeLibrary(hIpHlpDll);
  }
 }
 catch(Exception __except){
  free(pUDPTab);
  pUDPTab = NULL;
 }

 const unsigned int uValidPortRange = 61000;
 int iMaxTests = uValidPortRange; // just in case, avoid endless loop
 uint16 nPort;
 bool bPortIsFree;
 do {
  // Get random port
  nPort = 4096 + (GetRandomUInt16() % uValidPortRange);

  // The port is by default assumed to be available. If we got a table of currently
  // used     ports, we verify that this port is currently not used in any way.
  bPortIsFree = true;
  if (pUDPTab)
  {
   uint16 nPortBE = htons(nPort);
   for (unsigned int e = 0; e < pUDPTab->dwNumEntries; e++)
   {
    if (pUDPTab->table[e].dwLocalPort == nPortBE)
    {
     bPortIsFree = false;
     break;
    }
   }
  }
 }
 while (!bPortIsFree && --iMaxTests > 0);
 free(pUDPTab);
 return nPort;
}
// General behavior:
// WinVer = 95/NT4
// Default: ApplicationDir
// Default _not_ overwritten by Registry value
//
// WinVer < Vista && WinVer > Win95:
// Default: ApplicationDir if preference.ini exists there. If not: user specific dirs if preferences.ini exits there. If not: again ApplicationDir
// Default overwritten by Registry value (see below)
// Fallback: ApplicationDir
//
// WinVer >= Vista:
// Default: User specific Dir if preferences.ini exists there. If not: All users dir, if preferences.ini exists there. If not user specific dirs again
// Default overwritten by Registry value (see below)
// Fallback: ApplicationDir
CString CPreferences::GetDefaultDirectory(EDefaultDirectory eDirectory, bool bCreate){

 if (m_astrDefaultDirs[0].IsEmpty()){ // already have all directories fetched and stored?

  // Get out exectuable starting directory which was our default till Vista
  char  tchBuffer[490];
  ::GetModuleFileName(0,tchBuffer, 490);
  char * pszFileName = _tcsrchr(tchBuffer,  '\\') + 1;
  *pszFileName =  '\0';
  m_astrDefaultDirs[EMULE_EXECUTEABLEDIR] = tchBuffer;

  // set our results to old default / fallback values
  // those 3 dirs are the base for all others
  CString strSelectedDataBaseDirectory = m_astrDefaultDirs[EMULE_EXECUTEABLEDIR];
  CString strSelectedConfigBaseDirectory = m_astrDefaultDirs[EMULE_EXECUTEABLEDIR];
  CString strSelectedExpansionBaseDirectory = m_astrDefaultDirs[EMULE_EXECUTEABLEDIR];
  m_nCurrentUserDirMode = 2; // To let us know which "mode" we are using in case we want to switch per options

  // For Win95, 98 and    we only support our old defaults due to missing
  if (GetWindowsVersion() != _WINVER_95_ && GetWindowsVersion() != _WINVER_NT4_){
   // check if preferences.ini exists already in our default / fallback dir
   CFileFind ff;
   bool bConfigAvailableExecuteable = ff.FindFile(strSelectedConfigBaseDirectory + CONFIGFOLDER + _T("preferences.ini"), 0) != 0;
   ff.Close();

   // check if our registry setting is present which forces the single or multiuser directories
   // and lets us ignore other defaults
   // 0 = Multiuser, 1 = Publicuser, 2 = ExecuteableDir. (on Winver < Vista 1 has the same effect as 2)
   unsigned long nRegistrySetting = (unsigned long)-1;
   CRegKey rkEMuleRegKey;
   if (rkEMuleRegKey.Open(HKEY_CURRENT_USER, _T("Software\\eMule"), KEY_READ) == ERROR_SUCCESS){
    rkEMuleRegKey.QueryDWORDValue(_T("UsePublicUserDirectories"), nRegistrySetting);
    rkEMuleRegKey.Close();
   }
   if (nRegistrySetting != -1 && nRegistrySetting != 0 && nRegistrySetting != 1 && nRegistrySetting != 2)
    nRegistrySetting = (unsigned long)-1;

   // Do we need to get SystemFolders or do we use our old Default anyway? (Executable Dir)
   if (nRegistrySetting == 0 || (nRegistrySetting == 1 && GetWindowsVersion() == _WINVER_VISTA_)
    || (nRegistrySetting == -1 && (!bConfigAvailableExecuteable || GetWindowsVersion() == _WINVER_VISTA_)))
   {
    void *  hShell32 = LoadLibrary(_T("shell32.dll"));
    if (hShell32){
     if (GetWindowsVersion() == _WINVER_VISTA_){

      PWSTR pszLocalAppData = NULL;
      PWSTR pszPersonalDownloads = NULL;
      PWSTR pszPublicDownloads = NULL;
      PWSTR pszProgrammData = NULL;

      // function not available on < WinVista
      unsigned long (       *pfnSHGetKnownFolderPath)(REFKNOWNFOLDERID, unsigned long, void *, PWSTR*);
      (FARPROC&)pfnSHGetKnownFolderPath = GetProcAddress(hShell32, "SHGetKnownFolderPath");

      if (pfnSHGetKnownFolderPath != NULL
       && (*pfnSHGetKnownFolderPath)(FOLDERID_LocalAppData, 0, NULL, &pszLocalAppData) == S_OK
       && (*pfnSHGetKnownFolderPath)(FOLDERID_Downloads, 0, NULL, &pszPersonalDownloads) == S_OK
       && (*pfnSHGetKnownFolderPath)(FOLDERID_PublicDownloads, 0, NULL, &pszPublicDownloads) == S_OK
       && (*pfnSHGetKnownFolderPath)(FOLDERID_ProgramData, 0, NULL, &pszProgrammData) == S_OK)
      {
       if (_tcsclen(pszLocalAppData) < MAX_PATH - 30 && _tcsclen(pszPersonalDownloads) < MAX_PATH - 40
        && _tcsclen(pszProgrammData) < MAX_PATH - 30 && _tcsclen(pszPublicDownloads) < MAX_PATH - 40)
       {
        CString strLocalAppData  = pszLocalAppData;
        CString strPersonalDownloads = pszPersonalDownloads;
        CString strPublicDownloads = pszPublicDownloads;
        CString strProgrammData = pszProgrammData;
        if (strLocalAppData.Right(1) != _T("\\"))
         strLocalAppData += _T("\\");
        if (strPersonalDownloads.Right(1) != _T("\\"))
         strPersonalDownloads += _T("\\");
        if (strPublicDownloads.Right(1) != _T("\\"))
         strPublicDownloads += _T("\\");
        if (strProgrammData.Right(1) != _T("\\"))
         strProgrammData += _T("\\");

        if (nRegistrySetting == -1){
         // no registry default, check if we find a preferences.ini to use
         bool bRes =  ff.FindFile(strLocalAppData + _T("eMule\\") + CONFIGFOLDER + _T("preferences.ini"), 0) != 0;
         ff.Close();
         if (bRes)
          m_nCurrentUserDirMode = 0;
         else{
          bRes =  ff.FindFile(strProgrammData + _T("eMule\\") + CONFIGFOLDER + _T("preferences.ini"), 0) != 0;
          ff.Close();
          if (bRes)
           m_nCurrentUserDirMode = 1;
          else if (bConfigAvailableExecuteable)
           m_nCurrentUserDirMode = 2;
          else
           m_nCurrentUserDirMode = 0; // no preferences.ini found, use the default
         }
        }
        else
         m_nCurrentUserDirMode = nRegistrySetting;

        if (m_nCurrentUserDirMode == 0){
         // multiuser
         strSelectedDataBaseDirectory = strPersonalDownloads + _T("eMule\\");
         strSelectedConfigBaseDirectory = strLocalAppData + _T("eMule\\");
         strSelectedExpansionBaseDirectory = strProgrammData + _T("eMule\\");
         m_nCurrentUserDirMode = 0;
        }
        else if (m_nCurrentUserDirMode == 1){
         //        user
         strSelectedDataBaseDirectory = strPublicDownloads + _T("eMule\\");
         strSelectedConfigBaseDirectory = strProgrammData + _T("eMule\\");
         strSelectedExpansionBaseDirectory = strProgrammData + _T("eMule\\");
         m_nCurrentUserDirMode = 1;
        }
        else if (m_nCurrentUserDirMode == 2){
         // programm directory
         m_nCurrentUserDirMode = 2;
        }
        else
         ASSERT( false );
       }
       else
        ASSERT( false );
       }

       CoTaskMemFree(pszLocalAppData);
       CoTaskMemFree(pszPersonalDownloads);
       CoTaskMemFree(pszPublicDownloads);
       CoTaskMemFree(pszProgrammData);
     }
     else { // GetWindowsVersion() == _WINVER_VISTA_

      // function not available on <
      long  wchAppData[MAX_PATH];
      long  wchPersonal[MAX_PATH];
      unsigned long (      * pfnSHGetFolderPathW)(void*, int, void *, unsigned long, long* );
      (FARPROC&)pfnSHGetFolderPathW = GetProcAddress(hShell32, "SHGetFolderPathW");
      if (pfnSHGetFolderPathW != NULL
       && (*pfnSHGetFolderPathW)(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, wchAppData) == S_OK
       && (*pfnSHGetFolderPathW)(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, wchPersonal) == S_OK)
      {
       if (_tcsclen(wchAppData) < MAX_PATH - 30 && _tcsclen(wchPersonal) < MAX_PATH - 40){
        CString strPersonal = wchPersonal;
        CString strAppData = wchAppData;
        if (strPersonal.Right(1) != _T("\\"))
         strPersonal += _T("\\");
        if (strAppData.Right(1) != _T("\\"))
         strAppData += _T("\\");
        if (nRegistrySetting == 0){
         // registry setting overwrites, use these folders
         strSelectedDataBaseDirectory = strPersonal + _T("eMule Downloads\\");
         strSelectedConfigBaseDirectory = strAppData + _T("eMule\\");
         m_nCurrentUserDirMode = 0;
         // strSelectedExpansionBaseDirectory stays default
        }
        else if (nRegistrySetting == -1 && !bConfigAvailableExecuteable){
         if (ff.FindFile(strAppData + _T("eMule\\") + CONFIGFOLDER + _T("preferences.ini"), 0)){
          // preferences.ini found, so we use this as default
          strSelectedDataBaseDirectory = strPersonal + _T("eMule Downloads\\");
          strSelectedConfigBaseDirectory = strAppData + _T("eMule\\");
          m_nCurrentUserDirMode = 0;
         }
         ff.Close();
        }
        else
         ASSERT( false );
       }
       else
        ASSERT( false );

      }
     }
     FreeLibrary(hShell32);
    }
    else{
     DebugLogError(_T("Unable to load shell32.dll to retrieve the systemfolder locations, using fallbacks"));
     ASSERT( false );
    }
   }
  }

  // the use of ending backslashes is inconsitent, would need a rework throughout the code to fix this
  m_astrDefaultDirs[EMULE_CONFIGDIR] = strSelectedConfigBaseDirectory + CONFIGFOLDER;
  m_astrDefaultDirs[EMULE_TEMPDIR] = strSelectedDataBaseDirectory + _T("Temp");
  m_astrDefaultDirs[EMULE_INCOMINGDIR] = strSelectedDataBaseDirectory + _T("Incoming");
  m_astrDefaultDirs[EMULE_LOGDIR] = strSelectedConfigBaseDirectory + _T("logs\\");
  m_astrDefaultDirs[EMULE_ADDLANGDIR] = strSelectedExpansionBaseDirectory + _T("lang\\");
  m_astrDefaultDirs[EMULE_INSTLANGDIR] = m_astrDefaultDirs[EMULE_EXECUTEABLEDIR] + _T("lang\\");
  m_astrDefaultDirs[EMULE_WEBSERVERDIR] = m_astrDefaultDirs[EMULE_EXECUTEABLEDIR] + _T("webserver\\");
  m_astrDefaultDirs[EMULE_SKINDIR] = strSelectedExpansionBaseDirectory + _T("skins");
  m_astrDefaultDirs[EMULE_DATABASEDIR] = strSelectedDataBaseDirectory; // has ending backslashes
  m_astrDefaultDirs[EMULE_CONFIGBASEDIR] = strSelectedConfigBaseDirectory; // has ending backslashes
  //                EMULE_EXECUTEABLEDIR
  m_astrDefaultDirs[EMULE_TOOLBARDIR] = strSelectedExpansionBaseDirectory + _T("skins");
  m_astrDefaultDirs[EMULE_EXPANSIONDIR] = strSelectedExpansionBaseDirectory; // has ending backslashes

  /*CString strDebug;
  for (int i = 0; i < 12; i++)
   strDebug += m_astrDefaultDirs[i] + _T("\n");
  AfxMessageBox(strDebug, MB_ICONINFORMATION);*/
 }
 if (bCreate && !m_abDefaultDirsCreated[eDirectory]){
  switch (eDirectory){ // create the underlying directory first - be sure to adjust this if changing default directories
   case EMULE_CONFIGDIR:
   case EMULE_LOGDIR:
    ::CreateDirectory(m_astrDefaultDirs[EMULE_CONFIGBASEDIR], NULL);
    break;
   case EMULE_TEMPDIR:
   case EMULE_INCOMINGDIR:
    ::CreateDirectory(m_astrDefaultDirs[EMULE_DATABASEDIR], NULL);
    break;
   case EMULE_ADDLANGDIR:
   case EMULE_SKINDIR:
   case EMULE_TOOLBARDIR:
    ::CreateDirectory(m_astrDefaultDirs[EMULE_EXPANSIONDIR], NULL);
    break;
  }
  ::CreateDirectory(m_astrDefaultDirs[eDirectory], NULL);
  m_abDefaultDirsCreated[eDirectory] = true;
 }
 return m_astrDefaultDirs[eDirectory];
}

CString CPreferences::GetMuleDirectory(EDefaultDirectory eDirectory, bool bCreate){
 switch (eDirectory){
  case EMULE_INCOMINGDIR:
   return m_strIncomingDir;
  case EMULE_TEMPDIR:
   ASSERT( false ); // use instead! This function can only return the first tempdirectory
   return GetTempDir(0);
  case EMULE_SKINDIR:
   return m_strSkinProfileDir;
  case EMULE_TOOLBARDIR:
   return m_sToolbarBitmapFolder;
  default:
   return GetDefaultDirectory(eDirectory, bCreate);
 }
}

void CPreferences::SetMuleDirectory(EDefaultDirectory eDirectory, CString strNewDir){
 switch (eDirectory){
  case EMULE_INCOMINGDIR:
   m_strIncomingDir = strNewDir;
   break;
  case EMULE_SKINDIR:
   m_strSkinProfileDir = strNewDir;
   break;
  case EMULE_TOOLBARDIR:
   m_sToolbarBitmapFolder = strNewDir;
   break;
  default:
   ASSERT( false );
 }
}

void CPreferences::ChangeUserDirMode(int nNewMode){
 if (m_nCurrentUserDirMode == nNewMode)
  return;
 if ((nNewMode == 1 && GetWindowsVersion() != _WINVER_VISTA_)
  || (nNewMode == 0 &&
  (GetWindowsVersion() == _WINVER_95_ || GetWindowsVersion() == _WINVER_NT4_)))
 {
  ASSERT( false );
  return;
 }
 // check if our registry setting is present which forces the single or multiuser directories
 // and lets us ignore other defaults
 // 0 = Multiuser, 1 = Publicuser, 2 = ExecuteableDir.
 CRegKey rkEMuleRegKey;
 if (rkEMuleRegKey.Create(HKEY_CURRENT_USER, _T("Software\\eMule")) == ERROR_SUCCESS){
  if (rkEMuleRegKey.SetDWORDValue(_T("UsePublicUserDirectories"), nNewMode) != ERROR_SUCCESS)
   DebugLogError(_T("Failed to write registry key to switch UserDirMode"));
  else
   m_nCurrentUserDirMode = nNewMode;
  rkEMuleRegKey.Close();
 }
}

bool CPreferences::GetSparsePartFiles() {
 // Vistas Sparse File implemenation seems to be buggy as     as i can see
 // If a sparsefile exceeds a given limit of write io operations in a certain order (or i.e. end to beginning)
 // in its lifetime, it will at some point throw out a                        error and deny any writing
 // to this file.
 // It was suggested that Vista might limits the dataruns, which would lead to such a behavior, but wouldn't
 // make much sense for a sparse file implementation nevertheless.
 // Due to the fact that eMule wirtes a lot small blocks into sparse files and flushs them every 6 seconds,
 // this problem pops up sooner or later for all big files. I don't see any way to walk arround this for now
 return m_bSparsePartFiles && (GetWindowsVersion() != _WINVER_VISTA_);
}

bool CPreferences::IsRunningAeroGlassTheme(){
 // This is important for all functions which need to draw in the NC-Area (glass style)
 // Aero by default does not allow this, any drawing will not be visible. This can be turned off,
 // but Vista will not deliver the Glass style then as background when calling the default draw function
 // in other words, its draw all or nothing yourself - eMule chooses currently nothing
 static bool bAeroAlreadyDetected = false;
 if (!bAeroAlreadyDetected){
  bAeroAlreadyDetected = true;
  m_bIsRunningAeroGlass = FALSE;
  if (GetWindowsVersion() == _WINVER_VISTA_){
   void *  hDWMAPI = LoadLibrary(_T("dwmapi.dll"));
   if (hDWMAPI){
    unsigned long (       *pfnDwmIsCompositionEnabled)(int *);
    (FARPROC&)pfnDwmIsCompositionEnabled = GetProcAddress(hDWMAPI, "DwmIsCompositionEnabled");
    if (pfnDwmIsCompositionEnabled != NULL)
     pfnDwmIsCompositionEnabled(&m_bIsRunningAeroGlass);
    FreeLibrary(hDWMAPI);
   }
  }
 }
 return m_bIsRunningAeroGlass == TRUE ? true : false;
}





 