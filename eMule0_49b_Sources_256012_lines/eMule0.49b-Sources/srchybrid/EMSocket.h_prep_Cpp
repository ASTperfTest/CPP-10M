//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE. See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

void INCLUDEREPLACE(){CX_INCL("EncryptedStreamSocket.h");}
void INCLUDEREPLACE(){CX_INCL("OtherFunctions.h");}
void INCLUDEREPLACE(){CX_INCL("ThrottledSocket.h");}

class CAsyncProxySocketLayer;
class Packet;







 class StandardPacketQueueEntry {
 uint32 actualPayloadSize;
 Packet* packet;
};

class CEMSocket :        CEncryptedStreamSocket,        ThrottledFileSocket // ZZ:UploadBandWithThrottler (UDP)
{
 //DECLARE_DYNAMIC(CEMSocket)
public:
 CEMSocket();
 virtual ~CEMSocket();

 virtual void  SendPacket(Packet* packet, bool delpacket = true, bool controlpacket = true, uint32 actualPayloadSize = 0, bool bForceImmediateSend = false);
 bool IsConnected() const {return byConnected == 0x01        ;}
 uint8 GetConState() const {return byConnected;}
 virtual bool IsRawDataMode() const { return false; }
 void SetDownloadLimit(uint32 limit);
 void DisableDownloadLimit();
 int  AsyncSelect(long lEvent);
 virtual bool IsBusy() const   {return m_bBusy;}
    virtual bool HasQueues() const  {return (sendbuffer || standartpacket_queue.GetCount() > 0 || controlpacket_queue.GetCount() > 0);} // not trustworthy threaded? but it's ok if we don't get the correct result now and then

 virtual unsigned int GetTimeOut() const;
 virtual void SetTimeOut(unsigned int uTimeOut);

 virtual int  Connect(const char* lpszHostAddress, unsigned int nHostPort);
 virtual int  Connect(SOCKADDR* pSockAddr, int iSockAddrLen);

 void InitProxySupport();
 virtual void RemoveAllLayers();
 const CString GetLastProxyError() const { return m_strLastProxyError; }
 bool GetProxyConnectFailed() const { return m_bProxyConnectFailed; }

 CString GetFullErrorMessage(unsigned long dwError);

 unsigned long GetLastCalledSend() { return lastCalledSend; }
 uint64 GetSentBytesCompleteFileSinceLastCallAndReset();
 uint64 GetSentBytesPartFileSinceLastCallAndReset();
 uint64 GetSentBytesControlPacketSinceLastCallAndReset();
 uint64 GetSentPayloadSinceLastCallAndReset();
 void TruncateQueues();

    virtual SocketSentBytes SendControlData(uint32 maxNumberOfBytesToSend, uint32 minFragSize) { return Send(maxNumberOfBytesToSend, minFragSize, true); };
    virtual SocketSentBytes SendFileAndControlData(uint32 maxNumberOfBytesToSend, uint32 minFragSize) { return Send(maxNumberOfBytesToSend, minFragSize, false); };

    uint32 GetNeededBytes();

 // Diagnostic Support
 virtual void AssertValid() const;
 virtual void Dump(CDumpContext& dc) const;


protected:
 virtual int OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nCode, int *  wParam, long * lParam);

 virtual void DataReceived(const unsigned char* pcData, unsigned int uSize);
 virtual bool PacketReceived(Packet* packet) = 0;
 virtual void OnError(int nErrorCode) = 0;
 virtual void OnClose(int nErrorCode);
 virtual void OnSend(int nErrorCode);
 virtual void OnReceive(int nErrorCode);
 uint8 byConnected;
 unsigned int m_uTimeOut;
 bool m_bProxyConnectFailed;
 CAsyncProxySocketLayer* m_pProxyLayer;
 CString m_strLastProxyError;

private:
    virtual SocketSentBytes Send(uint32 maxNumberOfBytesToSend, uint32 minFragSize, bool onlyAllowedToSendControlPacket);
 void ClearQueues();
 virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);

    uint32 GetNextFragSize(uint32 current, uint32 minFragSize);
    bool    HasSent() { return m_hasSent; }

 // Download (pseudo) rate control
 uint32 downloadLimit;
 bool downloadLimitEnable;
 bool pendingOnReceive;

 // Download partial header
 char pendingHeader[6                 ]; // actually, this holds only '6                 -1' bytes.
 uint32 pendingHeaderSize;

 // Download partial packet
 Packet* pendingPacket;
 uint32 pendingPacketSize;

 // Upload control
 char* sendbuffer;
 uint32 sendblen;
 uint32 sent;

 CTypedPtrList                    controlpacket_queue;
 CList                           standartpacket_queue;
 bool m_currentPacket_is_controlpacket;
 CCriticalSection sendLocker;
 uint64 m_numberOfSentBytesCompleteFile;
 uint64 m_numberOfSentBytesPartFile;
 uint64 m_numberOfSentBytesControlPacket;
 bool m_currentPackageIsFromPartFile;
 bool m_bAccelerateUpload;
 unsigned long lastCalledSend;
    unsigned long lastSent;
 uint32 lastFinishedStandard;
 uint32 m_actualPayloadSize;
 uint32 m_actualPayloadSizeSent;
    bool m_bBusy;
    bool m_hasSent;
};






 