/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */





void INCLUDEREPLACE(){CX_INCL("stdio.h");}
void INCLUDEREPLACE(){CX_INCL("errno.h");}

/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */









void INCLUDEREPLACE(){CX_INCL("stdlib.h");}

void INCLUDEREPLACE(){CX_INCL("unistd.h");}


/* Use prototypes in function declarations. */


/* The "const" storage-class-modifier is valid. */















void INCLUDEREPLACE(){CX_INCL("io.h");}
void INCLUDEREPLACE(){CX_INCL("stdlib.h");}


















/* Returned upon end-of-file. */


/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */


/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */


/* Translate the current start state into a value that can be later handed
 * to yy_start = 1 + 2 * to return to the state.  The         alias is for lex
 * compatibility.
 */



/* Action number for     rule of a given start state. */


/* Special action meaning "start processing a neW file". */




/* Size of default input buffer. */


               yy_buffer_state *YY_BUFFER_STATE = "CX_TYPEDEF";

extern int yyleng;
extern FILE *yyin, *yyout;





/* The funky do-while in the following #define is used to turn the definition
 * int a single   statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *  if ( condition_holds )
 *  yyless( 5 );
 * else
 *  do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */














/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
        unsigned int yy_size_t = "CX_TYPEDEF";


 class yy_buffer_state
 {
 FILE *yy_input_file;

 char *yy_ch_buf;  /* input buffer */
 char *yy_buf_pos;  /* current position in input buffer */

 /* Size of input buffer in bytes, not including room for EOB
  * characters.
  */
 yy_size_t yy_buf_size;

 /* Number of characters read into yy_ch_buf, not including EOB
  * characters.
  */
 int yy_n_chars;

 /* Whether we "own" the buffer - i.e., we know we created it,
  * and can it to grow it, and should it to
  * delete it.
  */
 int yy_is_our_buffer;

 /* Whether this is an "interactive" input source; if so, and
  * if we're using stdio for input, then we want to use getc()
  * instead of fread(), to make sure we stop fetching input after
  * each newline.
  */
 int yy_is_interactive;

 /* Whether we're considered to be at the beginning of a line.
  * If so, '^' rules will be active on the next match, otherwise
  * not.
  */
 int yy_at_bol;

 /* Whether to try to fill the input buffer when we reach the
  * end of it.
  */
 int yy_fill_buffer;

 int yy_buffer_status;


 /* When an EOF's been seen but there's still some text to process
  * then we mark the buffer as YY_EOF_PENDING, to indicate that we
  * shouldn't try reading from the input source any more.  We might
  * still have a bunch of tokens to match, though, because of
  * possible backing-up.
  *
  * When we actually see the EOF, we change the status to "neW"
  * (via yyrestart()), so that the user can continue scanning by
  * just pointing yyin at a neW input file.
  */

 };

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */



/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;  /* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart ( FILE *input_file )   ;

void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer )   ;
void yy_load_buffer_state ( void )   ;
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size )   ;
void yy_delete_buffer ( YY_BUFFER_STATE b )   ;
void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file )   ;
void yy_flush_buffer ( YY_BUFFER_STATE b )   ;


YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size )   ;
YY_BUFFER_STATE yy_scan_string ( const   char *yy_str )   ;
YY_BUFFER_STATE yy_scan_bytes ( const   char *bytes, int len )   ;

static void *yy_flex_alloc ( yy_size_t )   ;
static void *yy_flex_realloc ( void *, yy_size_t )   ;
static void yy_flex_free ( void * )   ;
























        unsigned char YY_CHAR = "CX_TYPEDEF";
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
        int yy_state_type = "CX_TYPEDEF";
extern char *yytext;


static yy_state_type yy_get_previous_state ( void )   ;
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state )   ;
static int yy_get_next_buffer ( void )   ;
static void yy_fatal_error ( const   char msg[] )   ;

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */









static const   short int yy_acclist[148] =
    {   0,
       20,   20,   20,   20,   24,   20,   22,   23,   20,   23,
        1,   22,   23,   21,   22,   23,   22,   23,   19,   20,
       22,   23,    6,   22,   23,   20,   22,   23,   20,   22,
       23,   20,   22,   23,   20,   22,   23,   20,   22,   23,
       23,   23,   13,   23,    8,   23,    6,   23,    7,   23,
       23,   14,   23,   18,   23,   21,   23,   23,   15,   23,
       20,    5,   20,   20,   20,    2,   20,   20,   13,   13,
       13,   13,   10,   11,    9,   14,   14,   14,   14,   18,
       15,   15,   15,   15,    3,   20,    4,   20,   20,   13,
       14,   16,   15,   20,   13,   14,   15,   20,   17,   20,

       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   12,   20,   12
    } ;

static const   short int yy_accept[173] =
    {   0,
        1,    2,    3,    3,    3,    3,    3,    3,    3,    4,
        5,    5,    5,    6,    9,   11,   14,   17,   19,   23,
       26,   29,   32,   35,   38,   41,   42,   43,   45,   47,
       49,   51,   52,   54,   56,   58,   59,   61,   62,   64,
       65,   66,   68,   69,   70,   71,   72,   72,   73,   74,
       75,   76,   77,   78,   79,   80,   80,   81,   82,   83,
       84,   84,   84,   85,   87,   89,   90,   90,   90,   91,
       91,   91,   92,   92,   93,   93,   94,   95,   95,   96,
       96,   97,   97,   98,   98,   99,  100,  101,  102,  103,
      104,  105,  106,  107,  108,  109,  109,  110,  110,  111,

      111,  112,  112,  113,  113,  114,  114,  115,  115,  116,
      116,  117,  117,  118,  118,  119,  119,  120,  120,  121,
      121,  122,  122,  123,  123,  124,  124,  125,  125,  126,
      126,  127,  127,  128,  128,  129,  129,  130,  130,  131,
      131,  132,  132,  133,  133,  134,  134,  135,  135,  136,
      136,  137,  137,  138,  138,  139,  139,  140,  140,  141,
      141,  142,  142,  143,  143,  144,  144,  145,  145,  147,
      148,  148
    } ;

static const   int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    1,    4,    1,    1,    1,    1,    1,    5,
        5,    1,    6,    1,    7,    8,    9,   10,   10,   11,
       10,   10,   10,   10,   10,   10,   10,   12,    1,   13,
       14,   15,    1,   16,   17,   18,   19,   20,   21,   19,
       22,   23,   23,   23,   22,   23,   22,   24,   25,   23,
       23,   26,   23,   27,   23,   23,   23,   23,   23,   23,
        1,    1,    1,    1,    1,    1,   28,   29,   28,   30,

       31,   32,   33,   34,   35,   36,   37,   38,   39,   36,
       36,   36,   36,   36,   34,   36,   36,   36,   36,   36,
       36,   36,    1,   40,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const   int yy_meta[41] =
    {   0,
        1,    1,    2,    2,    2,    1,    1,    1,    1,    3,
        3,    1,    2,    2,    2,    1,    4,    4,    4,    4,
        4,    5,    5,    5,    5,    5,    5,    4,    4,    4,
        4,    4,    5,    5,    5,    5,    5,    5,    5,    1
    } ;

static const   short int yy_base[211] =
    {   0,
        0,   30,   49,   57,   65,   73,   88,    0,    5,   25,
      121,  129,  204,    0,    0, 1221, 1221, 1221,    0, 1221,
      117,  177,  173,  167,  160, 1221,    1,  149,    7, 1221,
      171,   16,  181,    0, 1221,   31,  213,    0,    0,  163,
      154,    0,  167,  243,   27,    0,  155, 1221, 1221, 1221,
     1221,  163,   35,    0, 1221,  157,    0,  166,  148,    0,
       39,  220, 1221,    0,    0,  138,  222,   41,  206,  230,
      185,  238,  250,  196,  240,  252,  160,  255,  257,  260,
      262,  267,  273,  277,  149,  282,  132,   98,  101,   95,
       47,   51,   37,  310,  348,   34,  287,  289,  291,  293,

      379,    0,  402,    0,  425,    0,  448,    0,  471,    0,
      494,    0,  517,    0,  540,    0,  563,    0,  586,    0,
      609,    0,  632,    0,  655,    0,  678,    0,  701,    0,
      724,    0,  747,    0,  770,    0,  793,    0,  816,    0,
      839,    0,  862,    0,  885,    0,  908,    0,  931,    0,
      954,    0,  977,    0, 1000,    0, 1023,    0, 1046,    0,
     1069,    0, 1092,    0,   29,   13,   27,   14,    0, 1221,
     1221, 1124, 1129, 1134, 1139, 1141, 1146, 1151, 1154, 1156,
     1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176,
     1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196,

     1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, 1216
    } ;

static const   short int yy_def[211] =
    {   0,
      172,  172,  173,  173,  173,  173,  171,    7,  174,  174,
      173,  173,  171,  175,  175,  171,  171,  171,  175,  171,
      175,  175,  175,  175,  175,  171,  171,  171,  171,  171,
      171,  171,  171,  176,  171,  171,  171,  175,   21,  175,
      175,  175,  175,  171,   44,   28,  171,  171,  171,  171,
      171,   33,   52,   33,  171,  171,  176,  171,   58,   37,
      171,  171,  171,  175,  175,  175,  171,  171,  171,  171,
      171,   52,  171,  171,  171,  171,  175,  171,  171,  171,
       72,  171,  171,  171,  175,  171,  175,  175,  175,  175,
      175,  175,  175,  177,  177,  178,  175,  171,  175,  171,

      175,  179,  175,  180,  175,  181,  175,  182,  175,  183,
      175,  184,  175,  185,  175,  186,  175,  187,  175,  188,
      175,  189,  175,  190,  175,  191,  175,  192,  175,  193,
      175,  194,  175,  195,  175,  196,  175,  197,  175,  198,
      175,  199,  175,  200,  175,  201,  175,  202,  175,  203,
      175,  204,  175,  205,  175,  206,  175,  207,  175,  208,
      175,  209,  175,  210,  175,  171,  175,  171,  175,  171,
        0,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,

      171,  171,  171,  171,  171,  171,  171,  171,  171,  171
    } ;

static const   short int yy_nxt[1262] =
    {   0,
      171,   15,   16,   17,   18,  171,   19,   26,   35,   26,
       44,   44,   18,   20,   18,   21,   22,   26,   30,   26,
       49,   50,  170,   23,   24,   52,   52,   26,   35,   26,
       25,   15,   16,   17,   18,  169,   19,   26,   30,   26,
       58,   58,   18,   20,   18,   21,   22,   47,   74,   74,
       69,   69,  168,   23,   24,   56,   27,   47,   28,   28,
       25,   29,   30,   31,   27,   56,   28,   28,  167,   29,
       30,   31,   32,   98,   33,   33,   94,   29,   30,   31,
       32,   93,   33,   33,   92,   29,   30,   31,   26,   26,
       26,   26,   26,   26,   26,   26,   26,   26,   26,   26,

       26,   30,   26,   26,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   26,   36,   91,
       37,   37,   90,   29,   30,   31,   36,   89,   37,   37,
       88,   29,   30,   31,   39,   39,   39,   39,   39,   39,
       39,   39,   39,   39,   39,   39,   45,   87,   46,   46,
       68,   68,   71,   71,   69,   69,   72,   72,   62,   47,
      171,   85,   52,   52,   77,   58,   58,   66,   62,   47,
       65,   48,   64,   70,   51,   48,   73,   48,   53,   43,
       54,   54,   42,   70,   72,   72,   73,   41,   55,   63,

       40,   56,   55,  171,   63,   74,   74,   84,  171,   55,
      171,   56,  171,   55,  171,   69,   69,   55,  171,   55,
       59,  171,   60,   60,   61,   75,   75,   78,   78,   76,
       76,   79,   79,   62,  171,   80,   80,  171,   48,   81,
       81,  171,   48,   62,   48,  171,   63,   72,   72,   76,
       76,   63,   44,   44,  171,   82,   82,  171,  171,   83,
       83,   76,   76,   67,   79,   79,   79,   79,  171,   81,
       81,   81,   81,   67,  171,   48,   83,   83,  171,   48,
      171,   48,   83,   83,  171,   63,   86,   86,  171,   48,
       63,   86,   86,   48,  171,   48,   99,   99,  100,  100,

       99,   99,  100,  100,  171,  171,   63,  171,  171,  171,
      171,   63,   96,   96,   96,  171,  171,  171,  171,  171,
      171,  171,   96,   96,   96,  171,  171,  171,  171,  171,
      101,  171,  102,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,   38,
       96,   96,   96,  171,  171,  171,  171,  171,  171,  171,
       96,   96,   96,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,   97,  103,  103,
      171,  171,  171,  171,  171,  103,  103,  103,  103,  103,

      171,  171,  171,  171,  171,  171,  103,  103,  103,  103,
      103,  105,  105,  171,  171,  171,  171,  171,  105,  105,
      105,  105,  105,  171,  171,  171,  171,  171,  171,  105,
      105,  105,  105,  105,  107,  107,  171,  171,  171,  171,
      171,  107,  107,  107,  107,  107,  171,  171,  171,  171,
      171,  171,  107,  107,  107,  107,  107,  109,  109,  171,
      171,  171,  171,  171,  109,  109,  109,  109,  109,  171,
      171,  171,  171,  171,  171,  109,  109,  109,  109,  109,
      111,  111,  171,  171,  171,  171,  171,  111,  111,  111,
      111,  111,  171,  171,  171,  171,  171,  171,  111,  111,

      111,  111,  111,  113,  113,  171,  171,  171,  171,  171,
      113,  113,  113,  113,  113,  171,  171,  171,  171,  171,
      171,  113,  113,  113,  113,  113,  115,  115,  171,  171,
      171,  171,  171,  115,  115,  115,  115,  115,  171,  171,
      171,  171,  171,  171,  115,  115,  115,  115,  115,  117,
      117,  171,  171,  171,  171,  171,  117,  117,  117,  117,
      117,  171,  171,  171,  171,  171,  171,  117,  117,  117,
      117,  117,  119,  119,  171,  171,  171,  171,  171,  119,
      119,  119,  119,  119,  171,  171,  171,  171,  171,  171,
      119,  119,  119,  119,  119,  121,  121,  171,  171,  171,

      171,  171,  121,  121,  121,  121,  121,  171,  171,  171,
      171,  171,  171,  121,  121,  121,  121,  121,  123,  123,
      171,  171,  171,  171,  171,  123,  123,  123,  123,  123,
      171,  171,  171,  171,  171,  171,  123,  123,  123,  123,
      123,  125,  125,  171,  171,  171,  171,  171,  125,  125,
      125,  125,  125,  171,  171,  171,  171,  171,  171,  125,
      125,  125,  125,  125,  127,  127,  171,  171,  171,  171,
      171,  127,  127,  127,  127,  127,  171,  171,  171,  171,
      171,  171,  127,  127,  127,  127,  127,  129,  129,  171,
      171,  171,  171,  171,  129,  129,  129,  129,  129,  171,

      171,  171,  171,  171,  171,  129,  129,  129,  129,  129,
      131,  131,  171,  171,  171,  171,  171,  131,  131,  131,
      131,  131,  171,  171,  171,  171,  171,  171,  131,  131,
      131,  131,  131,  133,  133,  171,  171,  171,  171,  171,
      133,  133,  133,  133,  133,  171,  171,  171,  171,  171,
      171,  133,  133,  133,  133,  133,  135,  135,  171,  171,
      171,  171,  171,  135,  135,  135,  135,  135,  171,  171,
      171,  171,  171,  171,  135,  135,  135,  135,  135,  137,
      137,  171,  171,  171,  171,  171,  137,  137,  137,  137,
      137,  171,  171,  171,  171,  171,  171,  137,  137,  137,

      137,  137,  139,  139,  171,  171,  171,  171,  171,  139,
      139,  139,  139,  139,  171,  171,  171,  171,  171,  171,
      139,  139,  139,  139,  139,  141,  141,  171,  171,  171,
      171,  171,  141,  141,  141,  141,  141,  171,  171,  171,
      171,  171,  171,  141,  141,  141,  141,  141,  143,  143,
      171,  171,  171,  171,  171,  143,  143,  143,  143,  143,
      171,  171,  171,  171,  171,  171,  143,  143,  143,  143,
      143,  145,  145,  171,  171,  171,  171,  171,  145,  145,
      145,  145,  145,  171,  171,  171,  171,  171,  171,  145,
      145,  145,  145,  145,  147,  147,  171,  171,  171,  171,

      171,  147,  147,  147,  147,  147,  171,  171,  171,  171,
      171,  171,  147,  147,  147,  147,  147,  149,  149,  171,
      171,  171,  171,  171,  149,  149,  149,  149,  149,  171,
      171,  171,  171,  171,  171,  149,  149,  149,  149,  149,
      151,  151,  171,  171,  171,  171,  171,  151,  151,  151,
      151,  151,  171,  171,  171,  171,  171,  171,  151,  151,
      151,  151,  151,  153,  153,  171,  171,  171,  171,  171,
      153,  153,  153,  153,  153,  171,  171,  171,  171,  171,
      171,  153,  153,  153,  153,  153,  155,  155,  171,  171,
      171,  171,  171,  155,  155,  155,  155,  155,  171,  171,

      171,  171,  171,  171,  155,  155,  155,  155,  155,  157,
      157,  171,  171,  171,  171,  171,  157,  157,  157,  157,
      157,  171,  171,  171,  171,  171,  171,  157,  157,  157,
      157,  157,  159,  159,  171,  171,  171,  171,  171,  159,
      159,  159,  159,  159,  171,  171,  171,  171,  171,  171,
      159,  159,  159,  159,  159,  161,  161,  171,  171,  171,
      171,  171,  161,  161,  161,  161,  161,  171,  171,  171,
      171,  171,  171,  161,  161,  161,  161,  161,  163,  163,
      171,  171,  171,  171,  171,  163,  163,  163,  163,  163,
      171,  171,  171,  171,  171,  171,  163,  163,  163,  163,

      163,  165,  165,  171,  171,  171,  171,  171,  165,  165,
      165,  165,  165,  171,  171,  171,  171,  171,  171,  165,
      165,  165,  165,  165,   14,   14,   14,   14,   14,   26,
       26,   26,   26,   26,   15,   15,   15,   15,   15,   38,
      171,   38,   38,   38,   57,   57,   95,   95,   95,   95,
       95,   96,   96,   96,   96,   96,  104,  104,  106,  106,
      108,  108,  110,  110,  112,  112,  114,  114,  116,  116,
      118,  118,  120,  120,  122,  122,  124,  124,  126,  126,
      128,  128,  130,  130,  132,  132,  134,  134,  136,  136,
      138,  138,  140,  140,  142,  142,  144,  144,  146,  146,

      148,  148,  150,  150,  152,  152,  154,  154,  156,  156,
      158,  158,  160,  160,  162,  162,  164,  164,  166,  166,
       13,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171
    } ;

static const   short int yy_chk[1262] =
    {   0,
        0,    1,    1,    1,    1,    0,    1,    9,    9,    9,
       27,   27,    1,    1,    1,    1,    1,    9,    9,    9,
       29,   29,  168,    1,    1,   32,   32,   10,   10,   10,
        1,    2,    2,    2,    2,  167,    2,   10,   10,   10,
       36,   36,    2,    2,    2,    2,    2,   45,   61,   61,
       68,   68,  166,    2,    2,   53,    3,   45,    3,    3,
        2,    3,    3,    3,    4,   53,    4,    4,  165,    4,
        4,    4,    5,   96,    5,    5,   93,    5,    5,    5,
        6,   92,    6,    6,   91,    6,    6,    6,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,

        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,   11,   90,
       11,   11,   89,   11,   11,   11,   12,   88,   12,   12,
       87,   12,   12,   12,   21,   21,   21,   21,   21,   21,
       21,   21,   21,   21,   21,   21,   28,   85,   28,   28,
       47,   47,   56,   56,   47,   47,   56,   56,   59,   28,
       52,   77,   52,   52,   66,   58,   58,   43,   59,   28,
       41,   28,   40,   52,   31,   28,   58,   28,   33,   25,
       33,   33,   24,   52,   71,   71,   58,   23,   33,   58,

       22,   33,   33,   13,   58,   74,   74,   74,    0,   33,
        0,   33,    0,   33,    0,   69,   69,   33,    0,   33,
       37,    0,   37,   37,   37,   62,   62,   67,   67,   62,
       62,   67,   67,   37,    0,   70,   70,    0,   69,   70,
       70,    0,   69,   37,   69,    0,   37,   72,   72,   75,
       75,   37,   44,   44,    0,   73,   73,    0,   72,   73,
       73,   76,   76,   44,   78,   78,   79,   79,   72,   80,
       80,   81,   81,   44,    0,   44,   82,   82,    0,   44,
        0,   44,   83,   83,    0,   76,   84,   84,    0,   79,
       76,   86,   86,   79,    0,   79,   97,   97,   98,   98,

       99,   99,  100,  100,    0,    0,   83,    0,    0,    0,
        0,   83,   94,   94,   94,    0,    0,    0,    0,    0,
        0,    0,   94,   94,   94,    0,    0,    0,    0,    0,
       99,    0,  100,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   94,
       95,   95,   95,    0,    0,    0,    0,    0,    0,    0,
       95,   95,   95,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   95,  101,  101,
        0,    0,    0,    0,    0,  101,  101,  101,  101,  101,

        0,    0,    0,    0,    0,    0,  101,  101,  101,  101,
      101,  103,  103,    0,    0,    0,    0,    0,  103,  103,
      103,  103,  103,    0,    0,    0,    0,    0,    0,  103,
      103,  103,  103,  103,  105,  105,    0,    0,    0,    0,
        0,  105,  105,  105,  105,  105,    0,    0,    0,    0,
        0,    0,  105,  105,  105,  105,  105,  107,  107,    0,
        0,    0,    0,    0,  107,  107,  107,  107,  107,    0,
        0,    0,    0,    0,    0,  107,  107,  107,  107,  107,
      109,  109,    0,    0,    0,    0,    0,  109,  109,  109,
      109,  109,    0,    0,    0,    0,    0,    0,  109,  109,

      109,  109,  109,  111,  111,    0,    0,    0,    0,    0,
      111,  111,  111,  111,  111,    0,    0,    0,    0,    0,
        0,  111,  111,  111,  111,  111,  113,  113,    0,    0,
        0,    0,    0,  113,  113,  113,  113,  113,    0,    0,
        0,    0,    0,    0,  113,  113,  113,  113,  113,  115,
      115,    0,    0,    0,    0,    0,  115,  115,  115,  115,
      115,    0,    0,    0,    0,    0,    0,  115,  115,  115,
      115,  115,  117,  117,    0,    0,    0,    0,    0,  117,
      117,  117,  117,  117,    0,    0,    0,    0,    0,    0,
      117,  117,  117,  117,  117,  119,  119,    0,    0,    0,

        0,    0,  119,  119,  119,  119,  119,    0,    0,    0,
        0,    0,    0,  119,  119,  119,  119,  119,  121,  121,
        0,    0,    0,    0,    0,  121,  121,  121,  121,  121,
        0,    0,    0,    0,    0,    0,  121,  121,  121,  121,
      121,  123,  123,    0,    0,    0,    0,    0,  123,  123,
      123,  123,  123,    0,    0,    0,    0,    0,    0,  123,
      123,  123,  123,  123,  125,  125,    0,    0,    0,    0,
        0,  125,  125,  125,  125,  125,    0,    0,    0,    0,
        0,    0,  125,  125,  125,  125,  125,  127,  127,    0,
        0,    0,    0,    0,  127,  127,  127,  127,  127,    0,

        0,    0,    0,    0,    0,  127,  127,  127,  127,  127,
      129,  129,    0,    0,    0,    0,    0,  129,  129,  129,
      129,  129,    0,    0,    0,    0,    0,    0,  129,  129,
      129,  129,  129,  131,  131,    0,    0,    0,    0,    0,
      131,  131,  131,  131,  131,    0,    0,    0,    0,    0,
        0,  131,  131,  131,  131,  131,  133,  133,    0,    0,
        0,    0,    0,  133,  133,  133,  133,  133,    0,    0,
        0,    0,    0,    0,  133,  133,  133,  133,  133,  135,
      135,    0,    0,    0,    0,    0,  135,  135,  135,  135,
      135,    0,    0,    0,    0,    0,    0,  135,  135,  135,

      135,  135,  137,  137,    0,    0,    0,    0,    0,  137,
      137,  137,  137,  137,    0,    0,    0,    0,    0,    0,
      137,  137,  137,  137,  137,  139,  139,    0,    0,    0,
        0,    0,  139,  139,  139,  139,  139,    0,    0,    0,
        0,    0,    0,  139,  139,  139,  139,  139,  141,  141,
        0,    0,    0,    0,    0,  141,  141,  141,  141,  141,
        0,    0,    0,    0,    0,    0,  141,  141,  141,  141,
      141,  143,  143,    0,    0,    0,    0,    0,  143,  143,
      143,  143,  143,    0,    0,    0,    0,    0,    0,  143,
      143,  143,  143,  143,  145,  145,    0,    0,    0,    0,

        0,  145,  145,  145,  145,  145,    0,    0,    0,    0,
        0,    0,  145,  145,  145,  145,  145,  147,  147,    0,
        0,    0,    0,    0,  147,  147,  147,  147,  147,    0,
        0,    0,    0,    0,    0,  147,  147,  147,  147,  147,
      149,  149,    0,    0,    0,    0,    0,  149,  149,  149,
      149,  149,    0,    0,    0,    0,    0,    0,  149,  149,
      149,  149,  149,  151,  151,    0,    0,    0,    0,    0,
      151,  151,  151,  151,  151,    0,    0,    0,    0,    0,
        0,  151,  151,  151,  151,  151,  153,  153,    0,    0,
        0,    0,    0,  153,  153,  153,  153,  153,    0,    0,

        0,    0,    0,    0,  153,  153,  153,  153,  153,  155,
      155,    0,    0,    0,    0,    0,  155,  155,  155,  155,
      155,    0,    0,    0,    0,    0,    0,  155,  155,  155,
      155,  155,  157,  157,    0,    0,    0,    0,    0,  157,
      157,  157,  157,  157,    0,    0,    0,    0,    0,    0,
      157,  157,  157,  157,  157,  159,  159,    0,    0,    0,
        0,    0,  159,  159,  159,  159,  159,    0,    0,    0,
        0,    0,    0,  159,  159,  159,  159,  159,  161,  161,
        0,    0,    0,    0,    0,  161,  161,  161,  161,  161,
        0,    0,    0,    0,    0,    0,  161,  161,  161,  161,

      161,  163,  163,    0,    0,    0,    0,    0,  163,  163,
      163,  163,  163,    0,    0,    0,    0,    0,    0,  163,
      163,  163,  163,  163,  172,  172,  172,  172,  172,  173,
      173,  173,  173,  173,  174,  174,  174,  174,  174,  175,
        0,  175,  175,  175,  176,  176,  177,  177,  177,  177,
      177,  178,  178,  178,  178,  178,  179,  179,  180,  180,
      181,  181,  182,  182,  183,  183,  184,  184,  185,  185,
      186,  186,  187,  187,  188,  188,  189,  189,  190,  190,
      191,  191,  192,  192,  193,  193,  194,  194,  195,  195,
      196,  196,  197,  197,  198,  198,  199,  199,  200,  200,

      201,  201,  202,  202,  203,  203,  204,  204,  205,  205,
      206,  206,  207,  207,  208,  208,  209,  209,  210,  210,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171,  171,  171,  171,  171,  171,  171,  171,  171,  171,
      171
    } ;

static yy_state_type yy_state_buf[16384       + 2], *yy_state_ptr;
static char *yy_full_match;
static int yy_lp;










char *yytext;

void INCLUDEREPLACE(){CX_INCL("stdafx.h");}
void INCLUDEREPLACE(){CX_INCL("resource.h");}
void INCLUDEREPLACE(){CX_INCL("io.h");}
void INCLUDEREPLACE(){CX_INCL("OtherFunctions.h");}
void INCLUDEREPLACE(){CX_INCL("SearchExpr.h");}
void INCLUDEREPLACE(){CX_INCL("scanner.h");}
void INCLUDEREPLACE(){CX_INCL("parser.hpp");}
void INCLUDEREPLACE(){CX_INCL("ED2KLink.h");}
void INCLUDEREPLACE(){CX_INCL("StringConversion.h");}




static char THIS_FILE[] =  "FILE" ;




extern int yyerror(const char* errstr);
extern int yyerrorf(const char* errstr, ...);
extern CStringA StrToUtf8(const CString& rstr);





static void ReadLexBuff(char* pcBuff, int& riResult, size_t uMaxSize);
static void FatalLexError(const   char msg[]);
int opt_strnicmp(const char* pszString, const char* pszMatch, size_t nMinMatch);

static CStringA _strInputBuff;
static const char* _pszLexBuff;
static bool _bKeepQuotedStrings;




/* Reject some special characters for 'keywords'
 *
 * SPACE obvious
 * ( and ) obvious
 * "  quoted string
 *
                            comparison operator
 * =             operator
 *
 * The '@' character does not need to be rejected because:
 * - it is allowed only at the start of a meta-id (e.g. @size)
 *  - all terminals which are allowed to preceede a meta-id and which are allowed
 *    to follow a meta-id are already rejected (e.g. (a)@size>1). This way we can
 *    still allow keywords which include a '@' character (e.g. fr@nk)
 */











/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */



           int () 1   ( void )   ;






static void yyunput ( int c, char *buf_ptr )   ;



static void yy_flex_strncpy ( char *, const   char *, int )   ;



static int yy_flex_strlen ( const   char * )   ;




static int yyinput ( void )   ;






static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;

static void yy_push_state ( int new_state )   ;


static void yy_pop_state ( void )   ;


static int yy_top_state ( void )   ;









YY_MALLOC_DECL













/* Amount of stuff to slurp up with each read. */




/* Copy whatever the last rule matched to the standard output. */


/* This used to be an fputs(), but since the string might contain NU 's,
 * we now use fwrite().
 */



/* Gets input and stuffs it into "buf".  number of characters read, or 0      ,
 * is returned in "result".
 */






























/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */




/* Number of entries by which start-condition stack grows. */




/* Report a fatal error. */




/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */




/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */




/* Code executed at the end of each rule. */







int yylex ( void )
 {
          yy_state_type yy_current_state;
          char *yy_cp, *yy_bp;
          int yy_act;




 if ( yy_init )
  {
  yy_init = 0;


  YY_USER_INIT;


  if ( ! yy_start )
   yy_start = 1; /* first start state */

  if ( ! yyin )
   yyin = stdin;

  if ( ! yyout )
   yyout = stdout;

  if ( ! yy_current_buffer )
   yy_current_buffer =
    yy_create_buffer( yyin, 16384       );

  yy_load_buffer_state();
  }

 while ( 1 )  /* loops until end-of-file is reached */
  {
  yy_cp = yy_c_buf_p;

  /* Support of yytext. */
  *yy_cp = yy_hold_char;

  /* yy_bp points to the position in yy_ch_buf of the start of
   * the current run.
   */
  yy_bp = yy_cp;

  yy_current_state = yy_start;
  yy_state_ptr = yy_state_buf;
  *yy_state_ptr++ = yy_current_state;
yy_match:
  do
   {
            YY_CHAR yy_c = yy_ec[((unsigned int) (unsigned char) *yy_cp)];
   while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 172 )
     yy_c = yy_meta[(unsigned int) yy_c];
    }
   yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
   *yy_state_ptr++ = yy_current_state;
   ++yy_cp;
   }
  while ( yy_base[yy_current_state] != 1221 );

yy_find_action:
  yy_current_state = *--yy_state_ptr;
  yy_lp = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backing up */
  for ( ; ; ) /* until we find what rule we matched */
   {
   if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
    {
    yy_act = yy_acclist[yy_lp];
     {
     yy_full_match = yy_cp;
     break;
     }
    }
   --yy_cp;
   yy_current_state = *--yy_state_ptr;
   yy_lp = yy_accept[yy_current_state];
   }

  yytext     = yy_bp; yyleng = (int) (yy_cp - yy_bp); yy_hold_char = *yy_cp; *yy_cp = '\0'; yy_c_buf_p = yy_cp;;


do_action: /* This label is used only to access     actions. */


  switch ( yy_act )
 { /* beginning of action switch */
case 1:

{ /* Skip blanks. */ }
 break;
case 2:

{ return TOK_OR; }
 break;
case 3:

{ return TOK_AND; }
 break;
case 4:

{ return TOK_NOT; }
 break;
case 5:

{
     if (opt_strnicmp(yytext+1, "size", 3) == 0) {
      yy_start = 1 + 2 *(2   );
      return TOK_SIZE;
     }
     else if (opt_strnicmp(yytext+1, "type", 3) == 0) {
      yy_start = 1 + 2 *(3   );
      return TOK_TYPE;
     }
     else if (opt_strnicmp(yytext+1, "ext", 3) == 0) {
      yy_start = 1 + 2 *(4     );
      return TOK_EXT;
     }
     else if (opt_strnicmp(yytext+1, "availability", 3) == 0 ||
           opt_strnicmp(yytext+1, "sources", 3) == 0) {
      yy_start = 1 + 2 *(1     );
      return TOK_SOURCES;
     }
     else if (opt_strnicmp(yytext+1, "complete", 3) == 0) {
      yy_start = 1 + 2 *(1     );
      return TOK_COMPLETE;
     }
     else if (opt_strnicmp(yytext+1, "bitrate", 3) == 0) {
      yy_start = 1 + 2 *(1     );
      return TOK_BITRATE;
     }
     else if (opt_strnicmp(yytext+1, "length", 3) == 0) {
      yy_start = 1 + 2 *(5     );
      return TOK_LENGTH;
     }
     else if (opt_strnicmp(yytext+1, "codec", 3) == 0) {
      yy_start = 1 + 2 *(4     );
      return TOK_CODEC;
     }
     else if (opt_strnicmp(yytext+1, "rating", 3) == 0) {
      yy_start = 1 + 2 *(1     );
      return TOK_RATING;
     }
     else if (opt_strnicmp(yytext+1, "title", 3) == 0) {
      yy_start = 1 + 2 *(4     );
      return TOK_TITLE;
     }
     else if (opt_strnicmp(yytext+1, "album", 3) == 0) {
      yy_start = 1 + 2 *(4     );
      return TOK_ALBUM;
     }
     else if (opt_strnicmp(yytext+1, "artist", 3) == 0) {
      yy_start = 1 + 2 *(4     );
      return TOK_ARTIST;
     }
     yyerrorf(GetResString(IDS_SEARCH_UNKATTR), OptUtf8ToStr(yytext));
     () return 0      ();
     /*NOT REACHED*/
    }
 break;
case 6:

{ return TOK_OPR_EQ; }
 break;
case 7:

{ return TOK_OPR_GT; }
 break;
case 8:

{ return TOK_OPR_LT; }
 break;
case 9:

{ return TOK_OPR_GE; }
 break;
case 10:

{ return TOK_OPR_LE; }
 break;
case 11:

{ return TOK_OPR_NE; }
 break;
case 12:

{
 //
 // NOTE: There is no need to explicitly handle the
 //
 // "ed2k::"[a-fA-F0-9]{32}
 //
 // pattern with a separate token. It would be even wrong! "ed2k::      " is to be handled
 // as any other string term. It even can get combined with other search terms and operators
 // within one search tree.
     CString strError;
     try
     {
      USES_CONVERSION;
      CED2KLink* pLink = CED2KLink::CreateLinkFromUrl(A2T(yytext));
      if (pLink && pLink->GetKind() == CED2KLink::kFile)
      {
       CED2KFileLink* pFileLink = pLink->GetFileLink();
       if (pFileLink)
       {
        yylval.pstr = new       CStringA;
        yylval.pstr->Format("ed2k::%s", md4strA(pFileLink->GetHashKey()));
        delete pLink;
        return TOK_ED2K_LINK;
       }
      }
      delete pLink;
     }
     catch(CString strEd2kLinkError)
     {
      strError = strEd2kLinkError;
     }
     if (strError.IsEmpty())
      strError = GetResString(IDS_ERR_BADED2KLINK);
     yyerror(strError);
     () return 0      ();
     /*NOT REACHED*/
    }
 break;
case 13:

{
     yy_start = 1 + 2 *(0      );
     char* endptr = NULL;
     double dbl = strtod(yytext, &endptr);
     if (endptr) {
      if (*endptr == 'k')
       dbl *= 1000;
      else if (*endptr == 'm')
       dbl *= 1000*1000;
      else if (*endptr == 'g')
       dbl *= 1000*1000*1000;
     }
     yylval.num = (uint64)(dbl + 0.5);
     return TOK_NUMBER;
    }
 break;
case 14:

{
     yy_start = 1 + 2 *(0      );
     char* endptr = NULL;
     double dbl = strtod(yytext, &endptr);
     if (endptr) {
      if (*endptr == 'B' || *endptr == 'b')
       ;
      else if (*endptr == 'K' || *endptr == 'k')
       dbl *= 1024;
      else if (*endptr == 'M' || *endptr == 'm')
       dbl *= 1024*1024;
      else if (*endptr == 'G' || *endptr == 'g')
       dbl *= 1024*1024*1024;
      else
       dbl *= 1024*1024;
     }
     else {
      dbl *= 1024*1024;
     }
     yylval.num = (uint64)(dbl + 0.5);
     return TOK_NUMBER;
    }
 break;
case 15:

{
     yy_start = 1 + 2 *(0      );
     char* endptr = NULL;
     double dbl = strtod(yytext, &endptr);
     if (endptr) {
      if (*endptr == 's')
       ;
      else if (*endptr == 'm')
       dbl *= 60;
      else if (*endptr == 'h')
       dbl *= 60*60;
     }
     yylval.num = (uint64)(dbl + 0.5);
     return TOK_NUMBER;
    }
 break;
case 16:

{
     yy_start = 1 + 2 *(0      );
     unsigned int m, s;
     if (sscanf(yytext, "%u:%u", &m, &s) != 2) {
      yyerrorf(GetResString(IDS_SEARCH_ATTRERR), _T("@length"));
      () return 0      ();
      /*NOT REACHED*/
     }
     yylval.num = s + m*60;
     return TOK_NUMBER;
    }
 break;
case 17:

{
     yy_start = 1 + 2 *(0      );
     unsigned int h, m, s;
     if (sscanf(yytext, "%u:%u:%u", &h, &m, &s) != 3) {
      yyerrorf(GetResString(IDS_SEARCH_ATTRERR), _T("@length"));
      () return 0      ();
      /*NOT REACHED*/
     }
     yylval.num = s + m*60 + h*60*60;
     return TOK_NUMBER;
    }
 break;
case 18:

{
     yy_start = 1 + 2 *(0      );
     if (opt_strnicmp(yytext, "audio", 3) == 0)
     {
      yylval.pstr = new       CStringA(ED2KFTSTR_AUDIO);
      return TOK_TYPEVAL;
     }
     else if (opt_strnicmp(yytext, "video", 3) == 0)
     {
      yylval.pstr = new       CStringA(ED2KFTSTR_VIDEO);
      return TOK_TYPEVAL;
     }
     else if (opt_strnicmp(yytext, "image", 3) == 0 || _stricmp(yytext, "img") == 0)
     {
      yylval.pstr = new       CStringA(ED2KFTSTR_IMAGE);
      return TOK_TYPEVAL;
     }
     else if (opt_strnicmp(yytext, "document", 3) == 0)
     {
      yylval.pstr = new       CStringA(ED2KFTSTR_DOCUMENT);
      return TOK_TYPEVAL;
     }
     else if (opt_strnicmp(yytext, "program", 3) == 0)
     {
      yylval.pstr = new       CStringA(ED2KFTSTR_PROGRAM);
      return TOK_TYPEVAL;
     }
     else if (opt_strnicmp(yytext, "archive", 3) == 0)
     {
      yylval.pstr = new       CStringA(ED2KFTSTR_ARCHIVE);
      return TOK_TYPEVAL;
     }
     else if (_stricmp(yytext, "iso") == 0 || _stricmp(yytext, "cd") == 0)
     {
      yylval.pstr = new       CStringA(ED2KFTSTR_CDIMAGE);
      return TOK_TYPEVAL;
     }
     yyerrorf(GetResString(IDS_SEARCH_ATTRERR), _T("@type"));
     () return 0      ();
     /*NOT REACHED*/
    }
 break;
case 19:

{ return TOK_NOT; }
 break;
case 20:

{
     if (((yy_start - 1) / 2) == 0      )
     {
         /* Strings prefixed with '-' are to be handled with a different rule, reject it and let
          * the scanner find the next best rule. */
         if (yytext[0] == '-') {
          { *yy_cp = yy_hold_char;  ++yy_lp; goto find_rule; };
          /*NOT REACHED*/
         }

         /* Strings prefixed with '@' are treated as 'invalid' meta-tag id. Otherwise they would be
          * silently used as string terms -> a typo would not be noticed by the user */
         if (yytext[0] == '@') {
       yyerrorf(GetResString(IDS_SEARCH_UNKATTR), OptUtf8ToStr(yytext));
          () return 0      ();
          /*NOT REACHED*/
         }
     }
     else if (((yy_start - 1) / 2) == 4     )
      yy_start = 1 + 2 *(0      );
     yylval.pstr = new       CStringA(yytext);
     return TOK_STRING;
                }
 break;
case 21:

{
     int l = 128;
     char* psz = (char*)malloc(l);
     if (psz == NULL) {
      yyerror(_T("Less memory for string"));
      () return 0      ();
      /*NOT REACHED*/
     }
     int i = 0;
     int c;
     while ((c = yyinput()) != '\"')
     {
      if (c == EOF || c == '\n'){
       yyunput( c, yytext_ptr );
       yyerror(GetResString(IDS_SEARCH_UNTERMSTRING));
       () return 0      ();
       /*NOT REACHED*/
       break;
      }
      if (c == '\\'){  /*Escape sequence*/
       switch (c = yyinput())
       {
       case '\n':
        continue;
       case 't':  /*Tab*/
        c = '\t';
        break;
       case 'n':  /*Linefeed*/
        c = '\n';
        break;
       case 'f':  /*Formfeed*/
        c = '\f';
        break;
       case 'r':  /*Carriage return*/
        c = '\r';
        break;
       case '\\':  /*Backslash*/
        c = '\\';
        break;
       case '"':  /*Double quotation mark*/
        c = '\"';
        break;
       case '\'':  /*Single quotation mark*/
        c = '\'';
        break;
       case '?':  /*Question mark*/
        c = '\?';
        break;
       case 'v':  /*Vertical Tab*/
        c = '\v';
        break;
       case 'a':  /*Alert*/
        c = '\a';
        break;
       case 'b':  /*Backspace*/
        c = '\b';
        break;
       case 'x':  /*Hexadecimal number*/
        {
         int n, octv;
         for (n = 1, octv = 0; n <= 3; n++) {
          if ((c = yyinput()) >= '0' && c <= '9')
           c -= '0';
          else if (c >= 'a' && c <= 'f')
           c = (c - 'a') + 10;
          else if (c >= 'A' && c <= 'F')
           c = (c - 'A') + 10;
          else
           break;
          octv = octv * 16 + c;
         }
         yyunput( c, yytext_ptr );
         if (n == 1)
          c = 'x';
         else
          c = octv;
        }
        break;
       }
      }

      else{
       if ((unsigned char)c >= 0x80 && IsDBCSLeadByte(yytext[0])){
        psz[i++] = (unsigned char)c;
        if (i >= l){
         char* pszNew = (char*)realloc(psz, l += 128);
         if (pszNew == NULL){
          free(psz);
          yyerror(_T("Less memory for string"));
          () return 0      ();
          /*NOT REACHED*/
          break;
         }
         psz = pszNew;
        }
        c = yyinput();
       }
      }


      psz[i++] = (unsigned char)c;
      if (i >= l){
       char* pszNew = (char*)realloc(psz, l += 128);
       if (pszNew == NULL){
        free(psz);
        yyerror(_T("Less memory for string"));
        () return 0      ();
        /*NOT REACHED*/
        break;
       }
       psz = pszNew;
      }
     }
     psz[i] = '\0';

     if (_bKeepQuotedStrings && ((yy_start - 1) / 2) != 4     ) {
      CStringA quoted;
      quoted = '\"';
      quoted += psz;
      quoted += '\"';
      yylval.pstr = new       CStringA(quoted);
     }
     else
      yylval.pstr = new       CStringA(psz);
     free(psz);

     yy_start = 1 + 2 *(0      );

     // Do not return empty strings, and also do not return quoted empty strings
     if (!yylval.pstr->IsEmpty() && *yylval.pstr != "\"\"")
      return TOK_STRING;

     delete yylval.pstr;
    }
 break;
case 22:

{ return yytext[0]; }
 break;
case (YY_END_OF_BUFFER + 0       + 1):
case (YY_END_OF_BUFFER + 1      + 1):
case (YY_END_OF_BUFFER + 2    + 1):
case (YY_END_OF_BUFFER + 3    + 1):
case (YY_END_OF_BUFFER + 4      + 1):
case (YY_END_OF_BUFFER + 5      + 1):
{ return TOK_EOF; }
 break;
case 23:

(void) fwrite( yytext, yyleng, 1, yyout );
 break;

 case 24              :
  {
  /* Amount of text matched not including the     char. */
  int yy_amount_of_matched_text = (int) (yy_cp - yytext    ) - 1;

  /* Undo the effects of yytext     = yy_bp; yyleng = (int) (yy_cp - yy_bp); yy_hold_char = *yy_cp; *yy_cp = '\0'; yy_c_buf_p = yy_cp;. */
  *yy_cp = yy_hold_char;


  if ( yy_current_buffer->yy_buffer_status == 0             )
   {
   /* We're scanning a new       file or input source.  It's
    * possible that this happened because the user
    * just pointed yyin at a new       source and called
    * yylex().  If so, then we have to assure
    * consistency between yy_current_buffer and our
    * globals.  Here is the right place to do so, because
    * this is the first
 that will match for the new       input source.
    */
   yy_n_chars = yy_current_buffer->yy_n_chars;
   yy_current_buffer->yy_input_file = yyin;
   yy_current_buffer->yy_buffer_status = 1               ;
   }

  /* Note that here we test for yy_c_buf_p "<=" to the position
   * of the first     in the buffer, since yy_c_buf_p will
   * already have been incremented past the     character
   * (since all states make transitions on     to the
   * end-of-buffer state).  Contrast this with the test
   * in input().
   */
  if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
   { /* This was really a NUL. */
   yy_state_type yy_next_state;

   yy_c_buf_p = yytext     + yy_amount_of_matched_text;

   yy_current_state = yy_get_previous_state();

   /* Okay, we're now positioned to make the NUL
    * transition.  We couldn't have
    * yy_get_previous_state() go ahead and do it
    * for us because it doesn't know how to deal
    * with the possibility of jamming (and we don't
    * want to build jamming into it because then it
    * will run more slowly).
    */

   yy_next_state = yy_try_NUL_trans( yy_current_state );

   yy_bp = yytext     + 0          ;

   if ( yy_next_state )
    {
    /* Consume the NUL. */
    yy_cp = ++yy_c_buf_p;
    yy_current_state = yy_next_state;
    goto yy_match;
    }

   else
    {
    yy_cp = yy_c_buf_p;
    goto yy_find_action;
    }
   }

  else switch ( yy_get_next_buffer() )
   {
   case 1                  :
    {
    yy_did_buffer_switch_on_eof = 0;

    if ( () 1  () )
     {
     /* Note: because we've taken care in
      * yy_get_next_buffer() to have set up
      * yytext, we can now set up
      * yy_c_buf_p so that if some total
      * hoser (like flex itself) wants to
      * call the scanner after we return the
      * 0      , it'll still work - another
      * 0       will get returned.
      */
     yy_c_buf_p = yytext     + 0          ;

     yy_act = (YY_END_OF_BUFFER + ((yy_start - 1) / 2) + 1);
     goto do_action;
     }

    else
     {
     if ( ! yy_did_buffer_switch_on_eof )
      yyrestart( yyin );
     }
    break;
    }

   case 0                    :
    yy_c_buf_p =
     yytext     + yy_amount_of_matched_text;

    yy_current_state = yy_get_previous_state();

    yy_cp = yy_c_buf_p;
    yy_bp = yytext     + 0          ;
    goto yy_match;

   case 2                 :
    yy_c_buf_p =
    &yy_current_buffer->yy_ch_buf[yy_n_chars];

    yy_current_state = yy_get_previous_state();

    yy_cp = yy_c_buf_p;
    yy_bp = yytext     + 0          ;
    goto yy_find_action;
   }
  break;
  }

 default:
  yy_fatal_error(
   "fatal flex scanner internal error--no action found"  );
 } /* end of action switch */
  } /* end of scanning one token */
 } /* end of yylex */


/* yy_get_next_buffer - try to read in a new       buffer
 *
 * Returns a code representing an action:
 * 2                  -
 * 0                     - continue scanning from current position
 * 1                   - end of file
 */

static int yy_get_next_buffer()
 {
          char *dest = yy_current_buffer->yy_ch_buf;
          char *source = yytext    ;
          int number_to_move, i;
 int ret_val;

 if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
  yy_fatal_error(
  "fatal flex scanner internal error--end of buffer missed"  );

 if ( yy_current_buffer->yy_fill_buffer == 0 )
  { /* Don't try to fill the buffer, so this is an EOF. */
  if ( yy_c_buf_p - yytext     - 0           == 1 )
   {
   /* We matched a single character, the EOB, so
    * treat this as a final EOF.
    */
   return 1                  ;
   }

  else
   {
   /* We matched some text prior to the EOB, first
    * process it.
    */
   return 2                 ;
   }
  }

 /* Try to read more data. */

 /* First move last chars to start of buffer. */
 number_to_move = (int) (yy_c_buf_p - yytext    ) - 1;

 for ( i = 0; i < number_to_move; ++i )
  *(dest++) = *(source++);

 if ( yy_current_buffer->yy_buffer_status == 2                     )
  /* don't do the read, it's not guaranteed to return an EOF,
   * just force an EOF
   */
  yy_current_buffer->yy_n_chars = yy_n_chars = 0;

 else
  {
  int num_to_read =
   yy_current_buffer->yy_buf_size - number_to_move - 1;

  while ( num_to_read <= 0 )
   { /* Not enough room in the buffer - grow it. */

   yy_fatal_error(
"input buffer overflow );



































   }

  if ( num_to_read > 8192             )
   num_to_read = 8192            ;

  /* Read in more data. */
  if ( yy_current_buffer->yy_is_interactive ) { int c = '*', n; for ( n = 0; n <  num_to_read  && (c = getc( yyin )) != EOF && c != '\n'; ++n )  (&yy_current_buffer->yy_ch_buf[number_to_move])[n] = (char) c; if ( c == '\n' )  (&yy_current_buffer->yy_ch_buf[number_to_move])[n++] = (char) c; if ( c == EOF && ferror( yyin ) ) FatalLexError ( "input in flex scanner failed" );
   yy_n_chars = n; } else { errno=0; while ( (
   yy_n_chars = fread( (&yy_current_buffer->yy_ch_buf[number_to_move]), 1,  num_to_read , yyin))==0 && ferror(yyin)) { if( errno != EINTR) { FatalLexError ( "input in flex scanner failed" ); break; } errno=0; clearerr(yyin); } };

  yy_current_buffer->yy_n_chars = yy_n_chars;
  }

 if ( yy_n_chars == 0 )
  {
  if ( number_to_move == 0           )
   {
   ret_val = 1                  ;
   yyrestart( yyin );
   }

  else
   {
   ret_val = 2                 ;
   yy_current_buffer->yy_buffer_status =
    2                    ;
   }
  }

 else
  ret_val = 0                    ;

 yy_n_chars += number_to_move;
 yy_current_buffer->yy_ch_buf[yy_n_chars] = 0                    ;
 yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = 0                    ;

 yytext     = &yy_current_buffer->yy_ch_buf[0];

 return ret_val;
 }


/* yy_get_previous_state - get the state just before the     char was reached */

static yy_state_type yy_get_previous_state()
 {
          yy_state_type yy_current_state;
          char *yy_cp;

 yy_current_state = yy_start;
 yy_state_ptr = yy_state_buf;
 *yy_state_ptr++ = yy_current_state;

 for ( yy_cp = yytext     + 0          ; yy_cp < yy_c_buf_p; ++yy_cp )
  {
           YY_CHAR yy_c = (*yy_cp ? yy_ec[((unsigned int) (unsigned char) *yy_cp)] : 1);
  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
   {
   yy_current_state = (int) yy_def[yy_current_state];
   if ( yy_current_state >= 172 )
    yy_c = yy_meta[(unsigned int) yy_c];
   }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  *yy_state_ptr++ = yy_current_state;
  }

 return yy_current_state;
 }


/* yy_try_NUL_trans - try to make a transition on the     character
 *
 * synopsis
 * next_state = yy_try_NUL_trans( current_state );
 */


static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )




 {
          int yy_is_jam;

          YY_CHAR yy_c = 1;
 while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
  {
  yy_current_state = (int) yy_def[yy_current_state];
  if ( yy_current_state >= 172 )
   yy_c = yy_meta[(unsigned int) yy_c];
  }
 yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 yy_is_jam = (yy_current_state == 171);
 if ( ! yy_is_jam )
  *yy_state_ptr++ = yy_current_state;

 return yy_is_jam ? 0 : yy_current_state;
 }




static void yyunput( int c,          char *yy_bp )





 {
          char *yy_cp = yy_c_buf_p;

 /* undo effects of setting up yytext */
 *yy_cp = yy_hold_char;

 if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
  { /* need to shift things up to make room */
  /* +2 for     chars. */
           int number_to_move = yy_n_chars + 2;
           char *dest = &yy_current_buffer->yy_ch_buf[
     yy_current_buffer->yy_buf_size + 2];
           char *source =
    &yy_current_buffer->yy_ch_buf[number_to_move];

  while ( source > yy_current_buffer->yy_ch_buf )
   *--dest = *--source;

  yy_cp += (int) (dest - source);
  yy_bp += (int) (dest - source);
  yy_current_buffer->yy_n_chars =
   yy_n_chars = yy_current_buffer->yy_buf_size;

  if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
   yy_fatal_error(  "flex scanner push-back overflow"  );
  }

 *--yy_cp = (char) c;


 yytext     = yy_bp;
 yy_hold_char = *yy_cp;
 yy_c_buf_p = yy_cp;
 }
       /* ifndef YY_NO_UNPUT */



static int yyinput()



 {
 int c;

 *yy_c_buf_p = yy_hold_char;

 if ( *yy_c_buf_p == 0                     )
  {
  /* yy_c_buf_p now points to the character we want to return.
   * If this occurs *before* the     characters, then it's a
   * valid NUL; if not, then we've hit the end of the buffer.
   */
  if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
   /* This was really a NUL. */
   *yy_c_buf_p = '\0';

  else
   { /* need more input */
   int offset = yy_c_buf_p - yytext    ;
   ++yy_c_buf_p;

   switch ( yy_get_next_buffer() )
    {
    case 2                 :
     /* This happens because yy_g_n_b()
      * sees that we've accumulated a
      * token and flags that we need to
      * try matching the token before
      * proceeding.  But for input(),
      * there's no matching to consider.
      * So convert the 2
      * to 1                  .
      */

     /* Reset buffer status. */
     yyrestart( yyin );

     /* fall through */

    case 1                  :
     {
     if ( () 1  () )
      return EOF;

     if ( ! yy_did_buffer_switch_on_eof )
      yyrestart( yyin );

     return yyinput();



     }

    case 0                    :
     yy_c_buf_p = yytext     + offset;
     break;
    }
   }
  }

 c = *(unsigned char *) yy_c_buf_p; /* cast for 8-bit char's */
 *yy_c_buf_p = '\0'; /* preserve yytext */
 yy_hold_char = *++yy_c_buf_p;


 return c;
 }



void yyrestart( FILE *input_file )




 {
 if ( ! yy_current_buffer )
  yy_current_buffer = yy_create_buffer( yyin, 16384       );

 yy_init_buffer( yy_current_buffer, input_file );
 yy_load_buffer_state();
 }



void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )




 {
 if ( yy_current_buffer == new_buffer )
  return;

 if ( yy_current_buffer )
  {
  /* Flush out information for old buffer. */
  *yy_c_buf_p = yy_hold_char;
  yy_current_buffer->yy_buf_pos = yy_c_buf_p;
  yy_current_buffer->yy_n_chars = yy_n_chars;
  }

 yy_current_buffer = new_buffer;
 yy_load_buffer_state();

 /* We don't actually know whether we did this switch during
  * EOF (() 1  ()) processing, but the only time this flag
  * is looked at is is called, so it's safe
  * to go ahead and always set it.
  */
 yy_did_buffer_switch_on_eof = 1;
 }



void yy_load_buffer_state( void )



 {
 yy_n_chars = yy_current_buffer->yy_n_chars;
 yytext     = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
 yyin = yy_current_buffer->yy_input_file;
 yy_hold_char = *yy_c_buf_p;
 }



YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )





 {
 YY_BUFFER_STATE b;

 b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof(        yy_buffer_state ) );
 if ( ! b )
  yy_fatal_error(  "out of dynamic memory in yy_create_buffer()"  );

 b->yy_buf_size = size;

 /* yy_ch_buf has to be 2 characters longer than the size given because
  * we need to put in 2 end-of-buffer characters.
  */
 b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
 if ( ! b->yy_ch_buf )
  yy_fatal_error(  "out of dynamic memory in yy_create_buffer()"  );

 b->yy_is_our_buffer = 1;

 yy_init_buffer( b, file );

 return b;
 }



void yy_delete_buffer( YY_BUFFER_STATE b )




 {
 if ( ! b )
  return;

 if ( b == yy_current_buffer )
  yy_current_buffer = (YY_BUFFER_STATE) 0;

 if ( b->yy_is_our_buffer )
  yy_flex_free( (void *) b->yy_ch_buf );

 yy_flex_free( (void *) b );
 }



void INCLUDEREPLACE(){CX_INCL("unistd.h");}









void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )







 {
 yy_flush_buffer( b );

 b->yy_input_file = file;
 b->yy_fill_buffer = 1;


 b->yy_is_interactive = 1;







 }



void yy_flush_buffer( YY_BUFFER_STATE b )





 {
 if ( ! b )
  return;

 b->yy_n_chars = 0;

 /* We always need two end-of-buffer characters.  The first causes
  * a transition to the end-of-buffer state.  The second causes
  * a jam in that state.
  */
 b->yy_ch_buf[0] = 0                    ;
 b->yy_ch_buf[1] = 0                    ;

 b->yy_buf_pos = &b->yy_ch_buf[0];

 b->yy_at_bol = 1;
 b->yy_buffer_status = 0            ;

 if ( b == yy_current_buffer )
  yy_load_buffer_state();
 }




YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )





 {
 YY_BUFFER_STATE b;

 if ( size < 2 ||
      base[size-2] != 0                     ||
      base[size-1] != 0                     )
  /* They forgot to leave room for the EOB's. */
  return 0;

 b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof(        yy_buffer_state ) );
 if ( ! b )
  yy_fatal_error(  "out of dynamic memory in yy_scan_buffer()"  );

 b->yy_buf_size = size - 2; /* "- 2" to take care of EOB's */
 b->yy_buf_pos = b->yy_ch_buf = base;
 b->yy_is_our_buffer = 0;
 b->yy_input_file = 0;
 b->yy_n_chars = b->yy_buf_size;
 b->yy_is_interactive = 0;
 b->yy_at_bol = 1;
 b->yy_fill_buffer = 0;
 b->yy_buffer_status = 0            ;

 yy_switch_to_buffer( b );

 return b;
 }





YY_BUFFER_STATE yy_scan_string( const   char *yy_str )




 {
 int len;
 for ( len = 0; yy_str[len]; ++len )
  ;

 return yy_scan_bytes( yy_str, len );
 }





YY_BUFFER_STATE yy_scan_bytes( const   char *bytes, int len )





 {
 YY_BUFFER_STATE b;
 char *buf;
 yy_size_t n;
 int i;

 /* Get memory for full buffer, including space for trailing EOB's. */
 n = len + 2;
 buf = (char *) yy_flex_alloc( n );
 if ( ! buf )
  yy_fatal_error(  "out of dynamic memory in yy_scan_bytes()"  );

 for ( i = 0; i < len; ++i )
  buf[i] = bytes[i];

 buf[len] = buf[len+1] = 0                    ;

 b = yy_scan_buffer( buf, n );
 if ( ! b )
  yy_fatal_error(  "bad buffer in yy_scan_bytes()"  );

 /* It's okay to grow etc. this buffer, and we should throw it
  * away when we're done.
  */
 b->yy_is_our_buffer = 1;

 return b;
 }





static void yy_push_state( int new_state )




 {
 if ( yy_start_stack_ptr >= yy_start_stack_depth )
  {
  yy_size_t new_size;

  yy_start_stack_depth += 25                 ;
  new_size = yy_start_stack_depth * sizeof( int );

  if ( ! yy_start_stack )
   yy_start_stack = (int *) yy_flex_alloc( new_size );

  else
   yy_start_stack = (int *) yy_flex_realloc(
     (void *) yy_start_stack, new_size );

  if ( ! yy_start_stack )
   yy_fatal_error(
   "out of memory expanding start-condition stack"  );
  }

 yy_start_stack[yy_start_stack_ptr++] = ((yy_start - 1) / 2);

 yy_start = 1 + 2 *(new_state);
 }




static void yy_pop_state()
 {
 if ( --yy_start_stack_ptr < 0 )
  yy_fatal_error(  "start-condition stack underflow"  );

 yy_start = 1 + 2 *(yy_start_stack[yy_start_stack_ptr]);
 }




static int yy_top_state()
 {
 return yy_start_stack[yy_start_stack_ptr - 1];
 }







static void yy_fatal_error( const   char msg[] )




 {
 (void) fprintf( stderr, "%s\n", msg );
 exit( 2               );
 }



/* Redefine do {  } while ( 0 ) so it works in section 3 code. */















/* Internal utility routines. */



static void yy_flex_strncpy( char *s1, const   char *s2, int n )






 {
          int i;
 for ( i = 0; i < n; ++i )
  s1[i] = s2[i];
 }




static int yy_flex_strlen( const   char *s )




 {
          int n;
 for ( n = 0; s[n]; ++n )
  ;

 return n;
 }




static void *yy_flex_alloc( yy_size_t size )




 {
 return (void *) malloc( size );
 }


static void *yy_flex_realloc( void *ptr, yy_size_t size )





 {
 /* The cast in the following accommodates both
  * implementations that use char* generic pointers, and those
  * that use void* generic pointers.  It works with the latter
  * because both      C and C++ allow castless assignment from
  * any pointer type to void*, and deal with argument conversions
  * as though doing an assignment.
  */
 return (void *) realloc( (char *) ptr, size );
 }


static void yy_flex_free( void *ptr )




 {
 free( ptr );
 }


int main()
 {
 yylex();
 return 0;
 }






static void ReadLexBuff(char* pcBuff, int& riResult, size_t uMaxSize)
{
 ASSERT( _pszLexBuff != NULL );
 if (_pszLexBuff == NULL)
  yy_fatal_error( "Input in flex scanner failed" );

 ASSERT( sizeof(YY_CHAR) == sizeof(char) );
 size_t uCharsInBuff = strlen(_pszLexBuff);
 size_t uCharsRead = min(uMaxSize, uCharsInBuff);
 riResult = uCharsRead;
 memcpy(pcBuff, _pszLexBuff, uCharsRead);
 _pszLexBuff += uCharsRead;
}

static void FatalLexError(const   char msg[])
{

 printf("Fatal error in flex scanner: %s\n", msg);




}

void LexInit(const char* pszInput, bool bKeepQuotedStrings)
{
 _strInputBuff = StrToUtf8(pszInput);
 _pszLexBuff = (const char*)_strInputBuff;
 _bKeepQuotedStrings = bKeepQuotedStrings;
}

void LexFree()
{
 yytext = NULL;
 yyleng = 0;
 yyin = NULL;
 yyout = NULL;
 yy_delete_buffer(yy_current_buffer);
 yy_hold_char = '\0';
 yy_n_chars = 0;
 yy_c_buf_p = NULL;
 yy_init = 1;
 yy_start = 0;
 yy_did_buffer_switch_on_eof = 0;

 yy_last_accepting_state = 0;
 yy_last_accepting_cpos = NULL;


 yy_start_stack_ptr = 0;
 yy_start_stack_depth = 0;
 yy_start_stack = NULL;

 _strInputBuff.Empty();
 _pszLexBuff = NULL;
}

int opt_strnicmp(const char* pszString, const char* pszMatch, size_t nMinMatch)
{
 size_t nStringLen = strlen(pszString);
 if (nStringLen < nMinMatch)
  return -1;
 size_t nMatchLen = strlen(pszMatch);
 ASSERT( nMatchLen >= nMinMatch );
 if (nStringLen > nMatchLen)
  return 1;
 return _strnicmp(pszString, pszMatch, nStringLen);
}






 