//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE. See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


class CPartFile;
class CKnownFile;
       Gap_Struct;










 class ZIP_Entry
{
 uint32 header;
 uint16 versionToExtract;
 uint16 generalPurposeFlag;
 uint16 compressionMethod;
 uint16 lastModFileTime;
 uint16 lastModFileDate;
 uint32 crc32;
 uint32 lenCompressed;
 uint32 lenUncompressed;
 uint16 lenFilename;
 uint16 lenExtraField;
 unsigned char *filename;
 unsigned char *extraField;
 unsigned char *compressedData;
};



 class ZIP_CentralDirectory
{
 ZIP_CentralDirectory() {
  lenFilename = 0;
  filename = NULL;
  lenExtraField = 0;
  extraField = NULL;
  lenComment = 0;
  comment = NULL;
 }
 uint32 header;
 uint16 versionMadeBy;
 uint16 versionToExtract;
 uint16 generalPurposeFlag;
 uint16 compressionMethod;
 uint16 lastModFileTime;
 uint16 lastModFileDate;
 uint32 crc32;
 uint32 lenCompressed;
 uint32 lenUncompressed;
 uint16 lenFilename;
 uint16 lenExtraField;
 uint16 lenComment;
 uint16 diskNumberStart;
 uint16 internalFileAttributes;
 uint32 externalFileAttributes;
 uint32 relativeOffsetOfLocalHeader;
 unsigned char *filename;
 unsigned char *extraField;
 unsigned char *comment;
};



 class RAR_BlockFile
{
 RAR_BlockFile()
 {
  EXT_DATE = NULL;
  EXT_DATE_SIZE = 0;
 }
 ~RAR_BlockFile()
 {
  delete[] EXT_DATE;
 }

 // This indicates the position in the input file just after the filename
 unsigned long offsetData;
 // This indicates how much of the block is after this offset
 uint32 dataLength;

 uint16 HEAD_CRC;
 unsigned char HEAD_TYPE;
 uint16 HEAD_FLAGS;
 uint16 HEAD_SIZE;
 uint32 PACK_SIZE;
 uint32 UNP_SIZE;
 unsigned char HOST_OS;
 uint32 FILE_CRC;
 uint32 FTIME;
 unsigned char UNP_VER;
 unsigned char METHOD;
 uint16 NAME_SIZE;
 uint32 ATTR;
 uint32 HIGH_PACK_SIZE;
 uint32 HIGH_UNP_SIZE;
 unsigned char *FILE_NAME;
 unsigned char *EXT_DATE;
 uint32 EXT_DATE_SIZE;
 unsigned char SALT[8];
};


 class ACE_ARCHIVEHEADER
{
 uint16 HEAD_CRC;
 uint16 HEAD_SIZE;
 unsigned char HEAD_TYPE;
 uint16 HEAD_FLAGS;
 unsigned char HEAD_SIGN[7];
 unsigned char VER_EXTRACT;
 unsigned char VER_CREATED;
 unsigned char HOST_CREATED;
 unsigned char VOLUME_NUM;
 uint32 FTIME;
 unsigned char RESERVED[8];
 unsigned char AVSIZE;
 //**AV
 uint16 COMMENT_SIZE;

 char*   AV;
 char* COMMENT;
 char* DUMP;

 ACE_ARCHIVEHEADER() {
  AV=NULL;
  COMMENT=NULL;
  DUMP=NULL;
  COMMENT_SIZE=0;
 }
 ~ACE_ARCHIVEHEADER() {
  if (AV)  { free(AV);  AV=NULL;}
  if (COMMENT){ free(COMMENT);COMMENT=NULL;}
  if (DUMP) { free(DUMP); DUMP=NULL;}
 }
};


 class ACE_BlockFile
{
 uint16 HEAD_CRC;
 uint16 HEAD_SIZE;
 unsigned char HEAD_TYPE;
 uint16 HEAD_FLAGS;
 uint32  PACK_SIZE;
 uint32  ORIG_SIZE;
 uint32  FTIME;
 uint32  FILE_ATTRIBS;
 uint32  CRC32;
 uint32  TECHINFO;
 uint16  RESERVED;
 uint16  FNAME_SIZE;
 // fname
 uint16  COMM_SIZE;
 // comment

 char* FNAME;
 char* COMMENT;
 uint64  data_offset;
 ACE_BlockFile() {
  FNAME=NULL;
  COMMENT=NULL;
  COMM_SIZE=0;
 }
 ~ACE_BlockFile() {
  free(FNAME);
  free(COMMENT);
 }
};


 class ThreadParam
{
 CPartFile *partFile;
 CTypedPtrList                        *filled;
 bool preview;
 bool bCreatePartFileCopy;
};


 class archiveinfo_s {
 CTypedPtrList                                  *centralDirectoryEntries;
 CTypedPtrList                           *RARdir;
 CTypedPtrList                           *ACEdir;

 bool bZipCentralDir;
 unsigned short rarFlags;
 ACE_ARCHIVEHEADER *ACEhdr;
 archiveinfo_s() {
  centralDirectoryEntries=NULL;
  RARdir=NULL;
  ACEdir=NULL;
  rarFlags=0;
  bZipCentralDir=false;
  ACEhdr=NULL;
 }
};
 class archiveScannerThreadParams_s {
 CKnownFile*  file;
 archiveinfo_s* ai;
 CTypedPtrList                        *filled;
 int    type;
 void*   ownerHwnd;
 void*   progressHwnd;
 int    curProgress;
 bool   m_bIsValid;
};

class CArchiveRecovery
{
public:
 static void recover(CPartFile *partFile, bool preview = false, bool bCreatePartFileCopy = true);
 static bool recoverZip(CFile *zipInput, CFile *zipOutput, archiveScannerThreadParams_s* ai, CTypedPtrList                        *filled, bool fullSize);
 static bool recoverRar(CFile *rarInput, CFile *rarOutput, archiveScannerThreadParams_s* ai, CTypedPtrList                        *filled);
 static bool recoverAce(CFile *aceInput, CFile *aceOutput, archiveScannerThreadParams_s* ai, CTypedPtrList                        *filled);

private:
 CArchiveRecovery(void); // Just use static recover method

 static unsigned int           run(void*  lpParam);
 static bool performRecovery(CPartFile *partFile, CTypedPtrList                        *filled, bool preview, bool bCreatePartFileCopy = true);

 static bool scanForZipMarker(CFile *input, archiveScannerThreadParams_s* aitp, uint32 marker, uint32 available);
 static bool processZipEntry(CFile *zipInput, CFile *zipOutput, uint32 available, CTypedPtrList                                  *centralDirectoryEntries);
 static bool readZipCentralDirectory(CFile *zipInput, CTypedPtrList                                  *centralDirectoryEntries, CTypedPtrList                        *filled);

 static RAR_BlockFile *scanForRarFileHeader(CFile *input, archiveScannerThreadParams_s* aitp, unsigned long available);
 static bool validateRarFileBlock(RAR_BlockFile *block);
 static void writeRarBlock(CFile *input, CFile *output, RAR_BlockFile *block);

 static ACE_BlockFile *scanForAceFileHeader(CFile *input, archiveScannerThreadParams_s* aitp, unsigned long available);
 static void writeAceBlock(CFile *input, CFile *output, ACE_BlockFile *block);
 static void CArchiveRecovery::writeAceHeader(CFile *output, ACE_ARCHIVEHEADER* hdr);

 static bool CopyFile(CPartFile *partFile, CTypedPtrList                        *filled, CString tempFileName);
 static void DeleteMemory(ThreadParam *tp);
 static bool IsFilled(uint32 start, uint32 end, CTypedPtrList                        *filled);

 static void ProcessProgress(archiveScannerThreadParams_s* aitp, unsigned long pos);

 static uint16 readUInt16(CFile *input);
 static uint32 readUInt32(CFile *input);
 static uint16 calcUInt16(unsigned char *input);
 static uint32 calcUInt32(unsigned char *input);
 static void writeUInt16(CFile *output, uint16 val);
 static void writeUInt32(CFile *output, uint32 val);
};






 