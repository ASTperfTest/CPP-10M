// ------------------------------------------------------------
//  CDialogMinTrayBtn template class
//  MFC CDialog with minimize to systemtray button (0.04)
//  Supports WinXP styles (thanks to David Yuheng Zhao for CVisualStylesXP - yuheng_zhao@yahoo.com)
// ------------------------------------------------------------
//  DialogMinTrayBtn.hpp
//  zegzav - 2002,2003 - eMule project (http://www.emule-project.net)
// ------------------------------------------------------------
void INCLUDEREPLACE(){CX_INCL("stdafx.h");}
void INCLUDEREPLACE(){CX_INCL("DialogMinTrayBtn.h");}
void INCLUDEREPLACE(){CX_INCL("VisualStylesXP.h");}
void INCLUDEREPLACE(){CX_INCL("INVALID_INCLUDE_FILE_NAME_ResizableLibResizableDialog.h");}
void INCLUDEREPLACE(){CX_INCL("AfxBeginMsgMapTemplate.h");}
void INCLUDEREPLACE(){CX_INCL("OtherFunctions.h");}
void INCLUDEREPLACE(){CX_INCL("MenuCmds.h");}


// define this to use that source file as template











// ------------------------------
//  constants
// ------------------------------









BEGIN_TM_PART_STATES(TRAYBUTTON)
    TM_STATE(1, TRAYBS, NORMAL)


    TM_STATE(4, TRAYBS, DISABLED)
 // Inactive




END_TM_PART_STATES()








                      const char  *CDialogMinTrayBtn      ::m_pszMinTrayBtnBmpName[] = { _T("TRAYBTN_BLUE"), _T("TRAYBTN_METALLIC"), _T("TRAYBTN_HOMESTEAD") };









// _WIN32_WINNT >= 0x0501 (XP only)















/* BEGIN_MESSAGE_MAP_TEMPLATE(                     , CDialogMinTrayBtn      , CDialogMinTrayBtn, BASE)
    ON_WM_NCPAINT()






    ON_WM_TIMER()
 () { 0x031A          , 0, 0, 0, AfxSig_l, (        )(        W) (static_cast                                         ( &ThisClass :: _OnThemeChanged)) },()
END_MESSAGE_MAP() */ //)


                      CDialogMinTrayBtn      ::CDialogMinTrayBtn() :
    m_MinTrayBtnPos(0,0), m_MinTrayBtnSize(0,0), m_bMinTrayBtnEnabled(TRUE), m_bMinTrayBtnVisible(TRUE),
    m_bMinTrayBtnUp(TRUE), m_bMinTrayBtnCapture(FALSE), m_bMinTrayBtnActive(FALSE), m_bMinTrayBtnHitTest(FALSE)
{
    MinTrayBtnInit();
}

                      CDialogMinTrayBtn      ::CDialogMinTrayBtn(const char* lpszTemplateName, CWnd* pParentWnd) : BASE(lpszTemplateName, pParentWnd),
    m_MinTrayBtnPos(0,0), m_MinTrayBtnSize(0,0), m_bMinTrayBtnEnabled(TRUE), m_bMinTrayBtnVisible(TRUE),
    m_bMinTrayBtnUp(TRUE), m_bMinTrayBtnCapture(FALSE), m_bMinTrayBtnActive(FALSE), m_bMinTrayBtnHitTest(FALSE)
{
    MinTrayBtnInit();
}

                      CDialogMinTrayBtn      ::CDialogMinTrayBtn(unsigned int nIDTemplate, CWnd* pParentWnd) : BASE(nIDTemplate, pParentWnd),
    m_MinTrayBtnPos(0,0), m_MinTrayBtnSize(0,0), m_bMinTrayBtnEnabled(TRUE), m_bMinTrayBtnVisible(TRUE),
    m_bMinTrayBtnUp(TRUE), m_bMinTrayBtnCapture(FALSE), m_bMinTrayBtnActive(FALSE), m_bMinTrayBtnHitTest(FALSE)
{
    MinTrayBtnInit();
}

                      void CDialogMinTrayBtn      ::MinTrayBtnInit()
{
    m_nMinTrayBtnTimerId = 0;
 int  bBmpResult = MinTrayBtnInitBitmap();
 // - Never use the 'TransparentBlt' function under Win9x (read SDK)
 // - Load the 'MSIMG32.DL ' only, if it's really needed.
 if (!afxIsWin95() && bBmpResult && !_TransparentBlt)
 {
  void *  hMsImg32 = LoadLibrary(_T("MSIMG32.DL "));
  if (hMsImg32)
  {
   (FARPROC &)_TransparentBlt = GetProcAddress(hMsImg32, "TransparentBlt");
   if (!_TransparentBlt)
    FreeLibrary(hMsImg32);
  }
 }
}

                      int  CDialogMinTrayBtn      ::OnInitDialog()
{
 int  bReturn = BASE::OnInitDialog();
 InitWindowStyles(this);
    m_nMinTrayBtnTimerId = SetTimer(0x76617a67        , 200                   , NULL);
    return bReturn;
}

                      void CDialogMinTrayBtn      ::OnNcPaint()
{
    BASE::OnNcPaint();
    MinTrayBtnUpdatePosAndSize();
    MinTrayBtnDraw();
}

                      int  CDialogMinTrayBtn      ::OnNcActivate(int  bActive)
{
    MinTrayBtnUpdatePosAndSize();
    int  bResult = BASE::OnNcActivate(bActive);
    m_bMinTrayBtnActive = bActive;
    MinTrayBtnDraw();
    return bResult;
}



long * 



CDialogMinTrayBtn      ::OnNcHitTest(CPoint point)
{
    int  bPreviousHitTest = m_bMinTrayBtnHitTest;
    m_bMinTrayBtnHitTest = MinTrayBtnHitTest(point);
    if (!IsWindowsClassicStyle() && m_bMinTrayBtnHitTest != bPreviousHitTest)
        MinTrayBtnDraw(); // Windows   
    if (m_bMinTrayBtnHitTest)
       return HTMINTRAYBUTTON;
    return BASE::OnNcHitTest(point);
}

                      void CDialogMinTrayBtn      ::OnNcLButtonDown(unsigned int nHitTest, CPoint point)
{
    if ((GetStyle() & WS_DISABLED) || !MinTrayBtnIsEnabled() || !MinTrayBtnIsVisible() || !MinTrayBtnHitTest(point))
    {
        BASE::OnNcLButtonDown(nHitTest, point);
        return;
    }
    SetCapture();
    m_bMinTrayBtnCapture = TRUE;
    MinTrayBtnSetDown();
}

                      void CDialogMinTrayBtn      ::OnNcRButtonDown(unsigned int nHitTest, CPoint point)
{
    if ((GetStyle() & WS_DISABLED) || !MinTrayBtnIsVisible() || !MinTrayBtnHitTest(point))
        BASE::OnNcRButtonDown(nHitTest, point);
}

                      void CDialogMinTrayBtn      ::OnMouseMove(unsigned int nFlags, CPoint point)
{
    if ((GetStyle() & WS_DISABLED) || !m_bMinTrayBtnCapture)
    {
        BASE::OnMouseMove(nFlags, point);
        return;
    }

    ClientToScreen(&point);
    m_bMinTrayBtnHitTest = MinTrayBtnHitTest(point);
    if (m_bMinTrayBtnHitTest)
    {
        if (m_bMinTrayBtnUp)
            MinTrayBtnSetDown();
    }
    else
    {
        if (!m_bMinTrayBtnUp)
            MinTrayBtnSetUp();
    }
}

                      void CDialogMinTrayBtn      ::OnLButtonUp(unsigned int nFlags, CPoint point)
{
    if ((GetStyle() & WS_DISABLED) || !m_bMinTrayBtnCapture)
    {
        BASE::OnLButtonUp(nFlags, point);
        return;
    }

    ReleaseCapture();
    m_bMinTrayBtnCapture = FALSE;
    MinTrayBtnSetUp();

    ClientToScreen(&point);
    if (MinTrayBtnHitTest(point))
  SendMessage(WM_SYSCOMMAND, MP_MINIMIZETOTRAY, MAKELONG(point.x, point.y));
}

                      void CDialogMinTrayBtn      ::OnTimer(unsigned int nIDEvent)
{
    if (!IsWindowsClassicStyle() && nIDEvent == m_nMinTrayBtnTimerId)
    {
        // Visual   
        CPoint point;
        GetCursorPos(&point);
        int  bHitTest = MinTrayBtnHitTest(point);
        if (m_bMinTrayBtnHitTest != bHitTest)
        {
            m_bMinTrayBtnHitTest = bHitTest;
            MinTrayBtnDraw();
        }
    }
}

                      long *  CDialogMinTrayBtn      ::_OnThemeChanged()
{
 // BASE::OnThemeChanged();
 MinTrayBtnInitBitmap();
 return 0;
}

                      void CDialogMinTrayBtn      ::MinTrayBtnUpdatePosAndSize()
{
    unsigned long dwStyle = GetStyle();
    unsigned long dwExStyle = GetExStyle();

    int cyCaption = ((dwExStyle & WS_EX_TOOLWINDOW) == 0) ? GetSystemMetrics(SM_CYCAPTION) - 1 : GetSystemMetrics(SM_CYSMCAPTION) - 1;
    if (cyCaption < (8)              )
  cyCaption = (8)              ;

    CSize borderfixed(-GetSystemMetrics(SM_CXFIXEDFRAME), GetSystemMetrics(SM_CYFIXEDFRAME));
    CSize bordersize(-GetSystemMetrics(SM_CXSIZEFRAME), GetSystemMetrics(SM_CYSIZEFRAME));

    CRect rcWnd;
    GetWindowRect(&rcWnd);

 // get Windows' frame window button width/height (this may not always be a square!)
    CSize szBtn;
    szBtn.cy = cyCaption - ((2)                 * 2);
 if (IsWindowsClassicStyle())
  szBtn.cx = GetSystemMetrics(SM_CXSIZE) - 2;
 else
  szBtn.cx = GetSystemMetrics(SM_CXSIZE) - 4;

 // set our frame window button width/height...
 if (IsWindowsClassicStyle()){
  // ...this is same as Windows' buttons for non WinXP
  m_MinTrayBtnSize = szBtn;
 }
 else{
  // ...this is a square for WinXP
  m_MinTrayBtnSize.cx = szBtn.cy;
  m_MinTrayBtnSize.cy = szBtn.cy;
 }

 m_MinTrayBtnPos.x = rcWnd.Width() - ((2)                 + m_MinTrayBtnSize.cx + (2)                 + szBtn.cx);
    m_MinTrayBtnPos.y = (2)                ;

    if ((dwStyle & WS_THICKFRAME) != 0)
    {
        // resizable window
        m_MinTrayBtnPos += bordersize;
    }
    else
    {
        // fixed window
        m_MinTrayBtnPos += borderfixed;
    }

    if ( ((dwExStyle & WS_EX_TOOLWINDOW) == 0) && (((dwStyle & WS_MINIMIZEBOX) != 0) || ((dwStyle & WS_MAXIMIZEBOX) != 0)) )
    {
        if (IsWindowsClassicStyle())
            m_MinTrayBtnPos.x -= (szBtn.cx * 2) + (2)                ;
        else
            m_MinTrayBtnPos.x -= (szBtn.cx + (2)                ) * 2;
    }
}

                      void CDialogMinTrayBtn      ::MinTrayBtnShow()
{
    if (MinTrayBtnIsVisible())
       return;

    m_bMinTrayBtnVisible = TRUE;
    if (IsWindowVisible())
        RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW);
}

                      void CDialogMinTrayBtn      ::MinTrayBtnHide()
{
    if (!MinTrayBtnIsVisible())
       return;

    m_bMinTrayBtnVisible = FALSE;
    if (IsWindowVisible())
        RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW);
}

                      void CDialogMinTrayBtn      ::MinTrayBtnEnable()
{
    if (MinTrayBtnIsEnabled())
       return;

    m_bMinTrayBtnEnabled = TRUE;
    MinTrayBtnSetUp();
}

                      void CDialogMinTrayBtn      ::MinTrayBtnDisable()
{
    if (!MinTrayBtnIsEnabled())
       return;

    m_bMinTrayBtnEnabled = FALSE;
    if (m_bMinTrayBtnCapture)
    {
       ReleaseCapture();
       m_bMinTrayBtnCapture = FALSE;
    }
    MinTrayBtnSetUp();
}

                      void CDialogMinTrayBtn      ::MinTrayBtnDraw()
{
    if (!MinTrayBtnIsVisible())
       return;

    CDC *pDC= GetWindowDC();
    if (!pDC)
       return; // panic!

    if (IsWindowsClassicStyle())
    {
        CBrush black(GetSysColor(COLOR_BTNTEXT));
        CBrush gray(GetSysColor(COLOR_GRAYTEXT));
        CBrush gray2(GetSysColor(COLOR_BTNHILIGHT));

        // button
        if (m_bMinTrayBtnUp)
           pDC->DrawFrameControl(MinTrayBtnGetRect(), DFC_BUTTON, DFCS_BUTTONPUSH);
        else
           pDC->DrawFrameControl(MinTrayBtnGetRect(), DFC_BUTTON, DFCS_BUTTONPUSH | DFCS_PUSHED);

        // dot
        CRect btn = MinTrayBtnGetRect();
        btn.DeflateRect(2,2);
        unsigned int caption = MinTrayBtnGetSize().cy + ((2)                 * 2);
        unsigned int pixratio = (caption >= 14) ? ((caption >= 20) ? 2 + ((caption - 20) / 8) : 2) : 1;
        unsigned int pixratio2 = (caption >= 12) ? 1 + (caption - 12) / 8: 0;
        unsigned int dotwidth = (1 + pixratio * 3) >> 1;
        unsigned int dotheight = pixratio;
        CRect dot(CPoint(0,0), CPoint(dotwidth, dotheight));
        CSize spc((1 + pixratio2 * 3) >> 1, pixratio2);
        dot -= dot.Size();
        dot += btn.BottomRight();
        dot -= spc;
        if (!m_bMinTrayBtnUp)
           dot += CPoint(1,1);
        if (m_bMinTrayBtnEnabled)
        {
           pDC->FillRect(dot, &black);
        }
        else
        {
           pDC->FillRect(dot + CPoint(1,1), &gray2);
           pDC->FillRect(dot, &gray);
        }
    }
 else
 {
  // VisualStylesXP
  CRect btn = MinTrayBtnGetRect();
  int iState;
  if (!m_bMinTrayBtnEnabled)
   iState = TRAYBS_DISABLED;
  else if (GetStyle() & WS_DISABLED)
   iState = MINBS_NORMAL;
  else if (m_bMinTrayBtnHitTest)
   iState = (m_bMinTrayBtnCapture) ? MINBS_PUSHED : MINBS_HOT;
  else
   iState = MINBS_NORMAL;
  // inactive
  if (!m_bMinTrayBtnActive)
   iState += 4; // inactive state TRAYBS_Ixxx

  if (m_bmMinTrayBtnBitmap.m_hObject && _TransparentBlt)
  {
   // known
   CBitmap *pBmpOld;
   CDC dcMem;
   if (dcMem.CreateCompatibleDC(pDC) && (pBmpOld = dcMem.SelectObject(&m_bmMinTrayBtnBitmap)) != NULL)
   {
    _TransparentBlt(pDC->m_hDC, btn.left, btn.top, btn.Width(), btn.Height(), dcMem.m_hDC, 0, (21)               * (iState - 1), (21)             , (21)              , (RGB(255,0,255))      );
    dcMem.SelectObject(pBmpOld);
   }
  }
  else
  {
   // unknown
   HTHEME hTheme = g_xpStyle.OpenThemeData(m_hWnd,  "Window");
   if (hTheme)
   {
    btn.top += btn.Height() / 8;
    g_xpStyle.DrawThemeBackground(hTheme, pDC->m_hDC, WP_MINBUTTON , iState, &btn, NULL);
    g_xpStyle.CloseThemeData(hTheme);
   }
  }
 }

    ReleaseDC(pDC);
}

                      int  CDialogMinTrayBtn      ::MinTrayBtnHitTest(CPoint ptScreen) const
{
 CRect rcWnd;
 GetWindowRect(&rcWnd);
 // adjust 'ptScreen' with possible     window layout
 CRect rcWndOrg(rcWnd);
 CPoint ptScreenOrg(ptScreen);
 if (::MapWindowPoints(HWND_DESKTOP, m_hWnd, &rcWnd.TopLeft(), 2) == 0 ||
  ::MapWindowPoints(HWND_DESKTOP, m_hWnd, &ptScreen, 1) == 0)
 {
  // several bug reports about not working on    SP6 (?). in case of any problems with
  // 'MapWindowPoints' we fall back to old
  rcWnd = rcWndOrg;
  ptScreen = ptScreenOrg;
 }
 ptScreen.Offset(-rcWnd.TopLeft());

    CRect rcBtn = MinTrayBtnGetRect();
    rcBtn.InflateRect(0, (2)                );
    return rcBtn.PtInRect(ptScreen);
}

                      void CDialogMinTrayBtn      ::MinTrayBtnSetUp()
{
    m_bMinTrayBtnUp = TRUE;
    MinTrayBtnDraw();
}

                      void CDialogMinTrayBtn      ::MinTrayBtnSetDown()
{
    m_bMinTrayBtnUp = FALSE;
    MinTrayBtnDraw();
}

                      int  CDialogMinTrayBtn      ::IsWindowsClassicStyle() const
{
 return m_bMinTrayBtnWindowsClassicStyle;
}

                      void CDialogMinTrayBtn      ::SetWindowText(const char* lpszString)
{
 BASE::SetWindowText(lpszString);
 MinTrayBtnDraw();
}

                      int CDialogMinTrayBtn      ::GetVisualStylesXPColor() const
{
 if (IsWindowsClassicStyle())
  return -1;

 long  szwThemeFile[MAX_PATH];
 long  szwThemeColor[256];
 if (g_xpStyle.GetCurrentThemeName(szwThemeFile, MAX_PATH, szwThemeColor, 256, NULL, 0) != S_OK)
  return -1;
 long * p;
 if ((p = wcsrchr(szwThemeFile, _T('\\'))) == NULL)
  return -1;
 p++;
 if (_wcsicmp(p,  "LUNA.MSSTYLE "          ) != 0)
  return -1;
 if (_wcsicmp(szwThemeColor,  "NORMALCOLOR"         ) == 0)
  return 0                  ;
 if (_wcsicmp(szwThemeColor,  "METALLIC"                ) == 0)
  return 1                      ;
 if (_wcsicmp(szwThemeColor,  "HOMESTEAD"                ) == 0)
  return 2                       ;
 return -1;
}

                      int  CDialogMinTrayBtn      ::MinTrayBtnInitBitmap()
{
 m_bMinTrayBtnWindowsClassicStyle = !(g_xpStyle.IsThemeActive() && g_xpStyle.IsAppThemed());

 int nColor;
 m_bmMinTrayBtnBitmap.DeleteObject();
 if ((nColor = GetVisualStylesXPColor()) == -1)
  return FALSE;
 return m_bmMinTrayBtnBitmap.LoadBitmap(m_pszMinTrayBtnBmpName[nColor]);
}






 