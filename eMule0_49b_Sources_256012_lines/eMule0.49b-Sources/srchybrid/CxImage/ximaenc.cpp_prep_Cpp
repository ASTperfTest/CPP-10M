// xImaCodec.cpp : Encode Decode functions
/* 07/08/2001 v1.00 - Davide Pizzolato - www.xdp.it
 * CxImage version 6.0.0 02/Feb/2008
 */

void INCLUDEREPLACE(){CX_INCL("ximage.h");}


void INCLUDEREPLACE(){CX_INCL("ximajpg.h");}



void INCLUDEREPLACE(){CX_INCL("ximagif.h");}



void INCLUDEREPLACE(){CX_INCL("ximapng.h");}



void INCLUDEREPLACE(){CX_INCL("ximamng.h");}



void INCLUDEREPLACE(){CX_INCL("ximabmp.h");}



void INCLUDEREPLACE(){CX_INCL("ximaico.h");}



void INCLUDEREPLACE(){CX_INCL("ximatif.h");}



void INCLUDEREPLACE(){CX_INCL("ximatga.h");}



void INCLUDEREPLACE(){CX_INCL("ximapcx.h");}



void INCLUDEREPLACE(){CX_INCL("ximawbmp.h");}



void INCLUDEREPLACE(){CX_INCL("ximawmf.h");}



void INCLUDEREPLACE(){CX_INCL("ximajbg.h");}



void INCLUDEREPLACE(){CX_INCL("ximajas.h");}



void INCLUDEREPLACE(){CX_INCL("ximaska.h");}



void INCLUDEREPLACE(){CX_INCL("ximaraw.h");}


////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
bool CxImage::EncodeSafeCheck(CxFile *hFile)
{
 if (hFile==NULL) {
  strcpy(info.szLastError,CXIMAGE_ERR_NOFILE);
  return true;
 }

 if (pDib==NULL){
  strcpy(info.szLastError,CXIMAGE_ERR_NOIMAGE);
  return true;
 }
 return false;
}
////////////////////////////////////////////////////////////////////////////////
//#ifdef WIN32
//bool CxImage::Save(const long* filename, unsigned long imagetype)
//{
// FILE* hFile; //file handle to write the image
// if ((hFile=_wfopen(filename, "wb"))==NULL)  return false;
// bool bOK = Encode(hFile,imagetype);
// fclose(hFile);
// return bOK;
//}
//       //WIN32
////////////////////////////////////////////////////////////////////////////////
// For         support: char -> char 
/**
 * Saves to disk the image in a specific format.
 * \param filename: file name
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 */
bool CxImage::Save(const char  * filename, unsigned long imagetype)
{
 FILE* hFile; //file handle to write the image


 if ((hFile=_tfopen(filename,_T("wb")))==NULL)  return false; // For         support




 bool bOK = Encode(hFile,imagetype);
 fclose(hFile);
 return bOK;
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Saves to disk the image in a specific format.
 * \param hFile: file handle, open and enabled for writing.
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 */
bool CxImage::Encode(FILE *hFile, unsigned long imagetype)
{
 CxIOFile file(hFile);
 return Encode(&file,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Saves to memory buffer the image in a specific format.
 * \param buffer: output memory buffer pointer. Must be NULL,
 * the function allocates and fill the memory,
 * the application must free the buffer, see also FreeMemory().
 * \param size: output memory buffer size.
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 */
bool CxImage::Encode(unsigned char * &buffer, long &size, unsigned long imagetype)
{
 if (buffer!=NULL){
  strcpy(info.szLastError,"the buffer must be empty");
  return false;
 }
 CxMemFile file;
 file.Open();
 if(Encode(&file,imagetype)){
  buffer=file.GetBuffer();
  size=file.Size();
  return true;
 }
 return false;
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Saves to disk the image in a specific format.
 * \param hFile: file handle (CxMemFile or CxIOFile), with write access.
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 * \sa ENUM_CXIMAGE_FORMATS
 */
bool CxImage::Encode(CxFile *hFile, unsigned long imagetype)
{



 if (imagetype==CXIMAGE_FORMAT_BMP){
  CxImageBMP newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_ICO){
  CxImageICO newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_TIF){
  CxImageTIF newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_JPG){
  CxImageJPG newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_GIF){
  CxImageGIF newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_PNG){
  CxImagePNG newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_MNG){
  CxImageMNG newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_TGA){
  CxImageTGA newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_PCX){
  CxImagePCX newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_WBMP){
  CxImageWBMP newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_WMF){
  CxImageWMF newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_JBG){
  CxImageJBG newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (

  imagetype==CXIMAGE_FORMAT_JP2 ||


  imagetype==CXIMAGE_FORMAT_JPC ||


  imagetype==CXIMAGE_FORMAT_PGX ||


  imagetype==CXIMAGE_FORMAT_PNM ||


  imagetype==CXIMAGE_FORMAT_RAS ||

   false ){
  CxImageJAS newima;
  newima.Ghost(this);
  if (newima.Encode(hFile,imagetype)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }



 if (imagetype==CXIMAGE_FORMAT_SKA){
  CxImageSKA newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }



 if (imagetype==CXIMAGE_FORMAT_RAW){
  CxImageRAW newima;
  newima.Ghost(this);
  if (newima.Encode(hFile)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 strcpy(info.szLastError,"Encode: Unknown format");
 return false;
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Saves to disk or memory pagecount images, referenced by an array of CxImage pointers.
 * \param hFile: file handle.
 * \param pImages: array of CxImage pointers.
 * \param pagecount: number of images.
 * \param imagetype: can be                    or CXIMAGE_FORMAT_GIF.
 * \return true if everything is ok
 */
bool CxImage::Encode(FILE * hFile, CxImage ** pImages, int pagecount, unsigned long imagetype)
{
 CxIOFile file(hFile);
 return Encode(&file, pImages, pagecount,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Saves to disk or memory pagecount images, referenced by an array of CxImage pointers.
 * \param hFile: file handle (CxMemFile or CxIOFile), with write access.
 * \param pImages: array of CxImage pointers.
 * \param pagecount: number of images.
 * \param imagetype: can be CXIMAGE_FORMAT_TIF, CXIMAGE_FORMAT_GIF or CXIMAGE_FORMAT_ICO.
 * \return true if everything is ok
 */
bool CxImage::Encode(CxFile * hFile, CxImage ** pImages, int pagecount, unsigned long imagetype)
{

 if (imagetype==CXIMAGE_FORMAT_TIF){
  CxImageTIF newima;
  newima.Ghost(this);
  if (newima.Encode(hFile,pImages,pagecount)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_GIF){
  CxImageGIF newima;
  newima.Ghost(this);
  if (newima.Encode(hFile,pImages,pagecount)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_ICO){
  CxImageICO newima;
  newima.Ghost(this);
  if (newima.Encode(hFile,pImages,pagecount)){
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }

 strcpy(info.szLastError,"Multipage Encode, Unsupported operation for this format");
 return false;
}

////////////////////////////////////////////////////////////////////////////////
/**
 * exports the image into a      buffer, Useful for OpenGL applications.
 * \param buffer: output memory buffer pointer. Must be NULL,
 * the function allocates and fill the memory,
 * the application must free the buffer, see also FreeMemory().
 * \param size: output memory buffer size.
 * \param bFlipY: direction of   axis. default = false.
 * \return true if everything is ok
 */
bool CxImage::Encode2RGBA(unsigned char * &buffer, long &size, bool bFlipY)
{
 if (buffer!=NULL){
  strcpy(info.szLastError,"the buffer must be empty");
  return false;
 }
 CxMemFile file;
 file.Open();
 if(Encode2RGBA(&file,bFlipY)){
  buffer=file.GetBuffer();
  size=file.Size();
  return true;
 }
 return false;
}
////////////////////////////////////////////////////////////////////////////////
/**
 * exports the image into a      buffer, Useful for OpenGL applications.
 * \param hFile: file handle (CxMemFile or CxIOFile), with write access.
 * \param bFlipY: direction of   axis. default = false.
 * \return true if everything is ok
 */
bool CxImage::Encode2RGBA(CxFile *hFile, bool bFlipY)
{
 if (EncodeSafeCheck(hFile)) return false;

 for (long y1 = 0; y1 < head.biHeight; y1++) {
  long y = bFlipY ? head.biHeight - 1 - y1 : y1;
  for(long x = 0; x < head.biWidth; x++) {
   RGBQUAD color = BlindGetPixelColor(x,y);
   hFile->PutC(color.rgbRed);
   hFile->PutC(color.rgbGreen);
   hFile->PutC(color.rgbBlue);
   hFile->PutC(color.rgbReserved);
  }
 }
 return true;
}

////////////////////////////////////////////////////////////////////////////////
       //CXIMAGE_SUPPORT_ENCODE
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// For         support: char -> char 
/**
 * Reads from disk the image in a specific format.
 * - If decoding fails using the specified image format,
 * the function will try the automatic file format recognition.
 *
 * \param filename: file name
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 */
bool CxImage::Load(const char  * filename, unsigned long imagetype)
//bool CxImage::Load(const char * filename, unsigned long imagetype)
{
 /*FILE* hFile; //file handle to read the image
 if ((hFile=fopen(filename,"rb"))==NULL)  return false;
 bool bOK = Decode(hFile,imagetype);
 fclose(hFile);*/

 /* automatic file type recognition */
 bool bOK = false;
 if ( GetTypeIndexFromId(imagetype) ){
  FILE* hFile; //file handle to read the image


  if ((hFile=_tfopen(filename,_T("rb")))==NULL)  return false; // For         support




  bOK = Decode(hFile,imagetype);
  fclose(hFile);
  if (bOK) return bOK;
 }

 char szError[256];
 strcpy(szError,info.szLastError); //save the first error

 // if failed, try automatic recognition of the file...
 FILE* hFile;


 if ((hFile=_tfopen(filename,_T("rb")))==NULL)  return false; // For         support




 bOK = Decode(hFile,CXIMAGE_FORMAT_UNKNOWN);
 fclose(hFile);

 if (!bOK && imagetype > 0) strcpy(info.szLastError,szError); //restore the first error

 return bOK;
}
////////////////////////////////////////////////////////////////////////////////

//bool CxImage::Load(const long* filename, unsigned long imagetype)
//{
// /*FILE* hFile; //file handle to read the image
// if ((hFile=_wfopen(filename,  "rb"))==NULL)  return false;
// bool bOK = Decode(hFile,imagetype);
// fclose(hFile);*/
//
// /* automatic file type recognition */
// bool bOK = false;
// if ( GetTypeIndexFromId(imagetype) ){
//  FILE* hFile; //file handle to read the image
//  if ((hFile=_wfopen(filename, "rb"))==NULL)  return false;
//  bOK = Decode(hFile,imagetype);
//  fclose(hFile);
//  if (bOK) return bOK;
// }
//
// char szError[256];
// strcpy(szError,info.szLastError); //save the first error
//
// // if failed, try automatic recognition of the file...
// FILE* hFile; //file handle to read the image
// if ((hFile=_wfopen(filename, "rb"))==NULL)  return false;
// bOK = Decode(hFile,CXIMAGE_FORMAT_UNKNOWN);
// fclose(hFile);
//
// if (!bOK && imagetype > 0) strcpy(info.szLastError,szError); //restore the first error
//
// return bOK;
//}
////////////////////////////////////////////////////////////////////////////////
/**
 * Loads an image from the application resources.
 * \param hRes: the resource handle returned by FindResource().
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS.
 * \param hModule: NULL for internal resource, or external application/DLL hinstance returned by LoadLibray.
 * \return true if everything is ok
 */
bool CxImage::LoadResource(void* hRes, unsigned long imagetype, void *  hModule)
{
 unsigned long rsize=SizeofResource(hModule,hRes);
 void *  hMem=::LoadResource(hModule,hRes);
 if (hMem){
  char* lpVoid=(char*)LockResource(hMem);
  if (lpVoid){
   // FILE* fTmp=tmpfile(); doesn't work with network
   /*char tmpPath[MAX_PATH] = {0};
   char tmpFile[MAX_PATH] = {0};
   GetTempPath(MAX_PATH,tmpPath);
   GetTempFileName(tmpPath,"IMG",0,tmpFile);
   FILE* fTmp=fopen(tmpFile,"w+b");
   if (fTmp){
    fwrite(lpVoid,rsize,1,fTmp);
    fseek(fTmp,0,SEEK_SET);
    bool bOK = Decode(fTmp,imagetype);
    fclose(fTmp);
    DeleteFile(tmpFile);
    return bOK;
   }*/

   CxMemFile fTmp((unsigned char*)lpVoid,rsize);
   return Decode(&fTmp,imagetype);
  }
 } else strcpy(info.szLastError,"Unable to load resource!");
 return false;
}
       //WIN32
////////////////////////////////////////////////////////////////////////////////
/**
 * Constructor from file name, see Load()
 * \param filename: file name
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 */
//
// > filename: file name
// > imagetype: specify the image format (CXIMAGE_FORMAT_BMP,...)
// For         support: char -> char 
CxImage::CxImage(const char  * filename, unsigned long imagetype)
//CxImage::CxImage(const char * filename, unsigned long imagetype)
{
 Startup(imagetype);
 Load(filename,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Constructor from file handle, see Decode()
 * \param stream: file handle, with read access.
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 */
CxImage::CxImage(FILE * stream, unsigned long imagetype)
{
 Startup(imagetype);
 Decode(stream,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Constructor from CxFile object, see Decode()
 * \param stream: file handle (CxMemFile or CxIOFile), with read access.
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 */
CxImage::CxImage(CxFile * stream, unsigned long imagetype)
{
 Startup(imagetype);
 Decode(stream,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Constructor from memory buffer, see Decode()
 * \param buffer: memory buffer
 * \param size: size of buffer
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 */
CxImage::CxImage(unsigned char * buffer, unsigned long size, unsigned long imagetype)
{
 Startup(imagetype);
 CxMemFile stream(buffer,size);
 Decode(&stream,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Loads an image from memory buffer
 * \param buffer: memory buffer
 * \param size: size of buffer
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 */
bool CxImage::Decode(unsigned char * buffer, unsigned long size, unsigned long imagetype)
{
 CxMemFile file(buffer,size);
 return Decode(&file,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Loads an image from file handle.
 * \param hFile: file handle, with read access.
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 */
bool CxImage::Decode(FILE *hFile, unsigned long imagetype)
{
 CxIOFile file(hFile);
 return Decode(&file,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Loads an image from CxFile object
 * \param hFile: file handle (CxMemFile or CxIOFile), with read access.
 * \param imagetype: file format, see ENUM_CXIMAGE_FORMATS
 * \return true if everything is ok
 * \sa ENUM_CXIMAGE_FORMATS
 */
bool CxImage::Decode(CxFile *hFile, unsigned long imagetype)
{
 if (hFile == NULL){
  strcpy(info.szLastError,CXIMAGE_ERR_NOFILE);
  return false;
 }

 if (imagetype==CXIMAGE_FORMAT_UNKNOWN){
  unsigned long pos = hFile->Tell();

  { CxImageBMP newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageJPG newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageICO newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageGIF newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImagePNG newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageTIF newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageMNG newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageTGA newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImagePCX newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageWBMP newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageWMF newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageJBG newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageJAS newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageSKA newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }


  { CxImageRAW newima; newima.CopyInfo(*this); if (newima.Decode(hFile)) { Transfer(newima); return true; } else hFile->Seek(pos,SEEK_SET); }

 }


 if (imagetype==CXIMAGE_FORMAT_BMP){
  CxImageBMP newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_JPG){
  CxImageJPG newima;
  newima.CopyInfo(*this); //
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_ICO){
  CxImageICO newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   info.nNumFrames = newima.info.nNumFrames;
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_GIF){
  CxImageGIF newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   info.nNumFrames = newima.info.nNumFrames;
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_PNG){
  CxImagePNG newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_TIF){
  CxImageTIF newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   info.nNumFrames = newima.info.nNumFrames;
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_MNG){
  CxImageMNG newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   info.nNumFrames = newima.info.nNumFrames;
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_TGA){
  CxImageTGA newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_PCX){
  CxImagePCX newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_WBMP){
  CxImageWBMP newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype == CXIMAGE_FORMAT_WMF){
  CxImageWMF newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_JBG){
  CxImageJBG newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (

  imagetype==CXIMAGE_FORMAT_JP2 ||


  imagetype==CXIMAGE_FORMAT_JPC ||


  imagetype==CXIMAGE_FORMAT_PGX ||


  imagetype==CXIMAGE_FORMAT_PNM ||


  imagetype==CXIMAGE_FORMAT_RAS ||

   false ){
  CxImageJAS newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile,imagetype)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 if (imagetype==CXIMAGE_FORMAT_SKA){
  CxImageSKA newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }



 if (imagetype==CXIMAGE_FORMAT_RAW){
  CxImageRAW newima;
  newima.CopyInfo(*this);
  if (newima.Decode(hFile)){
   Transfer(newima);
   return true;
  } else {
   strcpy(info.szLastError,newima.GetLastError());
   return false;
  }
 }


 strcpy(info.szLastError,"Decode: Unknown or wrong format");
 return false;
}
////////////////////////////////////////////////////////////////////////////////
/**
 * Loads an image from CxFile object
 * \param hFile: file handle (CxMemFile or CxIOFile), with read access.
 * \param imagetype: file format, default = 0 (CXIMAGE_FORMAT_UNKNOWN)
 * \return : if imagetype is not 0, the function returns true when imagetype
 *  matches the file image format. If imagetype is 0, the function returns true
 *  when the file image format is recognized as a supported format.
 *  If the returned value is true, use GetHeight(), GetWidth() or GetType()
 *  to retrieve the basic image information.
 * \sa ENUM_CXIMAGE_FORMATS
 */
bool CxImage::CheckFormat(CxFile * hFile, unsigned long imagetype)
{
 SetType(CXIMAGE_FORMAT_UNKNOWN);
 SetEscape(-1);

 if (!Decode(hFile,imagetype))
  return false;

 if (GetType() == CXIMAGE_FORMAT_UNKNOWN || GetType() != imagetype)
  return false;

 return true;
}
////////////////////////////////////////////////////////////////////////////////
bool CxImage::CheckFormat(unsigned char * buffer, unsigned long size, unsigned long imagetype)
{
 if (buffer==NULL || size==NULL){
  strcpy(info.szLastError,"invalid or empty buffer");
  return false;
 }
 CxMemFile file(buffer,size);
 return CheckFormat(&file,imagetype);
}
////////////////////////////////////////////////////////////////////////////////
       //CXIMAGE_SUPPORT_DECODE
////////////////////////////////////////////////////////////////////////////////






 