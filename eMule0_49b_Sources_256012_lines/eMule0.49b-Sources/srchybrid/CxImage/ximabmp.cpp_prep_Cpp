/*
 * File: ximabmp.cpp
 * Purpose: Platform Independent     Image Class Loader and Writer
 * 07/Aug/2001 Davide Pizzolato - www.xdp.it
 * CxImage version 6.0.0 02/Feb/2008
 */

void INCLUDEREPLACE(){CX_INCL("ximabmp.h");}



void INCLUDEREPLACE(){CX_INCL("ximaiter.h");}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
bool CxImageBMP::Encode(CxFile * hFile)
{

 if (EncodeSafeCheck(hFile)) return false;

 BITMAPFILEHEADER hdr;

 hdr.bfType = 0x4d42;   // 'BM' WINDOWS_BITMAP_SIGNATURE
 hdr.bfSize = GetSize() + 14 /*sizeof(BITMAPFILEHEADER)*/;
 hdr.bfReserved1 = hdr.bfReserved2 = 0;
 hdr.bfOffBits = 14 /*sizeof(BITMAPFILEHEADER)*/ + head.biSize + GetPaletteSize();

 hdr.bfType = ntohs(hdr.bfType);
 hdr.bfSize = ntohl(hdr.bfSize);
 hdr.bfOffBits = ntohl(hdr.bfOffBits);


 if (GetNumColors()==0 && AlphaIsValid()){

  BITMAPINFOHEADER  infohdr;
  memcpy(&infohdr,&head,sizeof(BITMAPINFOHEADER));
  infohdr.biCompression = BI_RGB;
  infohdr.biBitCount = 32;
  unsigned long dwEffWidth = ((((infohdr.biBitCount * infohdr.biWidth) + 31) / 32) * 4);
  infohdr.biSizeImage = dwEffWidth * infohdr.biHeight;

  hdr.bfSize = infohdr.biSize + infohdr.biSizeImage + 14 /*sizeof(BITMAPFILEHEADER)*/;

  hdr.bfSize = ntohl(hdr.bfSize);
  bihtoh(&infohdr);

  // Write the file header
  hFile->Write(&hdr,min(14,sizeof(BITMAPFILEHEADER)),1);
  hFile->Write(&infohdr,sizeof(BITMAPINFOHEADER),1);
   //and DIB+ALPHA interlaced
  unsigned char *srcalpha = AlphaGetPointer();
  for(long y = 0; y < infohdr.biHeight; ++y){
   unsigned char *srcdib = GetBits(y);
   for(long x = 0; x < infohdr.biWidth; ++x){
    hFile->Write(srcdib,3,1);
    hFile->Write(srcalpha,1,1);
    srcdib += 3;
    ++srcalpha;
   }
  }

 } else
       //CXIMAGE_SUPPORT_ALPHA
 {
  // Write the file header
  hFile->Write(&hdr,min(14,sizeof(BITMAPFILEHEADER)),1);
  //copy attributes
  memcpy(pDib,&head,sizeof(BITMAPINFOHEADER));
  bihtoh((BITMAPINFOHEADER*)pDib);
  // Write the     header and the pixels
  hFile->Write(pDib,GetSize(),1);
  bihtoh((BITMAPINFOHEADER*)pDib);
 }
 return true;
}
////////////////////////////////////////////////////////////////////////////////
       //CXIMAGE_SUPPORT_ENCODE
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
bool CxImageBMP::Decode(CxFile * hFile)
{
 if (hFile == NULL) return false;

 BITMAPFILEHEADER   bf;
 unsigned long off = hFile->Tell(); //
  cx_try {
 if (hFile->Read(&bf,min(14,sizeof(bf)),1)==0) cx_throw("Not a BMP");

 bf.bfSize = ntohl(bf.bfSize);
 bf.bfOffBits = ntohl(bf.bfOffBits);

    if (bf.bfType != BFT_BITMAP) { //do we have a    HEADER?
        bf.bfOffBits = 0L;
        hFile->Seek(off,SEEK_SET);
    }

 BITMAPINFOHEADER bmpHeader;
 if (!DibReadBitmapInfo(hFile,&bmpHeader)) cx_throw("Error reading     info");
 unsigned long dwCompression=bmpHeader.biCompression;
 unsigned long dwBitCount=bmpHeader.biBitCount; //preserve for              compression
 bool bIsOldBmp = bmpHeader.biSize == sizeof(BITMAPCOREHEADER);

 bool bTopDownDib = bmpHeader.biHeight<0; //           check if it's a top-down bitmap
 if (bTopDownDib) bmpHeader.biHeight=-bmpHeader.biHeight;

 if (info.nEscape == -1) {
  // Return output dimensions only
  head.biWidth = bmpHeader.biWidth;
  head.biHeight = bmpHeader.biHeight;
  info.dwType = CXIMAGE_FORMAT_BMP;
  cx_throw("output dimensions returned");
 }

 if (!Create(bmpHeader.biWidth,bmpHeader.biHeight,bmpHeader.biBitCount,CXIMAGE_FORMAT_BMP))
  cx_throw("");

 SetXDPI((long) floor(bmpHeader.biXPelsPerMeter * 254.0 / 10000.0 + 0.5));
 SetYDPI((long) floor(bmpHeader.biYPelsPerMeter * 254.0 / 10000.0 + 0.5));

 if (info.nEscape) cx_throw("Cancelled"); //       - cancel decoding

    RGBQUAD *pRgb = GetPalette();
    if (pRgb){
        if (bIsOldBmp){
             // convert a old color to a neW
             // color
            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader) * sizeof(RGBTRIPLE),1);
            for (int i=DibNumColors(&head)-1; i>=0; i--){
                pRgb[i].rgbRed      = ((RGBTRIPLE *)pRgb)[i].rgbtRed;
                pRgb[i].rgbBlue     = ((RGBTRIPLE *)pRgb)[i].rgbtBlue;
                pRgb[i].rgbGreen    = ((RGBTRIPLE *)pRgb)[i].rgbtGreen;
                pRgb[i].rgbReserved = (unsigned char)0;
            }
        } else {
            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader) * sizeof(RGBQUAD),1);
   //force rgbReserved=0, to avoid problems with some WinXp bitmaps
   for (unsigned int i=0; i<head.biClrUsed; i++) pRgb[i].rgbReserved=0;
        }
    }

 if (info.nEscape) cx_throw("Cancelled"); //       - cancel decoding

 switch (dwBitCount) {
  case 32 :
   unsigned long bfmask[3];
   if (dwCompression == BI_BITFIELDS)
   {
    hFile->Read(bfmask, 12, 1);
   } else {
    bfmask[0]=0x00FF0000;
    bfmask[1]=0x0000FF00;
    bfmask[2]=0x000000FF;
   }
   if (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);
   if (dwCompression == BI_BITFIELDS || dwCompression == BI_RGB){
    long imagesize=4*head.biHeight*head.biWidth;
    unsigned char* buff32=(unsigned char*)malloc(imagesize);
    if (buff32){
     hFile->Read(buff32, imagesize,1); // read in the pixels


     if (dwCompression == BI_RGB){
      AlphaCreate();
      if (AlphaIsValid()){
       bool bAlphaOk = false;
       unsigned char* p;
       for (long y=0; y<head.biHeight; y++){
        p = buff32 + 3 + head.biWidth * 4 * y;
        for (long x=0; x<head.biWidth; x++){
         if (*p) bAlphaOk = true;
         AlphaSet(x,y,*p);
         p+=4;
        }
       }
       // fix if alpha pixels are all zero
       if (!bAlphaOk) AlphaInvert();
      }
     }
       //CXIMAGE_SUPPORT_ALPHA

     Bitfield2RGB(buff32,bfmask[0],bfmask[1],bfmask[2],32);
     free(buff32);
    } else cx_throw("can't allocate memory");
   } else cx_throw("unknown compression");
   break;
  case 24 :
   if (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);
   if (dwCompression == BI_RGB){
    hFile->Read(info.pImage, head.biSizeImage,1); // read in the pixels
   } else cx_throw("unknown compression");
   break;
  case 16 :
  {
   unsigned long bfmask[3];
   if (dwCompression == BI_BITFIELDS)
   {
    hFile->Read(bfmask, 12, 1);
   } else {
    bfmask[0]=0x7C00; bfmask[1]=0x3E0; bfmask[2]=0x1F; //RGB555
   }
   // bf.bfOffBits required after the bitfield mask
   if (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);
   // read in the pixels
   hFile->Read(info.pImage, head.biHeight*((head.biWidth+1)/2)*4,1);
   // transform into    
   Bitfield2RGB(info.pImage,bfmask[0],bfmask[1],bfmask[2],16);
   break;
  }
  case 8 :
  case 4 :
  case 1 :
  if (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);
  switch (dwCompression) {
   case BI_RGB :
    hFile->Read(info.pImage, head.biSizeImage,1); // read in the pixels
    break;
   case BI_RLE4 :
   {
    unsigned char status_byte = 0;
    unsigned char second_byte = 0;
    int scanline = 0;
    int bits = 0;
    int  low_nibble = FALSE;
    CImageIterator iter(this);

    for (int  bContinue = TRUE; bContinue && hFile->Read(&status_byte, sizeof(unsigned char), 1);) {

     switch (status_byte) {
      case RLE_COMMAND :
       hFile->Read(&status_byte, sizeof(unsigned char), 1);
       switch (status_byte) {
        case RLE_ENDOFLINE :
         bits = 0;
         scanline++;
         low_nibble = FALSE;
         break;
        case RLE_ENDOFBITMAP :
         bContinue=FALSE;
         break;
        case RLE_DELTA :
        {
         // read the delta values
         unsigned char delta_x;
         unsigned char delta_y;
         hFile->Read(&delta_x, sizeof(unsigned char), 1);
         hFile->Read(&delta_y, sizeof(unsigned char), 1);
         // apply them
         bits       += delta_x / 2;
         scanline   += delta_y;
         break;
        }
        default :
         hFile->Read(&second_byte, sizeof(unsigned char), 1);
         unsigned char *sline = iter.GetRow(scanline);
         for (int i = 0; i < status_byte; i++) {
          if ((unsigned char*)(sline+bits) < (unsigned char*)(info.pImage+head.biSizeImage)){
           if (low_nibble) {
            if (i&1)
             *(sline + bits) |= (second_byte & 0x0f);
            else
             *(sline + bits) |= (second_byte & 0xf0)>>4;
            bits++;
           } else {
            if (i&1)
             *(sline + bits) = (unsigned char)(second_byte & 0x0f)<<4;
            else
             *(sline + bits) = (unsigned char)(second_byte & 0xf0);
           }
          }

          if ((i & 1) && (i != (status_byte - 1)))
           hFile->Read(&second_byte, sizeof(unsigned char), 1);

          low_nibble = !low_nibble;
         }
         if ((((status_byte+1) >> 1) & 1 ) == 1)
          hFile->Read(&second_byte, sizeof(unsigned char), 1);
         break;
       };
       break;
      default :
      {
       unsigned char *sline = iter.GetRow(scanline);
       hFile->Read(&second_byte, sizeof(unsigned char), 1);
       for (unsigned i = 0; i < status_byte; i++) {
        if ((unsigned char*)(sline+bits) < (unsigned char*)(info.pImage+head.biSizeImage)){
         if (low_nibble) {
          if (i&1)
           *(sline + bits) |= (second_byte & 0x0f);
          else
           *(sline + bits) |= (second_byte & 0xf0)>>4;
          bits++;
         } else {
          if (i&1)
           *(sline + bits) = (unsigned char)(second_byte & 0x0f)<<4;
          else
           *(sline + bits) = (unsigned char)(second_byte & 0xf0);
         }
        }
        low_nibble = !low_nibble;
       }
      }
      break;
     };
    }
    break;
   }
   case BI_RLE8 :
   {
    unsigned char status_byte = 0;
    unsigned char second_byte = 0;
    int scanline = 0;
    int bits = 0;
    CImageIterator iter(this);

    for (int  bContinue = TRUE; bContinue && hFile->Read(&status_byte, sizeof(unsigned char), 1);) {
     switch (status_byte) {
      case RLE_COMMAND :
       hFile->Read(&status_byte, sizeof(unsigned char), 1);
       switch (status_byte) {
        case RLE_ENDOFLINE :
         bits = 0;
         scanline++;
         break;
        case RLE_ENDOFBITMAP :
         bContinue=FALSE;
         break;
        case RLE_DELTA :
        {
         // read the delta values
         unsigned char delta_x;
         unsigned char delta_y;
         hFile->Read(&delta_x, sizeof(unsigned char), 1);
         hFile->Read(&delta_y, sizeof(unsigned char), 1);
         // apply them
         bits     += delta_x;
         scanline += delta_y;
         break;
        }
        default :
         hFile->Read((void *)(iter.GetRow(scanline) + bits), sizeof(unsigned char) * status_byte, 1);
         // align run length to even number of bytes
         if ((status_byte & 1) == 1)
          hFile->Read(&second_byte, sizeof(unsigned char), 1);
         bits += status_byte;
         break;
       };
       break;
      default :
       unsigned char *sline = iter.GetRow(scanline);
       hFile->Read(&second_byte, sizeof(unsigned char), 1);
       for (unsigned i = 0; i < status_byte; i++) {
        if ((unsigned long)bits<info.dwEffWidth){
         *(sline + bits) = second_byte;
         bits++;
        } else {
         break;
        }
       }
       break;
     };
    }
    break;
   }
   default :
    cx_throw("compression type not supported");
  }
 }

 if (bTopDownDib) Flip(); //

  } cx_catch {
 if (strcmp(message,"")) strncpy(info.szLastError,message,255);
 if (info.nEscape == -1 && info.dwType == CXIMAGE_FORMAT_BMP) return true;
 return false;
  }
    return true;
}
////////////////////////////////////////////////////////////////////////////////
/*  ReadDibBitmapInfo()
 *
 *  Will read a file in     format and return a global void * to its
 *  BITMAPINFO.  This function will work with both "old" and "neW"
 *  bitmap formats, but will always return a "neW" BITMAPINFO.
 */
bool CxImageBMP::DibReadBitmapInfo(CxFile* fh, BITMAPINFOHEADER *pdib)
{
 if ((fh==NULL)||(pdib==NULL)) return false;

    if (fh->Read(pdib,sizeof(BITMAPINFOHEADER),1)==0) return false;

 bihtoh(pdib);

    switch (pdib->biSize) // what type of bitmap info is this?
    {
        case sizeof(BITMAPINFOHEADER):
            break;

  case 64: //sizeof(OS2_BMP_HEADER):
            fh->Seek((long)(64 - sizeof(BITMAPINFOHEADER)),SEEK_CUR);
   break;

        case sizeof(BITMAPCOREHEADER):
  {
            BITMAPCOREHEADER bc = *(BITMAPCOREHEADER*)pdib;
            pdib->biSize               = bc.bcSize;
            pdib->biWidth              = (unsigned long)bc.bcWidth;
            pdib->biHeight             = (unsigned long)bc.bcHeight;
            pdib->biPlanes             =  bc.bcPlanes;
            pdib->biBitCount           =  bc.bcBitCount;
            pdib->biCompression        = BI_RGB;
            pdib->biSizeImage          = 0;
            pdib->biXPelsPerMeter      = 0;
            pdib->biYPelsPerMeter      = 0;
            pdib->biClrUsed            = 0;
            pdib->biClrImportant       = 0;

   fh->Seek((long)(sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER)), SEEK_CUR);
  }
            break;
        default:
   //give a last chance
    if (pdib->biSize>(sizeof(BITMAPINFOHEADER))&&
    (pdib->biSizeImage>=(unsigned long)(pdib->biHeight*((((pdib->biBitCount*pdib->biWidth)+31)/32)*4)))&&
    (pdib->biPlanes==1)&&(pdib->biClrUsed==0))
    {
              if (pdib->biCompression==BI_RGB)
      fh->Seek((long)(pdib->biSize - sizeof(BITMAPINFOHEADER)),SEEK_CUR);
     break;
    }
   return false;
    }

    FixBitmapInfo(pdib);

    return true;
}
////////////////////////////////////////////////////////////////////////////////
       //CXIMAGE_SUPPORT_DECODE
////////////////////////////////////////////////////////////////////////////////
        // CXIMAGE_SUPPORT_BMP
////////////////////////////////////////////////////////////////////////////////






 