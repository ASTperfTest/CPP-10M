//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

/*---------------------------------------------------------------------
*
*  Some code in this file has been copied from a ping demo that was
*  created by Bob Quinn, 1997          http://www.sockets.com
*
* As some general documenation about how the ping is implemented,
* here is the description Bob Quinn wrote about the ping demo.
*
* Description:
*  Prototypes and typedefs Microsoft's ICMP.DLL functions & structs
*  for access to Internet Control Message Protocol.  This is capable
*  of doing "ping or "traceroute", although beware that Microsoft
*  discourages the use of these APIs.
*
* Some Background:
*
* The standard Berkeley Sockets          socket type, is normally used
* to create ping (echo request/reply), and sometimes traceroute applications
* (the original traceroute application from Van Jacobson used UDP, rather
* than ICMP). Microsoft's WinSock version 2 implementations for     and
* Windows 95 support raw sockets, but none of their WinSock version 1.1
* implementations (WFWG, NT3.x or standard Windows 95) did.
*
* Microsoft has their own     for an ICMP.DLL that their ping and tracert
* applications use (by the way, they are both non-GUI text-based console
* applications. This is a proprietary API, and all function calls that
* involve network functions operate in blocking mode. They still include
* it with WinSock 2 implementations.
*
* There is little documentation available (I first found it in the Win32
* SDK in \MSTOOLS\ICMP, and it exists on the MS&nbsp;Developers' Network
* CD-ROM now, also). Microsoft disclaims this     about as strongly as
* possible.  The README.TXT that accompanies it says:
*
* [DISCLAIMER]
*
* We have had requests in the past to expose the functions exported from
* icmp.dll. The files in this directory are provided for your convenience
* in building applications which make use of ICMPSendEcho(). Notice that
* the functions in icmp.dll are not considered part of the Win32     and
* will not be supported in future releases. Once we have a more complete
* solution in the operating system, this DLL, and the functions it exports,
* will be dropped.
*
* [DOCUMENTATION]
*
* The function sends an      echo request to the specified
* destination    address and returns any replies received within the timeout
* specified. The     is synchronous, requiring the process to spawn a thread
* before calling the     to avoid blocking. An open IcmpHandle is required
* for the request to complete. and IcmpCloseHandle()
* functions are used to create and destroy the context handle.</P>
*/
































        void *        IcmpCreateFile(void) = "CX_TYPEDEF"; /* INVALID_HANDLE_VALUE on error */
        int         IcmpCloseHandle(void * IcmpHandle) = "CX_TYPEDEF"; /* FALSE on error */

/* Note 2: For the most part, you can refer to     791 for detials
* on how to fill in values for the    option information structure.
*/
          class ip_option_information {
    u_char Ttl;  /* Time To Live (used for traceroute) */
    u_char Tos;  /* Type Of Service (usually 0) */
    u_char Flags;  /* IP header flags (usually 0) */
    u_char OptionsSize; /* Size of options data (usually 0, max 40) */
    u_char FAR *OptionsData;   /* Options data buffer */
};       ip_option_information IPINFO, *PIPINFO, FAR *LPIPINFO = "CX_TYPEDEF";

/* Note 1: The Reply Buffer will have an array of ICMP_ECHO_REPLY
* structures, followed by options and the data in      echo reply
* datagram received. You must have room for at least one ICMP
* echo reply structure, plus 8 bytes for an      header.
*/
          class icmp_echo_reply {
    u_long Address;  /* source address */
    u_long Status; /* IP status value (see below) */
    u_long RTTime; /* Round Trip Time in milliseconds */
    u_short DataSize;  /* reply data size */
    u_short Reserved;  /* */
    void FAR *Data;  /* reply data buffer */
           ip_option_information Options; /* reply options */
};       icmp_echo_reply ICMPECHO, *PICMPECHO, FAR *LPICMPECHO = "CX_TYPEDEF";

        unsigned long        IcmpSendEcho(
    void * IcmpHandle,  /* handle returned from IcmpCreateFile() */
    u_long DestAddress, /* destination    address (in network order) */
    void*  RequestData, /* pointer to buffer to send */
    unsigned short RequestSize, /* length of data in buffer */
    LPIPINFO RequestOptns,  /* see Note 2 */
    void*  ReplyBuffer, /* see Note 1 */
    unsigned long ReplySize,  /* length of reply (must allow at least 1 reply) */
    unsigned long Timeout  /* time in milliseconds to wait for reply */
);

 class PingStatus {
    bool success;
    unsigned long status;
    float delay;
    uint32 destinationAddress;
    uint32 ttl;

    unsigned long error;
};

// UDPing - required constants and structures -->

// ICMP packet types





// Minimum      packet size, in bytes



// The following two structures need to be packed tightly, but unlike
// Borland C++, Microsoft C++ does not do this by default.



// The    header
 class IPHeader {
    unsigned char h_len:4;           // Length of the header in dwords
    unsigned char version:4;         // Version of   
    unsigned char tos;               // Type of service
    unsigned short total_len;       // Length of the packet in dwords
    unsigned short ident;           // unique identifier
    unsigned short flags;           // Flags
    unsigned char ttl;               // Time to live
    unsigned char proto;             // Protocol
    unsigned short checksum;        // IP checksum
    unsigned long source_ip;
    unsigned long dest_ip;
};

// ICMP header for              and            replys
 class ICMPHeader {
    unsigned char type;          // ICMP packet type
    unsigned char code;          // Type sub code
    unsigned short checksum;
    unsigned char unused[4];     // may be used for various data, we don't need it
    IPHeader hdrsent;   // original    header
    union {
        unsigned char data[8];   // data next to   
        struct {
            unsigned short src_port;
            unsigned short dest_port;
            unsigned short length;
            unsigned short checksum;
        } UDP;
    };
};







// UDPing - required constants and structures end <--


class Pinger {
public:
    Pinger();
    ~Pinger();

    PingStatus Ping(uint32 lAddr, uint32 ttl = 64         , bool doLog = false, bool useUdp = false);

    void PIcmpErr(int nICMPErr);

private:
    void DisplayErr(int nWSAErr);

    bool udpStarted;

    IcmpCreateFile* lpfnIcmpCreateFile;
    IcmpCloseHandle* lpfnIcmpCloseHandle;
    IcmpSendEcho* lpfnIcmpSendEcho;
    PingStatus Pinger::PingUDP(uint32 lAddr, uint32 ttl, bool doLog);
    PingStatus Pinger::PingICMP(uint32 lAddr, uint32 ttl, bool doLog);

    void * hICMP;
    void *  hICMP_DLL; // PENDING: was void *
    IPINFO stIPInfo;

    SOCKET us;          // UDP socket to send requests
    SOCKET is;          // raw      socket to catch responses
};






 