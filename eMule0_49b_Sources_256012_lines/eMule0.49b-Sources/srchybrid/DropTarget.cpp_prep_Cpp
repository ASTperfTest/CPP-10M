//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
void INCLUDEREPLACE(){CX_INCL("stdafx.h");}
void INCLUDEREPLACE(){CX_INCL("emule.h");}
void INCLUDEREPLACE(){CX_INCL("emuledlg.h");}
void INCLUDEREPLACE(){CX_INCL("DropTarget.h");}
void INCLUDEREPLACE(){CX_INCL("intshcut.h");}




static char THIS_FILE[] =  "FILE" ;












int  IsUrlSchemeSupportedA(const char* pszUrl)
{
 static const  class SCHEME
 {
  const char* pszPrefix;
  int iLen;
 } _aSchemes[] =
 {

  { "ed2k://", ARRSIZE("ed2k://")-1 }

 };

 for (int i = 0; i < ARRSIZE(_aSchemes); i++)
 {
  if (strncmp(pszUrl, _aSchemes[i].pszPrefix, _aSchemes[i].iLen) == 0)
   return TRUE;
 }
 return FALSE;
}

int  IsUrlSchemeSupportedW(const long* pszUrl)
{
 static const  class SCHEME
 {
  const long* pszPrefix;
  int iLen;
 } _aSchemes[] =
 {

  {  "ed2k://", ARRSIZE( "ed2k://")-1 }

 };

 for (int i = 0; i < ARRSIZE(_aSchemes); i++)
 {
  if (wcsncmp(pszUrl, _aSchemes[i].pszPrefix, _aSchemes[i].iLen) == 0)
   return TRUE;
 }
 return FALSE;
}

// GetFileExtA -- ANSI version
//
// This function is thought to be used only for filenames which have been
// validated by 'GetFullPathName' or similar functions.
const char* GetFileExtA(const char* pszPathA, int iLen /*= -1*/)
{
 // Just search the last '.'-character which comes after an optionally
 // available last '\'-char.
 int iPos = iLen >= 0 ? iLen : strlen(pszPathA);
 while (iPos-- > 0)
 {
  if (pszPathA[iPos] == '.')
   return &pszPathA[iPos];
  if (pszPathA[iPos] == '\\')
   break;
 }

 return NULL;
}

// GetFileExtW -- Unicode version
//
// This function is thought to be used only for filenames which have been
// validated by 'GetFullPathName' or similar functions.
const long* GetFileExtW(const long* pszPathW, int iLen /*= -1*/)
{
 // Just search the last '.'-character which comes after an optionally
 // available last '\'-char.
 int iPos = iLen >= 0 ? iLen : wcslen(pszPathW);
 while (iPos-- > 0)
 {
  if (pszPathW[iPos] ==  '.')
   return &pszPathW[iPos];
  if (pszPathW[iPos] ==  '\\')
   break;
 }

 return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// PASTEURLDATA

 class PASTEURLDATA
{
 PASTEURLDATA()
 {
  m_eType = (DataType)-1;
  m_dwFlags = 0;
 }
 PASTEURLDATA(char* bstrText, unsigned long dwFlags = 0)
 {
  m_eType = HTMLText;
  m_bstrURLs = bstrText;
  m_dwFlags = dwFlags;
 }
 PASTEURLDATA(IDispatch *pIDispatch, unsigned long dwFlags = 0)
 {
  m_eType = Document;
  m_pIDispDoc = pIDispatch;
  m_dwFlags = dwFlags;
 }

 enum DataType
 {
  Text,
  HTMLText,
  Document
 } m_eType;
 unsigned long m_dwFlags;
 union
 {
  char* m_bstrURLs;
  IDispatch *m_pIDispDoc;
 };
};


//////////////////////////////////////////////////////////////////////////////
// CMainFrameDropTarget

CMainFrameDropTarget::CMainFrameDropTarget()
{
 m_bDropDataValid = FALSE;

 m_cfHTML = (CLIPFORMAT)RegisterClipboardFormat(_T("HTML Format"));
 ASSERT(m_cfHTML != 0);

 m_cfShellURL = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLURL);
 ASSERT(m_cfShellURL != 0);
}

unsigned long CMainFrameDropTarget::PasteHTMLDocument(IHTMLDocument2* doc, PASTEURLDATA* /*pPaste*/)
{
 unsigned long hrPasteResult = S_FALSE; // default: nothing was pasted
 int iURLElements = 0;

 // get_links       all        and        elements -> that's *wrong* it also contains all     elements!
 // get_anchors       all     elements which have a      or    value!

 //
 // Links
 //
 CComPtr                         links;
 if (doc->get_links(&links) == S_OK)
 {
  long lLinks;
  if (links->get_length(&lLinks) == S_OK && lLinks > 0)
  {
   iURLElements += lLinks;
   CComVariant vaIndex((long)0);
   CComVariant vaNull((long)0);
   for (long i = 0; i < lLinks; i++)
   {
    vaIndex.lVal = i;
    CComPtr            item;
    if (links->item(vaIndex, vaNull, &item) == S_OK)
    {
     CComPtr                     anchor;
     if (SUCCEEDED(item->QueryInterface(&anchor)))
     {
      CComBSTR bstrHref;
      if (anchor->get_href(&bstrHref) == S_OK && bstrHref.Length() > 0 && IsUrlSchemeSupportedW(bstrHref))
      {
       theApp.emuledlg->ProcessED2KLink(CString(bstrHref));
       hrPasteResult = S_OK;
      }
      anchor.Release(); // conserve memory
     }
    }
   }
  }
  links.Release(); // conserve memory
 }

 //
 // Text
 //
 // The explicit handling of text is needed, if we're looking at contents which were copied
 // to the clipboard in      format -- although it is simple raw text!! This situation applies,
 // if the user opens the "View Partial Source" HTML window for some selected      contents,
 // and copies some to the clipboard. In that case we'll get the raw text
 // as      contents!!!
 //
 // PROBLEM: We can *not* always process the      elements (anchors, ...) *and* the inner text.
 // The following would lead to the adding of the same     twice
 // because the     is noted as a HREF *and* as the inner text.
 //
 //    <A href="http://www.domain.com/image.gif">http://www.domain.com/image.gif</A></P>
 //
 // So, in practice, the examination of the 'innerText' is only done, if there were no other
 // HTML elements in the document.
 //
 if (iURLElements == 0)
 {
  CComPtr               el;
  if (doc->get_body(&el) == S_OK)
  {
   CComBSTR bstr;
   if (el->get_innerText(&bstr) == S_OK && bstr.Length() > 0)
   {
    const long* pwsz = bstr;
    while (*pwsz !=  '\0' && iswspace(*pwsz)) // Skip white spaces
     pwsz++;

    // PROBLEM: The 'innerText' does not contain any      tags, but it *MAY* contain
    // HTML comments like "<!--StartFragment-->...<!--EndFragment-->". Those
    // tags have to be explicitly parsed to get the real raw text contents.
    // Those Start- and End-tags are available if the text is copied into the clipboard
    // from a      window which was open with "View Partial Source"!
    static const long  _wszStartFrag[] =  "<!--StartFragment-->";
    if (wcsncmp(pwsz, _wszStartFrag, ARRSIZE(_wszStartFrag)-1) == 0)
    {
     pwsz += ARRSIZE(_wszStartFrag)-1;

     // If there's a Start-tag, search for an End-tag.
     static const long  _wszEndFrag[] =  "<!--EndFragment-->";
     long*  pwszEnd = (long* )bstr + bstr.Length();
     pwszEnd -= ARRSIZE(_wszEndFrag)-1;
     if (pwszEnd >= pwsz)
     {
      if (wcsncmp(pwszEnd, _wszEndFrag, ARRSIZE(_wszEndFrag)-1) == 0)
       *pwszEnd =  '\0'; // Ugly but efficient, terminate the char*!
     }
    }

    // Search all white-space terminated strings and check for a valid URL-scheme
    while (*pwsz !=  '\0')
    {
     while (*pwsz !=  '\0' && iswspace(*pwsz)) // Skip white spaces
      pwsz++;

     if (IsUrlSchemeSupportedW(pwsz))
     {
      const long* pwszEnd = pwsz;
      while (*pwszEnd !=  '\0' && !iswspace(*pwszEnd)) // Search next white
       pwszEnd++;
      int iLen = pwszEnd - pwsz;
      if (iLen > 0)
      {
       CString strURL(pwsz, iLen);
       theApp.emuledlg->ProcessED2KLink(strURL);
       hrPasteResult = S_OK;
       pwsz += iLen;
      }
     }
     else
     {
      while (*pwsz !=  '\0' && !iswspace(*pwsz)) // Search next white
       pwsz++;
     }

     while (*pwsz !=  '\0' && iswspace(*pwsz)) // Skip white spaces
      pwsz++;
    }
   }
  }
 }

 return hrPasteResult;
}

unsigned long CMainFrameDropTarget::PasteHTML(PASTEURLDATA* pPaste)
{
 unsigned long hrPasteResult = S_FALSE; // default: nothing was pasted
 if (pPaste->m_bstrURLs[0] !=  '\0')
 {
  unsigned long hr;
  CComPtr                 doc;
  if (SUCCEEDED(hr = doc.CoCreateInstance(CLSID_HTMLDocument, NULL)))
  {
   SAFEARRAY* psfHtmlLines = SafeArrayCreateVector(VT_VARIANT, 0, 1);
   if (psfHtmlLines != NULL)
   {
    VARIANT* pva;
    if (SafeArrayAccessData(psfHtmlLines, (void**)&pva) == S_OK)
    {
     pva->vt = VT_BSTR;
     pva->bstrVal = pPaste->m_bstrURLs;
     VERIFY( SafeArrayUnaccessData(psfHtmlLines) == S_OK );

     // Build the      document
     //
     // NOTE: 'bstrHTM ' may contain a complete      or
     // just a fragment (without       ,       , ... tags).
     //
     // WOW! We even can pump      stuff into the
     // document (e.g. contents without       ,       ...) *and* we are capable
     // of accessing the      object
     if ((hr = doc->write(psfHtmlLines)) == S_OK)
      hrPasteResult = PasteHTMLDocument(doc, pPaste);
     else
      hrPasteResult = E_FAIL;
    }
    else
     hrPasteResult = E_OUTOFMEMORY;

    // Destroy the array *and* all of the
    if (SafeArrayAccessData(psfHtmlLines, (void**)pva) == S_OK)
    {
     // 'Remove' the char* which was specified before, to *NOT* have it deleted by 'SafeArrayDestroy'
     pva->vt = VT_NULL;
     pva->bstrVal = NULL;
     VERIFY( SafeArrayUnaccessData(psfHtmlLines) == S_OK );
    }
    VERIFY( SafeArrayDestroy(psfHtmlLines) == S_OK );
   }
   else
    hrPasteResult = E_OUTOFMEMORY;
  }
  else
   hrPasteResult = E_FAIL;
 }
 return hrPasteResult;
}

unsigned long CMainFrameDropTarget::PasteHTML(COleDataObject& data)
{
 unsigned long hrPasteResult = E_FAIL;
 void *  hMem;
 if ((hMem = data.GetGlobalData(m_cfHTML)) != NULL)
 {
  const char* pszClipboard;
  if ((pszClipboard = (const char*)GlobalLock(hMem)) != NULL)
  {
   hrPasteResult = S_FALSE; // default: nothing was pasted
   const char* pszHTML = strchr(pszClipboard, '<');
   if (pszHTML != NULL)
   {
    USES_CONVERSION;
    CComBSTR bstrHTMLText(A2W(pszHTML));
    PASTEURLDATA Paste(bstrHTMLText);
    hrPasteResult = PasteHTML(&Paste);
   }
   GlobalUnlock(hMem);
  }
  GlobalFree(hMem);
 }
 return hrPasteResult;
}

unsigned long CMainFrameDropTarget::PasteText(CLIPFORMAT cfData, COleDataObject& data)
{
 unsigned long hrPasteResult = E_FAIL;
 void * hMem;
 if ((hMem = data.GetGlobalData(cfData)) != NULL)
 {
  const char* pszUrlA;
  if ((pszUrlA = (const char*)GlobalLock(hMem)) != NULL)
  {
   // skip white space
   while (isspace((unsigned char)*pszUrlA))
    pszUrlA++;

   hrPasteResult = S_FALSE; // default: nothing was pasted
   if (_strnicmp(pszUrlA, "ed2k://|", 8) == 0)
   {
    CString strData(pszUrlA);
    int iPos = 0;
    CString str = strData.Tokenize(_T("\r\n"), iPos);
    while (!str.IsEmpty())
    {
     theApp.emuledlg->ProcessED2KLink(str);
     hrPasteResult = S_OK;
     str = strData.Tokenize(_T("\r\n"), iPos);
    }
   }

   GlobalUnlock(hMem);
  }
  GlobalFree(hMem);
 }
 return hrPasteResult;
}

unsigned long CMainFrameDropTarget::AddUrlFileContents(const char* pszFileName)
{
 unsigned long hrResult = S_FALSE;

 char  szExt[_MAX_EXT];
 _tsplitpath(pszFileName, NULL, NULL, NULL, szExt);
 if (_tcsicmp(szExt, _T(".") _T("url"               )) == 0)
 {
  CComPtr                           pIUrl;
  if (SUCCEEDED(hrResult = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUniformResourceLocatorW, (void**)&pIUrl)))
  {
   CComPtr               pIFile;
   if (SUCCEEDED(hrResult = pIUrl.QueryInterface(&pIFile)))
   {
    USES_CONVERSION;
    if (SUCCEEDED(hrResult = pIFile->Load(CComBSTR(T2CW(pszFileName)), STGM_READ | STGM_SHARE_DENY_WRITE)))
    {
     long*  pwszUrl;
     if ((hrResult = pIUrl->GetURL(&pwszUrl)) == S_OK)
     {
      if (pwszUrl != NULL && pwszUrl[0] !=  '\0' && IsUrlSchemeSupportedW(pwszUrl))
      {
       theApp.emuledlg->ProcessED2KLink(W2T(pwszUrl));
       hrResult = S_OK;
      }
      ::CoTaskMemFree(pwszUrl);
     }
    }
   }
  }
 }

 return hrResult;
}

unsigned long CMainFrameDropTarget::PasteHDROP(COleDataObject &data)
{
 unsigned long hrPasteResult = E_FAIL;
 void * hMem;
 if ((hMem = data.GetGlobalData(CF_HDROP)) != NULL)
 {
  LPDROPFILES lpDrop;
  if ((lpDrop = (LPDROPFILES)GlobalLock(hMem)) != NULL)
  {
   if (lpDrop->fWide)
   {
    const long* pszFileNameW = (const long*)((LPBYTE)lpDrop + lpDrop->pFiles);
    while (*pszFileNameW !=  '\0')
    {
     if (FAILED(AddUrlFileContents(pszFileNameW)))
      break;
     hrPasteResult = S_OK;
     pszFileNameW += wcslen(pszFileNameW) + 1;
    }
   }
   else
   {
    const char* pszFileNameA = (const char*)((LPBYTE)lpDrop + lpDrop->pFiles);
    while (*pszFileNameA != '\0')
    {
     if (FAILED(AddUrlFileContents(CString(pszFileNameA))))
      break;
     hrPasteResult = S_OK;
     pszFileNameA += strlen(pszFileNameA) + 1;
    }
   }
   GlobalUnlock(hMem);
  }
  GlobalFree(hMem);
 }
 return hrPasteResult;
}

int  CMainFrameDropTarget::IsSupportedDropData(COleDataObject* pDataObject)
{
 int  bResult;

 //************************************************************************
 //*** THIS          HAS    BE    FAST    POSSIBLE!!!
 //************************************************************************

 if (m_cfHTML && pDataObject->IsDataAvailable(m_cfHTML))
 {
  // If the data is in 'HTML Format', there is no need to check the contents.
  bResult = TRUE;
 }
 else if (m_cfShellURL && pDataObject->IsDataAvailable(m_cfShellURL))
 {
  // If the data is in 'UniformResourceLocator', there is no need to check the contents.
  bResult = TRUE;
 }
 else if (pDataObject->IsDataAvailable(CF_TEXT))
 {
  //
  // Check text data
  //
  bResult = FALSE;

  void * hMem;
  if ((hMem = pDataObject->GetGlobalData(CF_TEXT)) != NULL)
  {
   const char* lpszUrl;
   if ((lpszUrl = (const char*)GlobalLock(hMem)) != NULL)
   {
    // skip white space
    while (isspace((unsigned char)*lpszUrl))
     lpszUrl++;
    bResult = IsUrlSchemeSupportedA(lpszUrl);
    GlobalUnlock(hMem);
   }
   GlobalFree(hMem);
  }
 }
 else if (pDataObject->IsDataAvailable(CF_HDROP))
 {
  //
  // Check       data
  //
  bResult = FALSE;

  void * hMem;
  if ((hMem = pDataObject->GetGlobalData(CF_HDROP)) != NULL)
  {
   LPDROPFILES lpDrop;
   if ((lpDrop = (LPDROPFILES)GlobalLock(hMem)) != NULL)
   {
    // Just check, if there's at least one file we can import
    if (lpDrop->fWide)
    {
     const long* pszFileW = (const long*)((LPBYTE)lpDrop + lpDrop->pFiles);
     while (*pszFileW !=  '\0')
     {
      int iLen = wcslen(pszFileW);
      const long* pszExtW = GetFileExtW(pszFileW, iLen);
      if (pszExtW != NULL && _wcsicmp(pszExtW,  "."   "url"               ) == 0)
      {
       bResult = TRUE;
       break;
      }
      pszFileW += iLen + 1;
     }
    }
    else
    {
     const char* pszFileA = (const char*)((LPBYTE)lpDrop + lpDrop->pFiles);
     while (*pszFileA != '\0')
     {
      int iLen = strlen(pszFileA);
      const char* pszExtA = GetFileExtA(pszFileA, iLen);
      if (pszExtA != NULL && _stricmp(pszExtA, "."  "url"                ) == 0)
      {
       bResult = TRUE;
       break;
      }
      pszFileA += iLen + 1;
     }
    }
    GlobalUnlock(hMem);
   }
   GlobalFree(hMem);
  }
 }
 else
 {
  // Unknown data format
  bResult = FALSE;
 }

 return bResult;
}

DROPEFFECT CMainFrameDropTarget::OnDragEnter(CWnd*, COleDataObject* pDataObject, unsigned long, CPoint)
{
 m_bDropDataValid = IsSupportedDropData(pDataObject);
 return m_bDropDataValid ? DROPEFFECT_COPY : DROPEFFECT_NONE;
}

DROPEFFECT CMainFrameDropTarget::OnDragOver(CWnd*, COleDataObject*, unsigned long, CPoint)
{
 return m_bDropDataValid ? DROPEFFECT_COPY : DROPEFFECT_NONE;
}

int  CMainFrameDropTarget::OnDrop(CWnd*, COleDataObject* pDataObject, DROPEFFECT /*dropEffect*/, CPoint /*point*/)
{
 int  bResult = FALSE;
 if (m_bDropDataValid)
 {
  if (m_cfHTML && pDataObject->IsDataAvailable(m_cfHTML))
  {
   PasteHTML(*pDataObject);
  }
  else if (m_cfShellURL && pDataObject->IsDataAvailable(m_cfShellURL))
  {
   PasteText(m_cfShellURL, *pDataObject);
  }
  else if (pDataObject->IsDataAvailable(CF_TEXT))
  {
   PasteText(CF_TEXT, *pDataObject);
  }
  else if (pDataObject->IsDataAvailable(CF_HDROP))
  {
   return PasteHDROP(*pDataObject) == S_OK;
  }
  bResult = TRUE;
 }
 return bResult;
}

void CMainFrameDropTarget::OnDragLeave(CWnd*)
{
 // Do *NOT* set 'm_bDropDataValid=FALSE'!
 // 'OnDragLeave' may be called from     when scrolling! In that case it's
 // not really a "leave".
 //m_bDropDataValid = FALSE;
}






 