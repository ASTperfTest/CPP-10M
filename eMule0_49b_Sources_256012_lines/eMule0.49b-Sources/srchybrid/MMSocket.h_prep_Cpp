//this file is part of eMule
//Copyright (C)2003 Merkur ( devs@emule-project.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

void INCLUDEREPLACE(){CX_INCL("SafeFile.h");}

class CMMServer;

//****** Outgoing Packets Class
class CMMPacket
{
public:
 CMMPacket(uint8 byOpcode) {m_pBuffer = new CMemFile; m_pBuffer->Write(&byOpcode,1); m_bSpecialHeader = false;}
 ~CMMPacket()    {delete m_pBuffer;}
 void WriteByte(uint8 write)  {m_pBuffer->Write(&write,1);}
 void WriteShort(uint16 write) {m_pBuffer->Write(&write,2);}
 void WriteInt(uint32 write)  {m_pBuffer->Write(&write,4);}
 void WriteInt64(uint64 write) {m_pBuffer->Write(&write,8);}
 void WriteString(CStringA write){
  uint8 len = (write.GetLength() > 255) ? (uint8)255 : (uint8)write.GetLength();
  WriteByte(len);
  m_pBuffer->Write(const_cast       ((const char*)write), len);
 }
 void WriteString(CString write){
  CStringA strA(write);
  WriteString(strA);
 }
 CMemFile* m_pBuffer;
 bool   m_bSpecialHeader;
};

//****** Incoming Packets Class
class CMMData:        CSafeMemFile
{
public:
 CMMData(char* pData,uint32 nSize):CSafeMemFile((unsigned char*)pData,nSize) {}

 uint8 ReadByte(){
  uint8 buf;
  Read(&buf,1);
  return buf;
 }
 uint16 ReadShort(){
  uint16 buf;
  Read(&buf,2);
  return buf;
 }
 uint32 ReadInt(){
  uint32 buf;
  Read(&buf,4);
  return buf;
 }
 uint64 ReadInt64(){
  uint64 buf;
  Read(&buf,8);
  return buf;
 }
 CString ReadString(){
  uint8 buf;
  char str[256];
  buf = ReadByte();
  Read(str,buf);
  return CString(str,buf);
 }
};

//****** Socket
class CMMSocket:        CAsyncSocket
{
public:
 CMMSocket(CMMServer* pOwner);
 ~CMMSocket(void);
 bool SendPacket(CMMPacket* packet, bool bQueueFirst = false);
 bool m_bClosed;
 uint32 m_dwTimedShutdown;
protected:
 void OnReceive(int nErrorCode);
 void OnClose(int nErrorCode);
 void Close();
 void OnRequestReceived(char* pHeader, unsigned long dwHeaderLen, char* pData, unsigned long dwDataLen);
 void OnSend(int nErrorCode);
 void CheckForClosing();
private:
 char* m_pBuf;
 unsigned long m_dwRecv;
 unsigned long m_dwBufSize;
 unsigned long m_dwHttpHeaderLen;
 unsigned long m_dwHttpContentLen;
 CMMServer* m_pOwner;
 char*   m_pSendBuffer;
 uint32   m_nSendLen;
 uint32   m_nSent;

 CTypedPtrList                       m_PacketQueue;
};

//****** Listening Socket
class CListenMMSocket:        CAsyncSocket
{
public:
 CListenMMSocket(CMMServer* pOwner);
 ~CListenMMSocket(void);
 bool Create();
 void Process();
 virtual void OnAccept(int nErrorCode);
protected:
 void DeleteClosedSockets();
private:
 CMMServer* m_pOwner;
 CTypedPtrList                       m_socket_list;
};




//opcodes



























// tags


















// OK = 0x01




// failed = 0x00
// OK = 0x01














 