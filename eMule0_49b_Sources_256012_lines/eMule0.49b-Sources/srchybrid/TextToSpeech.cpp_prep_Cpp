//this file is part of eMule
//Copyright (C)2002-2005 Merkur ( devs@emule-project.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE. See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
void INCLUDEREPLACE(){CX_INCL("stdafx.h");}


// NOTE: If you get a compile error due to missing 'sapi.h', look at "emule_site_config.h" for further information.
void INCLUDEREPLACE(){CX_INCL("sapi.h");}
      //HAVE_SAPI_H
void INCLUDEREPLACE(){CX_INCL("emule.h");}
void INCLUDEREPLACE(){CX_INCL("emuleDlg.h");}
void INCLUDEREPLACE(){CX_INCL("TextToSpeech.h");}




static char THIS_FILE[] =  "FILE" ;




///////////////////////////////////////////////////////////////////////////////
// CTextToSpeech

class CTextToSpeech
{
public:
 ~CTextToSpeech();
 CTextToSpeech();

 bool CreateTTS();
 void ReleaseTTS();
 bool IsActive() const { return m_pISpVoice != NULL; }
 bool Speak(const char* psz);

protected:
 long m_lTTSLangID;
 CComPtr           m_pISpVoice;
};

CTextToSpeech::CTextToSpeech()
{
 m_lTTSLangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
}

CTextToSpeech::~CTextToSpeech()
{
 ASSERT( m_pISpVoice == NULL );
 ReleaseTTS();
}

bool CTextToSpeech::CreateTTS()
{
 bool bResult = FALSE;
 if (m_pISpVoice == NULL)
 {
  unsigned long hr;
  if (SUCCEEDED(hr = m_pISpVoice.CoCreateInstance(CLSID_SpVoice)))
  {
   m_lTTSLangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
   bResult = TRUE;
  }
 }
 return bResult;
}

void CTextToSpeech::ReleaseTTS()
{
 m_lTTSLangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
 m_pISpVoice.Release();
}

bool CTextToSpeech::Speak(const char* pwsz)
{
 bool bResult = false;
 USES_CONVERSION;
 if (m_pISpVoice)
 {
  if (SUCCEEDED(m_pISpVoice->Speak(T2CW(pwsz), SPF_ASYNC | SPF_IS_NOT_XML, NULL)))
   bResult = true;
 }
 return bResult;
}

///////////////////////////////////////////////////////////////////////////////
CTextToSpeech theTextToSpeech;
static bool s_bTTSDisabled = false;
static bool s_bInitialized = false;




bool Speak(const char* pszSay)
{

 if (theApp.emuledlg == NULL || !theApp.emuledlg->IsRunning())
  return false;
 if (s_bTTSDisabled)
  return false;

 if (!s_bInitialized)
 {
  s_bInitialized = true;
  if (!theTextToSpeech.CreateTTS())
   return false;
 }
 return theTextToSpeech.Speak(pszSay);




}

void ReleaseTTS()
{

 theTextToSpeech.ReleaseTTS();
 s_bInitialized = false;
      //HAVE_SAPI_H
}

void CloseTTS()
{

 ReleaseTTS();
 s_bTTSDisabled = true;
      //HAVE_SAPI_H
}

bool IsSpeechEngineAvailable()
{

 if (s_bTTSDisabled)
  return false;

 static bool _bIsAvailable = false;
 static bool _bCheckedAvailable = false;
 if (!_bCheckedAvailable)
 {
  _bCheckedAvailable = true;
  if (theTextToSpeech.IsActive())
  {
   _bIsAvailable = true;
  }
  else
  {
   _bIsAvailable = theTextToSpeech.CreateTTS();
   theTextToSpeech.ReleaseTTS();
  }
 }
 return _bIsAvailable;



}






 