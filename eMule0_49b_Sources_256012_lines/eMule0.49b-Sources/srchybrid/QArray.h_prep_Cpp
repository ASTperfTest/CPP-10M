/********************************************************************************************
* MOD-NAME      : QArray.h
* long-NAME     : QuickSort algorithm enabled CArray
*
* AUTHOR        : Martin Ziacek, Martin.Ziacek@swh.sk, http://www.swh.sk
* COPYRIGHT     : 1999 Martin Ziacek
* DEPARTMENT    : SWH s.r.o
* TELEPHONE     : +421 7 59684147
* CREATION-DATE : 1.5.1999 8:27:23
* SP-NO         :
* FUNCTION      : Implementation of QuickSort algorithm as template for array class
*                 and template for simple function QuickSort()
*
*********************************************************************************************/



//////////////////////////////////////////////////////////////////////////
// QuickSort functions
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// QuickSortRecursive - core of algorithm, do not call it, use QuickSort,
// see below
                   void QuickSortRecursive(T *pArr, int d, int h, int  bAscending)
{
 int i,j;
 T str;

 i = h;
 j = d;

 str = pArr[((int) ((d+h) / 2))];

 do {

  if (bAscending) {
   while (pArr[j] < str) j++;
   while (pArr[i] > str) i--;
  } else {
   while (pArr[j] > str) j++;
   while (pArr[i] < str) i--;
  }

  if ( i >= j ) {

   if ( i != j ) {
    T zal;

    zal = pArr[i];
    pArr[i] = pArr[j];
    pArr[j] = zal;

   }

   i--;
   j++;
  }
 } while (j <= i);

 if (d < i) QuickSortRecursive(pArr,d,i,bAscending);
 if (j < h) QuickSortRecursive(pArr,j,h,bAscending);
}

//////////////////////////////////////////////////////////////////////////
// QuickSort - entry to algorithm
//
// T *pArr   ... pointer of array to sort
// int iSize  ... size of array T *pArr
// int  bAscending ... if bAscending == TRUE, then sort ascending,
//      otherwise descending
//
// return      if no error, error can be bad parameter, call ::GetLastError()
// if QuickSort returned      
                   int  QuickSort(T *pArr, int iSize, int  bAscending = TRUE)
{
 int  rc = TRUE;

 if (iSize > 1) {

  try {

   int low = 0,
    high = iSize - 1;

   QuickSortRecursive(pArr,low,high,bAscending);

  } catch (...) {
   ::SetLastError(ERROR_INVALID_PARAMETER);
   rc = FALSE;
  }

 } else {
  ::SetLastError(ERROR_INVALID_PARAMETER);
  rc = FALSE;
 }

 return rc;
}

//////////////////////////////////////////////////////////////////////////
// CQArray
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// CQArray declaration

                             class CQArray :        CArray
{
public:
 void QuickSort(int  bAscending = TRUE);
};

//////////////////////////////////////////////////////////////////////////
// CQArray implementation

//////////////////////////////////////////////////////////////////////////
// QuickSort - entry to algorithm
//
// int  bAscending ... if bAscending == TRUE, then sort ascending,
//      otherwise descending
//
                             void CQArray      ::QuickSort(int  bAscending/* = TRUE*/)
{
 if (GetSize() > 1) {
  ::QuickSort(GetData(),GetSize(),bAscending);
 }
}






 