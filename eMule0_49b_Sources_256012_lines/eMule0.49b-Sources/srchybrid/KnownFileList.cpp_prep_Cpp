//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
void INCLUDEREPLACE(){CX_INCL("stdafx.h");}
void INCLUDEREPLACE(){CX_INCL("io.h");}
void INCLUDEREPLACE(){CX_INCL("emule.h");}
void INCLUDEREPLACE(){CX_INCL("SharedFileList.h");}
void INCLUDEREPLACE(){CX_INCL("KnownFileList.h");}
void INCLUDEREPLACE(){CX_INCL("KnownFile.h");}
void INCLUDEREPLACE(){CX_INCL("opcodes.h");}
void INCLUDEREPLACE(){CX_INCL("Preferences.h");}
void INCLUDEREPLACE(){CX_INCL("SafeFile.h");}
void INCLUDEREPLACE(){CX_INCL("OtherFunctions.h");}
void INCLUDEREPLACE(){CX_INCL("UpDownClient.h");}
void INCLUDEREPLACE(){CX_INCL("DownloadQueue.h");}
void INCLUDEREPLACE(){CX_INCL("emuledlg.h");}
void INCLUDEREPLACE(){CX_INCL("TransferWnd.h");}
void INCLUDEREPLACE(){CX_INCL("Log.h");}
void INCLUDEREPLACE(){CX_INCL("packets.h");}
void INCLUDEREPLACE(){CX_INCL("MD5Sum.h");}




static char THIS_FILE[] =  "FILE" ;










CKnownFileList::CKnownFileList()
{
 m_Files_map.InitHashTable(2063);
 m_mapCancelledFiles.InitHashTable(1031);
 accepted = 0;
 requested = 0;
 transferred = 0;
 m_dwCancelledFilesSeed = 0;
 m_nLastSaved = ::GetTickCount();
 Init();
}

CKnownFileList::~CKnownFileList()
{
 Clear();
}

bool CKnownFileList::Init()
{
 return LoadKnownFiles() && LoadCancelledFiles();
}

bool CKnownFileList::LoadKnownFiles()
{
 CString fullpath = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR);
 fullpath.Append(_T("known.met")   );
 CSafeBufferedFile file;
 CFileException fexp;
 if (!file.Open(fullpath,CFile::modeRead|CFile::osSequentialScan|CFile::typeBinary|CFile::shareDenyWrite, &fexp)){
  if (fexp.m_cause != CFileException::fileNotFound){
   CString strError(_T("Failed to load ") _T("known.met")    _T(" file"));
   char  szError[MAX_CFEXP_ERRORMSG];
   if (fexp.GetErrorMessage(szError, ARRSIZE(szError))){
    strError += _T(" - ");
    strError += szError;
   }
   LogError(LOG_STATUSBAR, _T("%s"), strError);
  }
  return false;
 }
 setvbuf(file.m_pStream, NULL, _IOFBF, 16384);

 CKnownFile* pRecord = NULL;
 try {
  uint8 header = file.ReadUInt8();
  if (header != MET_HEADER && header != MET_HEADER_I64TAGS){
   file.Close();
   LogError(LOG_STATUSBAR, GetResString(IDS_ERR_SERVERMET_BAD));
   return false;
  }
  AddDebugLogLine(false, _T("Known.met file version is %u (%s support 64bit tags)"), header, (header == MET_HEADER) ? _T("doesn't") : _T("does"));

  unsigned int RecordsNumber = file.ReadUInt32();
  for (unsigned int i = 0; i < RecordsNumber; i++) {
   pRecord = new       CKnownFile();
   if (!pRecord->LoadFromFile(&file)){
    TRACE(_T("*** Failed to load entry %u (name=%s  hash=%s  size=%I64u  parthashs=%u expected parthashs=%u) from known.met\n"), i,
     pRecord->GetFileName(), md4str(pRecord->GetFileHash()), pRecord->GetFileSize(), pRecord->GetHashCount(), pRecord->GetED2KPartHashCount());
    delete pRecord;
    pRecord = NULL;
    continue;
   }
   SafeAddKFile(pRecord);
   pRecord = NULL;
  }
  file.Close();
 }
 catch(CFileException* error){
  if (error->m_cause == CFileException::endOfFile)
   LogError(LOG_STATUSBAR, GetResString(IDS_ERR_SERVERMET_BAD));
  else{
   char  buffer[MAX_CFEXP_ERRORMSG];
   error->GetErrorMessage(buffer, ARRSIZE(buffer));
   LogError(LOG_STATUSBAR, GetResString(IDS_ERR_SERVERMET_UNKNOWN),buffer);
  }
  error->Delete();
  delete pRecord;
  return false;
 }

 return true;
}

bool CKnownFileList::LoadCancelledFiles(){
// cancelled.met Format: <Header 1 = MET_HEADER + 0x01><Version 1 = 0x01             >                 [                         [Tags TagCount] Count]
 if (!thePrefs.IsRememberingCancelledFiles())
  return true;
 CString fullpath = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR);
 fullpath.Append(_T("cancelled.met")   );
 CSafeBufferedFile file;
 CFileException fexp;
 if (!file.Open(fullpath,CFile::modeRead|CFile::osSequentialScan|CFile::typeBinary|CFile::shareDenyWrite, &fexp)){
  if (fexp.m_cause != CFileException::fileNotFound){
   CString strError(_T("Failed to load ") _T("cancelled.met")    _T(" file"));
   char  szError[MAX_CFEXP_ERRORMSG];
   if (fexp.GetErrorMessage(szError, ARRSIZE(szError))){
    strError += _T(" - ");
    strError += szError;
   }
   LogError(LOG_STATUSBAR, _T("%s"), strError);
  }
  return false;
 }
 setvbuf(file.m_pStream, NULL, _IOFBF, 16384);
 uchar ucHash[16];
 try {
  bool bOldVersion = false;
  uint8 header = file.ReadUInt8();
  if (header != MET_HEADER + 0x01){
   if (header == MET_HEADER          ){
    bOldVersion = true;
    DebugLog(_T("Deprecated version of cancelled.met found, converting to new       version"));
   }
   else{
    file.Close();
    return false;
   }
  }
  uint8 byVersion = 0;
  if (!bOldVersion){
   byVersion = file.ReadUInt8();
   if (byVersion > 0x01             ){
    file.Close();
    return false;
   }

   m_dwCancelledFilesSeed = file.ReadUInt32();
  }
  if (m_dwCancelledFilesSeed == 0) {
   ASSERT( bOldVersion || file.GetLength() <= 10 );
   m_dwCancelledFilesSeed = (GetRandomUInt32() % 0xFFFFFFFE) + 1;
  }

  unsigned int RecordsNumber = file.ReadUInt32();
  for (unsigned int i = 0; i < RecordsNumber; i++) {
   file.ReadHash16(ucHash);
   uint8 nCount = file.ReadUInt8();
   // for compatibility with future versions which may add more data than just the hash
   for (unsigned int j = 0; j < nCount; j++) {
    CTag tag(&file, false);
   }
   if (bOldVersion){
    // convert old real hash to new       hashash
    uchar pachSeedHash[20];
    PokeUInt32(pachSeedHash, m_dwCancelledFilesSeed);
    md4cpy(pachSeedHash + 4, ucHash);
    MD5Sum md5(pachSeedHash, sizeof(pachSeedHash));
    md4cpy(ucHash, md5.GetRawHash());
   }
   m_mapCancelledFiles.SetAt(CSKey(ucHash), 1);
  }
  file.Close();
 }
 catch(CFileException* error){
  if (error->m_cause == CFileException::endOfFile)
   LogError(LOG_STATUSBAR, GetResString(IDS_ERR_CONFIGCORRUPT), _T("cancelled.met")   );
  else{
   char  buffer[MAX_CFEXP_ERRORMSG];
   error->GetErrorMessage(buffer, ARRSIZE(buffer));
   LogError(LOG_STATUSBAR, GetResString(IDS_ERR_FAILEDTOLOAD), _T("cancelled.met")   , buffer);
  }
  error->Delete();
  return false;
 }
 return true;
}

void CKnownFileList::Save()
{
 if (thePrefs.GetLogFileSaving())
  AddDebugLogLine(false, _T("Saving known files list file \"%s\""), _T("known.met")   );
 m_nLastSaved = ::GetTickCount();
 CString fullpath = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR);
 fullpath += _T("known.met")   ;
 CSafeBufferedFile file;
 CFileException fexp;
 if (!file.Open(fullpath, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary|CFile::shareDenyWrite, &fexp)){
  CString strError(_T("Failed to save ") _T("known.met")    _T(" file"));
  char  szError[MAX_CFEXP_ERRORMSG];
  if (fexp.GetErrorMessage(szError, ARRSIZE(szError))){
   strError += _T(" - ");
   strError += szError;
  }
  LogError(LOG_STATUSBAR, _T("%s"), strError);
 }
 else{
  setvbuf(file.m_pStream, NULL, _IOFBF, 16384);

  try{
   file.WriteUInt8(0); // we will write the version tag later depending if any large files are on the list
   unsigned int nRecordsNumber = 0;
   bool bContainsAnyLargeFiles = false;
   file.WriteUInt32(nRecordsNumber);
   POSITION pos = m_Files_map.GetStartPosition();
   while( pos != NULL )
   {
    CKnownFile* pFile;
    CCKey key;
    m_Files_map.GetNextAssoc( pos, key, pFile );
    if (!thePrefs.IsRememberingDownloadedFiles() && !theApp.sharedfiles->IsFilePtrInList(pFile)){
     continue;
    }
    else{
     pFile->WriteToFile(&file);
     nRecordsNumber++;
     if (pFile->IsLargeFile())
      bContainsAnyLargeFiles = true;
    }
   }
   file.SeekToBegin();
   file.WriteUInt8(bContainsAnyLargeFiles ? MET_HEADER_I64TAGS : MET_HEADER);
   file.WriteUInt32(nRecordsNumber);

   if (thePrefs.GetCommitFiles() >= 2 || (thePrefs.GetCommitFiles() >= 1 && !theApp.emuledlg->IsRunning())){
    file.Flush(); // flush file stream buffers to disk buffers
    if (_commit(_fileno(file.m_pStream)) != 0) // commit disk buffers to disk
     AfxThrowFileException(CFileException::hardIO, GetLastError(), file.GetFileName());
   }
   file.Close();
  }
  catch(CFileException* error){
   CString strError(_T("Failed to save ") _T("known.met")    _T(" file"));
   char  szError[MAX_CFEXP_ERRORMSG];
   if (error->GetErrorMessage(szError, ARRSIZE(szError))){
    strError += _T(" - ");
    strError += szError;
   }
   LogError(LOG_STATUSBAR, _T("%s"), strError);
   error->Delete();
  }
 }


 if (thePrefs.GetLogFileSaving())
  AddDebugLogLine(false, _T("Saving known files list file \"%s\""), _T("cancelled.met")   );
  fullpath = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR);
 fullpath += _T("cancelled.met")   ;
 if (!file.Open(fullpath, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary|CFile::shareDenyWrite, &fexp)){
  CString strError(_T("Failed to save ") _T("cancelled.met")    _T(" file"));
  char  szError[MAX_CFEXP_ERRORMSG];
  if (fexp.GetErrorMessage(szError, ARRSIZE(szError))){
   strError += _T(" - ");
   strError += szError;
  }
  LogError(LOG_STATUSBAR, _T("%s"), strError);
 }
 else{
  setvbuf(file.m_pStream, NULL, _IOFBF, 16384);

  try{
   file.WriteUInt8(MET_HEADER + 0x01);
   file.WriteUInt8(0x01             );
   file.WriteUInt32(m_dwCancelledFilesSeed);
   if (!thePrefs.IsRememberingCancelledFiles()){
    file.WriteUInt32(0);
   }
   else{
    unsigned int nRecordsNumber = m_mapCancelledFiles.GetCount();
    file.WriteUInt32(nRecordsNumber);
    POSITION pos = m_mapCancelledFiles.GetStartPosition();
    while( pos != NULL )
    {
     int dwDummy;
     CSKey key;
     m_mapCancelledFiles.GetNextAssoc( pos, key, dwDummy );
     file.WriteHash16(key.m_key);
     file.WriteUInt8(0);
    }
   }

   if (thePrefs.GetCommitFiles() >= 2 || (thePrefs.GetCommitFiles() >= 1 && !theApp.emuledlg->IsRunning())){
    file.Flush(); // flush file stream buffers to disk buffers
    if (_commit(_fileno(file.m_pStream)) != 0) // commit disk buffers to disk
     AfxThrowFileException(CFileException::hardIO, GetLastError(), file.GetFileName());
   }
   file.Close();
  }
  catch(CFileException* error){
   CString strError(_T("Failed to save ") _T("cancelled.met")    _T(" file"));
   char  szError[MAX_CFEXP_ERRORMSG];
   if (error->GetErrorMessage(szError, ARRSIZE(szError))){
    strError += _T(" - ");
    strError += szError;
   }
   LogError(LOG_STATUSBAR, _T("%s"), strError);
   error->Delete();
  }
 }
}

void CKnownFileList::Clear()
{
 POSITION pos = m_Files_map.GetStartPosition();
 while( pos != NULL )
 {
  CKnownFile* pFile;
  CCKey key;
  m_Files_map.GetNextAssoc( pos, key, pFile );
     delete pFile;
 }
 m_Files_map.RemoveAll();
}

void CKnownFileList::Process()
{
 if (::GetTickCount() - m_nLastSaved > MIN2MS(11))
  Save();
}

bool CKnownFileList::SafeAddKFile(CKnownFile* toadd)
{
 bool bRemovedDuplicateSharedFile = false;
 CCKey key(toadd->GetFileHash());
 CKnownFile* pFileInMap;
 if (m_Files_map.Lookup(key, pFileInMap))
 {
  TRACE(_T("%hs: Already in known list:   %s \"%s\"\n"), __FUNCTION__, md4str(pFileInMap->GetFileHash()), pFileInMap->GetFileName());
  TRACE(_T("%hs: Old entry replaced with: %s \"%s\"\n"), __FUNCTION__, md4str(toadd->GetFileHash()), toadd->GetFileName());

  // if we hash files which are already in known file list and add them later (when the hashing thread is finished),
  // we can not delete any already available entry from known files list. that entry can already be used by the
  // shared file list -> crash.

  m_Files_map.RemoveKey(CCKey(pFileInMap->GetFileHash()));
  //This can happen in a couple situations..
  //File was renamed outside of eMule..
  //A user decided to redownload a file he has downloaded and unshared..
  //RemovingKeyWords   believe is not thread safe if I'm looking at this right.
  //Not sure of a good solution yet..
  if (theApp.sharedfiles)
  {

   // This may crash the client because of dangling ptr in shared files ctrl.
   // This may happen if a file is re-shared which is also currently downloaded.
   // After the file was there is a dangl. ptr in shared files
   // ctrl.
   // Actually that's also wrong in some cases: Keywords are not always removed
   // because the wrong ptr is used to search for in keyword publish list.
   theApp.sharedfiles->RemoveKeywords(pFileInMap);














   ASSERT( !theApp.sharedfiles->IsFilePtrInList(pFileInMap) );
  }
  //Double check to make sure this is the same file as it's possible that a two files have the same hash.
  //Maybe in the furture we can change the client to not just use Hash as a key throughout the entire client..
  ASSERT( toadd->GetFileSize() == pFileInMap->GetFileSize() );
  ASSERT( toadd != pFileInMap );
  if (toadd->GetFileSize() == pFileInMap->GetFileSize())
   toadd->statistic.MergeFileStats(&pFileInMap->statistic);

  ASSERT( theApp.sharedfiles==NULL || !theApp.sharedfiles->IsFilePtrInList(pFileInMap) );
  ASSERT( theApp.downloadqueue==NULL || !theApp.downloadqueue->IsPartFile(pFileInMap) );

  // Quick fix: If we downloaded already downloaded files again and if those files all had the same file names
  // and were renamed during file completion, we have a pending ptr in transfer window.
  if (theApp.emuledlg && theApp.emuledlg->transferwnd && theApp.emuledlg->transferwnd->downloadlistctrl.m_hWnd)
   theApp.emuledlg->transferwnd->downloadlistctrl.RemoveFile((CPartFile*)pFileInMap);

  delete pFileInMap;
 }
 m_Files_map.SetAt(key, toadd);
 if (bRemovedDuplicateSharedFile) {
  theApp.sharedfiles->SafeAddKFile(toadd);
 }
 return true;
}

CKnownFile* CKnownFileList::FindKnownFile(const char* filename, uint32 date, uint64 size) const
{
 POSITION pos = m_Files_map.GetStartPosition();
 while (pos != NULL)
 {
  CKnownFile* cur_file;
  CCKey key;
  m_Files_map.GetNextAssoc(pos, key, cur_file);
  if (cur_file->GetUtcFileDate() == date && cur_file->GetFileSize() == size && !_tcscmp(filename, cur_file->GetFileName()))
   return cur_file;
 }
 return NULL;
}

CKnownFile* CKnownFileList::FindKnownFileByPath(const CString& sFilePath) const
{
 POSITION pos = m_Files_map.GetStartPosition();
 while (pos != NULL)
 {
  CKnownFile* cur_file;
  CCKey key;
  m_Files_map.GetNextAssoc(pos, key, cur_file);
  if (!cur_file->GetFilePath().CompareNoCase(sFilePath))
   return cur_file;
 }
 return NULL;
}

CKnownFile* CKnownFileList::FindKnownFileByID(const uchar* hash) const
{
 if (hash)
 {
  CKnownFile* found_file;
  CCKey key(hash);
  if (m_Files_map.Lookup(key, found_file))
   return found_file;
 }
 return NULL;
}

bool CKnownFileList::IsKnownFile(const CKnownFile* file) const
{
 if (file)
  return FindKnownFileByID(file->GetFileHash()) != NULL;
 return false;
}

bool CKnownFileList::IsFilePtrInList(const CKnownFile* file) const
{
 if (file)
 {
  POSITION pos = m_Files_map.GetStartPosition();
  while (pos)
  {
   CCKey key;
   CKnownFile* cur_file;
   m_Files_map.GetNextAssoc(pos, key, cur_file);
   if (file == cur_file)
    return true;
  }
 }
 return false;
}

void CKnownFileList::AddCancelledFileID(const uchar* hash){
 if (thePrefs.IsRememberingCancelledFiles()){
  if (m_dwCancelledFilesSeed == 0) {
   m_dwCancelledFilesSeed = (GetRandomUInt32() % 0xFFFFFFFE) + 1;
  }
  uchar pachSeedHash[20];
  PokeUInt32(pachSeedHash, m_dwCancelledFilesSeed);
  md4cpy(pachSeedHash + 4, hash);
  MD5Sum md5(pachSeedHash, sizeof(pachSeedHash));
  md4cpy(pachSeedHash, md5.GetRawHash());
  m_mapCancelledFiles.SetAt(CSKey(pachSeedHash), 1);
 }
}

bool CKnownFileList::IsCancelledFileByID(const uchar* hash) const
{
 if (thePrefs.IsRememberingCancelledFiles()){
  uchar pachSeedHash[20];
  PokeUInt32(pachSeedHash, m_dwCancelledFilesSeed);
  md4cpy(pachSeedHash + 4, hash);
  MD5Sum md5(pachSeedHash, sizeof(pachSeedHash));
  md4cpy(pachSeedHash, md5.GetRawHash());

  int dwDummy;
  if (m_mapCancelledFiles.Lookup(CSKey(pachSeedHash), dwDummy)){
   return true;
  }
 }
 return false;
}

void CKnownFileList::CopyKnownFileMap(CMap<CCKey,const CCKey&,CKnownFile*,CKnownFile*> &Files_Map)
{
 if (!m_Files_map.IsEmpty())
 {
  POSITION pos = m_Files_map.GetStartPosition();
  while (pos)
  {
   CCKey key;
   CKnownFile* cur_file;
   m_Files_map.GetNextAssoc(pos, key, cur_file);
   Files_Map.SetAt(key, cur_file);
  }
 }
}






 