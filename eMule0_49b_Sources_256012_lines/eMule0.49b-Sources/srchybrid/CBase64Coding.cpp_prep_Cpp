//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
void INCLUDEREPLACE(){CX_INCL("stdafx.h");}
void INCLUDEREPLACE(){CX_INCL("CBase64Coding.hpp");}





/*
** Author: Samuel R. Blackburn
** Internet: wfc@pobox.com
**
** You can use it any way you like as long as you don't try to sell it.
**
** Any attempt to sell     in source code form must have the permission
** of the original author. You can produce commercial executables with
** WFC but you can't sell WFC.
**
** Copyright, 2000, Samuel R. Blackburn
**
** $Workfile: CBase64Coding.cpp $
** $Revision: 14 $
** $Modtime: 5/12/00 3:39p $
** $Reuse Tracing Code: 1 $
*/

//Modified for use with CAsyncProxySocket, removed tracing code



static char THIS_FILE[]= "FILE" ;









static inline unsigned char __get_character( const unsigned char * buffer, const unsigned char * decoder_table, int& index, int size_of_buffer )
{
   unsigned char return_value = 0;

   do
   {
      if ( index >= size_of_buffer )
      {
         return( (0xFD)               );
      }

      return_value = buffer[ index ];
      index++;
   }
   while( return_value != ('=')                      &&
          decoder_table[ return_value ] == (0xFE)                     );

   return( return_value );
}

CBase64Coding::CBase64Coding()
{
}

CBase64Coding::~CBase64Coding()
{
}

int  CBase64Coding::Encode( const char * source, int len, char * destination_string )
{

   const char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

   int loop_index                = 0;
   int number_of_bytes_to_encode = len;

   unsigned char byte_to_add = 0;
   unsigned char byte_1      = 0;
   unsigned char byte_2      = 0;
   unsigned char byte_3      = 0;

   unsigned long number_of_bytes_encoded = (unsigned long) ( (double) number_of_bytes_to_encode / (double) 0.75 ) + 1;

   // Now add in the CR/LF pairs, each line is truncated at 72 characters

   // 2000-05-12
   // Thanks go to Ilia for finding a bug here.
   // I was using number_of_bytes_to_encode rather than number_of_bytes_encoded.

   number_of_bytes_encoded += (unsigned long)( ( ( number_of_bytes_encoded / (72)                                 ) + 1 ) * 2 );

   char * destination = destination_string;

   number_of_bytes_encoded = 0;

   while( loop_index < number_of_bytes_to_encode )
   {
      // Output the first byte

      byte_1 = source[ loop_index ];
      byte_to_add = alphabet[ ( byte_1 >> 2 ) ];

      destination[ number_of_bytes_encoded ] = static_cast        ( byte_to_add );
      number_of_bytes_encoded++;

      loop_index++;

      if ( loop_index >= number_of_bytes_to_encode )
      {
         // We're at the end of the data to encode

         byte_2 = 0;
         byte_to_add = alphabet[ ( ( ( byte_1 & 0x03 ) << 4 ) | ( ( byte_2 & 0xF0 ) >> 4 ) ) ];

         destination[ number_of_bytes_encoded ] = byte_to_add;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] =  ('=')                     ;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] =  ('=')                     ;

         // 1999-09-01
         // Thanks go to Yurong for finding a bug here.
         // We must      terminate the string before letting CString have the buffer back.

         destination[ number_of_bytes_encoded + 1 ] = 0;

         return( TRUE );
      }
      else
      {
         byte_2 = source[ loop_index ];
      }

      byte_to_add = alphabet[ ( ( ( byte_1 & 0x03 ) << 4 ) | ( ( byte_2 & 0xF0 ) >> 4 ) ) ];

      destination[ number_of_bytes_encoded ] = byte_to_add;
      number_of_bytes_encoded++;

      loop_index++;

      if ( loop_index >= number_of_bytes_to_encode )
      {
         // We ran out of bytes, we need to add the last half of byte_2 and pad
         byte_3 = 0;

         byte_to_add = alphabet[ ( ( ( byte_2 & 0x0F ) << 2 ) | ( ( byte_3 & 0xC0 ) >> 6 ) ) ];

         destination[ number_of_bytes_encoded ] = byte_to_add;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] = ('=')                     ;

         // 1999-09-01
         // Thanks go to Yurong for finding a bug here.
         // We must      terminate the string before letting CString have the buffer back.

         destination[ number_of_bytes_encoded + 1 ] = 0;

         return( TRUE );
      }
      else
      {
         byte_3 = source[ loop_index ];
      }

      loop_index++;

      byte_to_add = alphabet[ ( ( ( byte_2 & 0x0F ) << 2 ) | ( ( byte_3 & 0xC0 ) >> 6 ) ) ];

      destination[ number_of_bytes_encoded ] = byte_to_add;
      number_of_bytes_encoded++;

      byte_to_add = alphabet[ ( byte_3 & 0x3F ) ];

      destination[ number_of_bytes_encoded ] = byte_to_add;
      number_of_bytes_encoded++;

      if ( ( number_of_bytes_encoded % (72)                                 ) == 0 )
      {
         destination[ number_of_bytes_encoded ] = (13)           ;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] = (10)     ;
         number_of_bytes_encoded++;
      }
   }

   destination[ number_of_bytes_encoded ] = ('=')                     ;

   // 1999-09-01
   // Thanks go to Yurong for finding a bug here.
   // We must      terminate the string before letting CString have the buffer back.

   destination[ number_of_bytes_encoded + 1 ] = 0;

   return( TRUE );
}

// End of source





       WFC - CBase64Coding</TITLE>
<META name="keywords" content="WFC, MFC extension library, freeware class library, Win32, MIME encoding, base 64, source code">
<META name="description" content="This C++ class let's you      encode bytes to text using base64.">
</HEAD>



    CBase64Coding</H1>

$Revision: 14 $

    Description</H2>

This class gives you the ability to encode/decode data using base64.

    Constructors</H2>



            CBase64Coding</B>()
Constructs this object.

</DL>

    Methods</H2>



         int     <A NAME="Decode">Decode</A></B>( const CByteArray&amp; source, CByteArray&amp; destination )
int     Decode</B>( const CString&amp;    source, CByteArray&amp; destination )</PRE>
This method takes base64 encoded text and produces the bytes. It decodes
the base64 encoding.

         int     <A NAME="Encode">Encode</A></B>( const CByteArray&amp; source, CByteArray&amp; destination )
int     Encode</B>( const CByteArray&amp; source, CString&amp;    destination )</PRE>
This method takes bytes and turns them into base64 text.

</DL>

    Example</H2>
           #include &lt;wfc.h&gt;

int _tmain( int number_of_command_line_arguments, const char* command_line_arguments[] )
{
   <A HREF="WfcTrace.htm">WFCTRACEINIT</A>( TEXT( &quot;_tmain()&quot; ) );

   CByteArray bytes;

   get_file_contents( command_line_arguments[ 0 ], bytes );

      CBase64Coding</B> encoder;

   CString encoded_data;

   if ( encoder.Encode( bytes, encoded_data ) != FALSE )
   {
      _tprintf( TEXT( &quot;%s\n&quot;, (const char*) encoded_data );
   }
}</CODE></PRE>
       Copyright, 2000, <A HREF="mailto:wfc@pobox.com">Samuel R. Blackburn</A></I>
$Workfile: CBase64Coding.cpp $
$Modtime: 5/12/00 3:39p $
</BODY>

</HTML>







 