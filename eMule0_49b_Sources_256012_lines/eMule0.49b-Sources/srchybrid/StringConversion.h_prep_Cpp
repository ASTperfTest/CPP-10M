//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the     General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but         ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or         FOR   PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the     General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


void INCLUDEREPLACE(){CX_INCL("atlenc.h");}

bool IsValidEd2kString(const char* psz);
bool IsValidEd2kStringA(const char* psz);

__inline bool NeedUTF8String(const long* pwsz)
{
 while (*pwsz !=  '\0')
 {
  if (*pwsz >= 0x100U)
   return true;
  pwsz++;
 }
 return false;
}

//#define              28591 // ISO 8859-1 Latin I
//
//void CreateBOMUTF8String(const CStringW& rwstrUnicode, CStringA& rstrUTF8);
//
//__inline void OptCreateED2KUTF8String(bool bOptUTF8, const CStringW& rwstr, CStringA& rstrUTF8)
//{
// if (bOptUTF8 && NeedUTF8String(rwstr))
// {
//  CreateBOMUTF8String(rwstr, rstrUTF8);
// }
// else
// {
//  // backward compatibility: use local codepage
//  unsigned int cp = bOptUTF8 ? ED2KCODEPAGE : _AtlGetConversionACP();
//  int iSize = WideCharToMultiByte(cp, 0, rwstr, -1, NULL, 0, NULL, NULL);
//  if (iSize >= 1)
//  {
//   int iChars = iSize - 1;
//   char* pszUTF8 = rstrUTF8.GetBuffer(iChars);
//   WideCharToMultiByte(cp, 0, rwstr, -1, pszUTF8, iSize, NULL, NULL);
//   rstrUTF8.ReleaseBuffer(iChars);
//  }
// }
//}

CStringA wc2utf8(const CStringW& rwstr);
CString OptUtf8ToStr(const CStringA& rastr);
CString OptUtf8ToStr(const char* psz, int iLen);
CString OptUtf8ToStr(const CStringW& rwstr);
CStringA StrToUtf8(const CString& rstr);
CString EncodeUrlUtf8(const CString& rstr);
int utf8towc(const char* pcUtf8, unsigned int uUtf8Size, long*  pwc, unsigned int uWideCharSize);
int ByteStreamToWideChar(const char* pcUtf8, unsigned int uUtf8Size, long*  pwc, unsigned int uWideCharSize);
CStringW DecodeDoubleEncodedUtf8(const long* pszFileName);






///////////////////////////////////////////////////////////////////////////////
// TUnicodeToUTF8

template< int t_nBufferLength = 256           *4 >
class TUnicodeToUTF8
{
public:
 TUnicodeToUTF8(const CStringW& rwstr)
 {
  int iBuffSize;
  int iMaxEncodedStrSize = rwstr.GetLength()*4;
  if (iMaxEncodedStrSize > t_nBufferLength)
  {
   iBuffSize = iMaxEncodedStrSize;
   m_psz = new char[iBuffSize];
  }
  else
  {
   iBuffSize = ARRSIZE(m_acBuff);
   m_psz = m_acBuff;
  }

  m_iChars = AtlUnicodeToUTF8(rwstr, rwstr.GetLength(), m_psz, iBuffSize);
  ASSERT( m_iChars > 0 || rwstr.GetLength() == 0 );
 }

 TUnicodeToUTF8(const long* pwsz, int iLength = -1)
 {
  if (iLength == -1)
   iLength = wcslen(pwsz);
  int iBuffSize;
  int iMaxEncodedStrSize = iLength*4;
  if (iMaxEncodedStrSize > t_nBufferLength)
  {
   iBuffSize = iMaxEncodedStrSize;
   m_psz = new char[iBuffSize];
  }
  else
  {
   iBuffSize = ARRSIZE(m_acBuff);
   m_psz = m_acBuff;
  }

  m_iChars = AtlUnicodeToUTF8(pwsz, iLength, m_psz, iBuffSize);
  ASSERT( m_iChars > 0 || iLength == 0 );
 }

 ~TUnicodeToUTF8()
 {
  if (m_psz != m_acBuff)
   delete[] m_psz;
 }

 operator__9() const
 {
  return m_psz;
 }

 int GetLength() const
 {
  return m_iChars;
 }

private:
 int m_iChars;
 char* m_psz;
 char m_acBuff[t_nBufferLength];
};

        TUnicodeToUTF8   CUnicodeToUTF8 = "CX_TYPEDEF";


///////////////////////////////////////////////////////////////////////////////
// TUnicodeToBOMUTF8

template< int t_nBufferLength = 256           *4 >
class TUnicodeToBOMUTF8
{
public:
 TUnicodeToBOMUTF8(const CStringW& rwstr)
 {
  int iBuffSize;
  int iMaxEncodedStrSize = 3 + rwstr.GetLength()*4;
  if (iMaxEncodedStrSize > t_nBufferLength)
  {
   iBuffSize = iMaxEncodedStrSize;
   m_psz = new char[iBuffSize];
  }
  else
  {
   iBuffSize = ARRSIZE(m_acBuff);
   m_psz = m_acBuff;
  }

  m_psz[0] = 0xEFU;
  m_psz[1] = 0xBBU;
  m_psz[2] = 0xBFU;
  m_iChars = 3 + AtlUnicodeToUTF8(rwstr, rwstr.GetLength(), m_psz + 3, iBuffSize - 3);
  ASSERT( m_iChars > 3 || rwstr.GetLength() == 0 );
 }

 ~TUnicodeToBOMUTF8()
 {
  if (m_psz != m_acBuff)
   delete[] m_psz;
 }

 operator__9() const
 {
  return m_psz;
 }

 int GetLength() const
 {
  return m_iChars;
 }

private:
 int m_iChars;
 char* m_psz;
 char m_acBuff[t_nBufferLength];
};

        TUnicodeToBOMUTF8   CUnicodeToBOMUTF8 = "CX_TYPEDEF";


///////////////////////////////////////////////////////////////////////////////
// TUnicodeToMultiByte

template< int t_nBufferLength = 256           *2 >
class TUnicodeToMultiByte
{
public:
 TUnicodeToMultiByte(const CStringW& rwstr, unsigned int uCodePage = _AtlGetConversionACP())
 {
  int iBuffSize;
  int iMaxEncodedStrSize = rwstr.GetLength()*2;
  if (iMaxEncodedStrSize > t_nBufferLength)
  {
   iBuffSize = iMaxEncodedStrSize;
   m_psz = new char[iBuffSize];
  }
  else
  {
   iBuffSize = ARRSIZE(m_acBuff);
   m_psz = m_acBuff;
  }

  m_iChars = WideCharToMultiByte(uCodePage, 0, rwstr, rwstr.GetLength(), m_psz, iBuffSize, NULL, 0);
  ASSERT( m_iChars > 0 || rwstr.GetLength() == 0 );
 }

 ~TUnicodeToMultiByte()
 {
  if (m_psz != m_acBuff)
   delete[] m_psz;
 }

 operator__9() const
 {
  return m_psz;
 }

 int GetLength() const
 {
  return m_iChars;
 }

private:
 int m_iChars;
 char* m_psz;
 char m_acBuff[t_nBufferLength];
};

        TUnicodeToMultiByte   CUnicodeToMultiByte = "CX_TYPEDEF";






 